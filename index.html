<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EsquemApp - Visualizador de Red</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f7fafc;
        }
        .link, .cable-line {
            fill: none;
            stroke: #10b981; /* Green */
            stroke-width: 1.5px;
        }
        .connection-line {
            fill: none;
            stroke: #10b981; /* Green */
            stroke-width: 1.5px;
        }
        .node .symbol, .custom-element-group .symbol {
            stroke: #1f2937;
            stroke-width: 1.5px;
        }
        .custom-element-group .symbol.star {
            stroke: #0ea5e9; /* Sky blue */
            fill: #e0f2fe;
        }

        .annotation {
            stroke: #1f2937;    /* Dark Gray for node names */
            stroke-width: 1.5px;
        }
        .annotation.line-annotation,
        .annotation.dashed-line-annotation {
            stroke: #10b981; /* Green */
        }
        .node.se-node .symbol {
            fill: #ef4444;
        }
        
        .node text, .terminal-output-label, .custom-element-group text {
            font-size: 11px;
            font-family: 'Inter', sans-serif;
            fill: #1f2937;
            font-weight: 500;
            cursor: pointer;
            user-select: none;
        }
        
        .text-annotation {
            font-size: 11px;
            font-family: 'Inter', sans-serif;
            font-weight: 500; 
            fill: #1f2937;
            cursor: pointer;
            user-select: none;
            stroke: none;
        }
        .node.b-node text {
            fill: #800000; /* Burgundy */
        }

        #tooltip {
            position: absolute;
            text-align: center;
            padding: 8px;
            font: 12px sans-serif;
            background: rgba(0, 0, 0, 0.75);
            color: white;
            border-radius: 8px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
        }
        .loader {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #2563eb; /* Blue */
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .node.selected .symbol, .node.selected > rect, .node.selected > circle, .node.selected > path,
        .annotation.selected, .annotation-group.selected .annotation,
        .custom-element-group.selected .symbol, .custom-element-group.selected > g > .symbol {
            stroke: #10b981; /* Green */
            stroke-width: 2.5px;
        }
        .message-box {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: white;
            padding: 24px;
            border-radius: 12px;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            z-index: 1000;
            text-align: center;
            min-width: 320px;
        }
        .message-box button {
            margin-top: 15px;
            margin-left: 5px;
            margin-right: 5px;
            padding: 8px 15px;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.2s;
        }
         .message-box .btn-confirm { background-color: #2563eb; } /* Blue */
         .message-box .btn-confirm:hover { background-color: #1d4ed8; }
         .message-box .btn-danger { background-color: #ef4444; }
         .message-box .btn-danger:hover { background-color: #dc2626; }
         .message-box .btn-cancel { background-color: #6b7280; }
         .message-box .btn-cancel:hover { background-color: #4b5563; }

        .connector-rhombus {
            stroke: #10b981; /* Green */
            stroke-width: 1.5px;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
        }
        .connector-rhombus.manual-mode {
            cursor: move;
        }
        .connector-rhombus:hover {
            fill: #a7f3d0; /* Lighter Green */
        }
        .connector-rhombus.rhombus-selected {
            stroke: #10b981; /* Green */
            stroke-width: 2.5px;
            fill: #6ee7b7; /* Medium Green */
        }
        .node, .custom-element-group {
            transition: filter 0.2s ease-in-out;
        }
        .node:hover, .custom-element-group:hover {
            filter: drop-shadow(0 4px 6px rgba(0,0,0,0.1));
        }
        #info-panel {
            transition: transform 0.3s ease-in-out;
        }
        .tool-btn.active {
            background-color: #10b981 !important; /* Green */
            color: white !important;
        }
        #graph-svg.drawing-mode {
            cursor: crosshair;
        }
        .annotation-group, .custom-element-group {
            cursor: move;
        }
        .symbol-option {
            cursor: pointer;
            padding: 8px;
            border-radius: 6px;
            transition: background-color 0.2s;
        }
        .symbol-option:hover {
            background-color: #f3f4f6;
        }
        .symbol-option.active {
            background-color: #d1fae5; /* Lightest Green */
            border: 1px solid #a7f3d0; /* Lighter Green */
        }
        details > summary {
            list-style: none;
            cursor: pointer;
        }
        details > summary::-webkit-details-marker {
            display: none;
        }
        details > summary::after {
            content: '▸';
            float: right;
            transition: transform 0.2s;
        }
        details[open] > summary::after {
            transform: rotate(90deg);
        }
        .resize-handle {
            fill: #10b981; /* Green */
            stroke: white;
            stroke-width: 1px;
            opacity: 0;
            pointer-events: none;
        }
        .annotation-group.selected .resize-handle {
            opacity: 1;
            pointer-events: all;
        }
    </style>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
</head>
<body class="bg-gray-100 text-gray-800">

    <div id="tooltip"></div>
    <div id="message-box-container"></div>
    <div id="context-menu" class="absolute hidden bg-white border border-gray-300 rounded-md shadow-lg z-50">
        <ul class="py-1"></ul>
    </div>
    
    <!-- Modal for copying image -->
    <div id="copy-image-modal" class="fixed inset-0 bg-black bg-opacity-50 hidden items-center justify-center z-50">
        <div class="bg-white p-6 rounded-lg shadow-xl max-w-3xl w-full">
            <div class="flex justify-between items-center mb-4">
                <h3 class="text-lg font-bold">Copiar Imagen del Diagrama</h3>
                <button id="close-modal-btn" class="text-gray-500 hover:text-gray-800 text-2xl leading-none">&times;</button>
            </div>
            <p class="text-sm text-gray-600 mb-4">Haz clic derecho sobre la imagen y selecciona "Copiar imagen" para pegarla en otro programa.</p>
            <div class="border rounded-md p-2 bg-gray-100 max-h-[60vh] overflow-auto">
                <img id="image-to-copy" src="" alt="Vista previa del diagrama" class="max-w-full h-auto mx-auto">
            </div>
        </div>
    </div>


    <div class="flex h-screen">
        <!-- NEW: Tools Sidebar -->
        <div id="tools-sidebar" class="flex flex-col items-center space-y-2 p-2 bg-white shadow-md z-20 border-r border-gray-200">
            <button id="draw-ct-btn" title="Añadir CT" class="tool-btn p-2 text-gray-600 rounded-md bg-gray-200 hover:bg-gray-300 transition-colors">
                <svg class="w-6 h-6" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="-1 -1 26 26" stroke-width="1.5" stroke="currentColor">
                    <rect x="2" y="2" width="20" height="20" stroke="currentColor" fill="none"/>
                    <path stroke-linecap="round" stroke-linejoin="round" d="M12 6L6 16h12z" />
                </svg>
            </button>
            <button id="draw-seccionador-btn" title="Añadir Seccionador" class="tool-btn p-2 text-gray-600 rounded-md bg-gray-200 hover:bg-gray-300 transition-colors">
                <svg class="w-6 h-6" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M12 2L2 12l10 10 10-10L12 2z" />
                </svg>
            </button>
            <button id="draw-ellipse-btn" title="Elipse" class="tool-btn p-2 text-gray-600 rounded-md hover:bg-gray-100 transition-colors">
               <svg class="w-6 h-6" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><ellipse cx="12" cy="12" rx="10" ry="6"/></svg>
            </button>
            <button id="draw-rect-btn" title="Rectángulo" class="tool-btn p-2 text-gray-600 rounded-md hover:bg-gray-100 transition-colors">
                <svg class="w-6 h-6" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M2.25 3h19.5a2.25 2.25 0 012.25 2.25v13.5A2.25 2.25 0 0121.75 21H2.25A2.25 2.25 0 010 18.75V5.25A2.25 2.25 0 012.25 3z" /></svg>
            </button>
             <button id="draw-line-btn" title="Línea" class="tool-btn p-2 text-gray-600 rounded-md hover:bg-gray-100 transition-colors">
                <svg class="w-6 h-6" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><line x1="5" y1="19" x2="19" y2="5" /></svg>
            </button>
            <button id="draw-dashed-line-btn" title="Línea Punteada" class="tool-btn p-2 text-gray-600 rounded-md hover:bg-gray-100 transition-colors">
                <svg class="w-6 h-6" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" stroke-dasharray="4 4"><line x1="5" y1="19" x2="19" y2="5" /></svg>
            </button>
            <button id="draw-text-btn" title="Texto" class="tool-btn p-2 text-gray-600 rounded-md hover:bg-gray-100 transition-colors">
                <svg class="w-6 h-6" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
                    <text x="0" y="18" font-family="Inter, sans-serif" font-size="14" font-weight="bold">Abc</text>
                </svg>
            </button>
             <button id="draw-ground-btn" title="Tierra Eléctrica" class="tool-btn p-2 text-gray-600 rounded-md hover:bg-gray-100 transition-colors">
                <svg class="w-6 h-6" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
                    <line x1="12" y1="2" x2="12" y2="9"></line>
                    <line x1="8" y1="9" x2="16" y2="9"></line>
                    <line x1="9" y1="13" x2="15" y2="13"></line>
                    <line x1="10" y1="17" x2="14" y2="17"></line>
                </svg>
            </button>
        </div>

        <div class="flex-grow flex flex-col">
            <div class="max-w-6xl mx-auto p-4 md:p-6 lg:p-8 flex-grow flex flex-col w-full">
                <header class="shadow-sm rounded-xl p-4 mb-6 text-gray-800 bg-white border border-gray-200">
                    <div class="flex justify-between items-start mb-4">
                        <div>
                            <h1 class="text-2xl font-bold">
                                <span style="color: #2563eb;">Esquem</span><span style="color: #10b981;">App</span>
                            </h1>
                        </div>
                        <div class="flex items-center gap-2">
                             <button id="undo-btn" title="Deshacer" class="p-2 bg-gray-100 hover:bg-gray-200 text-gray-700 rounded-full transition-colors disabled:opacity-50 disabled:cursor-not-allowed" disabled>
                                <svg class="w-5 h-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M9 15L3 9m0 0l6-6M3 9h12a6 6 0 010 12h-3" /></svg>
                            </button>
                            <button id="redo-btn" title="Rehacer" class="p-2 bg-gray-100 hover:bg-gray-200 text-gray-700 rounded-full transition-colors disabled:opacity-50 disabled:cursor-not-allowed" disabled>
                                <svg class="w-5 h-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M15 15l6-6m0 0l-6-6m6 6H9a6 6 0 000 12h3" /></svg>
                            </button>
                            <button id="delete-btn" title="Eliminar Selección" class="p-2 bg-red-100 text-red-600 rounded-full hover:bg-red-200 transition-colors disabled:bg-gray-100 disabled:text-gray-400 disabled:cursor-not-allowed" disabled>
                                <svg class="w-5 h-5" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm4 0a1 1 0 012 0v6a1 1 0 11-2 0V8z" clip-rule="evenodd" /></svg>
                            </button>
                            <button id="clear-drawings-btn" title="Limpiar Lienzo" class="p-2 bg-yellow-100 text-yellow-600 rounded-full hover:bg-yellow-200 transition-colors disabled:bg-gray-100 disabled:text-gray-400 disabled:cursor-not-allowed" disabled>
                                <svg class="w-5 h-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                                    <path stroke-linecap="round" stroke-linejoin="round" d="M19.5 14.25v-2.625a3.375 3.375 0 00-3.375-3.375h-1.5A1.125 1.125 0 0113.5 7.125v-1.5a3.375 3.375 0 00-3.375-3.375H8.25m5.231 13.481L15 17.25m-4.5-15H5.625c-.621 0-1.125.504-1.125 1.125v17.25c0 .621.504 1.125 1.125 1.125h12.75c.621 0 1.125-.504 1.125-1.125V11.25a9 9 0 00-9-9z" />
                                </svg>
                            </button>
                        </div>
                    </div>
                    <div class="flex flex-wrap items-center justify-between gap-2">
                        <!-- Left Group -->
                        <div class="flex flex-wrap items-center gap-2">
                            <label for="file-upload" title="Subir archivo de datos (.csv)" class="cursor-pointer p-2 bg-gray-100 hover:bg-gray-200 text-gray-700 rounded-full shadow-sm transition-colors">
                                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                                    <polyline points="17 8 12 3 7 8"></polyline>
                                    <line x1="12" y1="3" x2="12" y2="15"></line>
                                </svg>
                            </label>
                            <input id="file-upload" type="file" class="hidden" accept=".csv, .txt">
                            <span id="file-name" class="text-gray-500 text-sm">Ningún archivo seleccionado</span>
                            
                            <div class="flex items-center bg-gray-100 rounded-full px-3 py-1 ml-2">
                                <svg class="w-5 h-5 text-gray-400" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
                                </svg>
                                <input type="text" id="search-input" list="search-suggestions" placeholder="Buscar elemento..." class="bg-transparent text-gray-700 placeholder-gray-400 focus:outline-none ml-2 text-sm w-48">
                                <datalist id="search-suggestions"></datalist>
                            </div>

                            <div class="relative inline-block text-left ml-2">
                                <div>
                                    <button type="button" id="saved-sketches-menu-button" class="p-2 bg-gray-100 hover:bg-gray-200 text-gray-700 rounded-full transition-colors" aria-expanded="false" aria-haspopup="true" title="Croquis Guardados">
                                        <svg class="w-5 h-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                                          <path stroke-linecap="round" stroke-linejoin="round" d="M2.25 12.75V12A2.25 2.25 0 014.5 9.75h15A2.25 2.25 0 0121.75 12v.75m-8.69-6.44l-2.12-2.12a1.5 1.5 0 00-1.061-.44H4.5A2.25 2.25 0 002.25 6v12a2.25 2.25 0 002.25 2.25h15A2.25 2.25 0 0021.75 18V9a2.25 2.25 0 00-2.25-2.25h-5.379a1.5 1.5 0 01-1.06-.44z" />
                                        </svg>
                                    </button>
                                </div>
                                <div id="saved-sketches-menu" class="origin-top-left absolute left-0 mt-2 w-64 rounded-md shadow-lg bg-white ring-1 ring-black ring-opacity-5 focus:outline-none hidden z-10" role="menu">
                                    <div class="p-2">
                                        <h4 class="text-sm font-semibold text-gray-700 mb-2 px-2">Croquis Guardados</h4>
                                        <ul id="saved-sketches-list" class="text-gray-700 text-sm max-h-60 overflow-y-auto"></ul>
                                    </div>
                                </div>
                            </div>
                            <button id="save-sketch-btn" title="Guardar Croquis en Navegador" class="p-2 bg-gray-100 hover:bg-gray-200 text-gray-700 rounded-full transition-colors">
                                <svg class="w-5 h-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                                  <path stroke-linecap="round" stroke-linejoin="round" d="M9 13.5l3 3m0 0l3-3m-3 3v-6m1.06-4.19l-2.12-2.12a1.5 1.5 0 00-1.061-.44H4.5A2.25 2.25 0 002.25 6v12a2.25 2.25 0 002.25 2.25h15A2.25 2.25 0 0021.75 18V9a2.25 2.25 0 00-2.25-2.25h-5.379a1.5 1.5 0 01-1.06-.44z" />
                                </svg>
                            </button>
                            <button id="copy-image-btn" title="Copiar Imagen" class="p-2 bg-gray-100 hover:bg-gray-200 text-gray-700 rounded-full transition-colors">
                                <svg class="w-5 h-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                                    <path stroke-linecap="round" stroke-linejoin="round" d="M6.827 6.175A2.31 2.31 0 015.186 7.23c-.38.054-.757.112-1.134.175C2.999 7.58 2.25 8.507 2.25 9.574V18a2.25 2.25 0 002.25 2.25h15A2.25 2.25 0 0021.75 18V9.574c0-1.067-.75-1.994-1.802-2.169a47.865 47.865 0 00-1.134-.175 2.31 2.31 0 01-1.64-1.055l-.822-1.316a2.192 2.192 0 00-1.736-1.039 48.776 48.776 0 00-5.232 0 2.192 2.192 0 00-1.736 1.039l-.821 1.316z" />
                                    <path stroke-linecap="round" stroke-linejoin="round" d="M16.5 12.75a4.5 4.5 0 11-9 0 4.5 4.5 0 019 0zM18.75 10.5h.008v.008h-.008V10.5z" />
                                </svg>
                            </button>
                        </div>
                         <!-- Right Group -->
                        <div class="flex items-center flex-wrap justify-end gap-2">
                            <label for="upload-sketch-file" title="Subir Croquis (.json)" class="cursor-pointer px-3 py-1 text-sm rounded bg-blue-100 text-blue-600 hover:bg-blue-200 transition-colors font-semibold flex items-center gap-1">
                                <svg class="w-4 h-4" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor">
                                  <path stroke-linecap="round" stroke-linejoin="round" d="M12 19.5v-15m0 0l-6.75 6.75M12 4.5l6.75 6.75" />
                                </svg>
                                <span>JSON</span>
                            </label>
                            <input id="upload-sketch-file" type="file" class="hidden" accept=".json">
                            <button id="download-sketch-btn" title="Descargar Croquis (.json)" class="px-3 py-1 text-sm rounded bg-blue-100 text-blue-600 hover:bg-blue-200 transition-colors font-semibold flex items-center gap-1">
                                <svg class="w-4 h-4" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor">
                                  <path stroke-linecap="round" stroke-linejoin="round" d="M12 4.5v15m0 0l6.75-6.75M12 19.5l-6.75-6.75" />
                                </svg>
                                <span>JSON</span>
                            </button>
                        </div>
                    </div>
                </header>

                <main id="visualization-container" class="bg-[#f5f5f0] shadow-sm rounded-xl p-2 sm:p-4 overflow-auto flex-grow border border-gray-300" style="min-height: 70vh;">
                    <div id="initial-message" class="hidden flex-col items-center justify-center h-full text-center text-gray-500" style="min-height: 65vh;">
                        <svg class="w-16 h-16 mb-4 text-gray-300" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 17v-2m3 2v-4m3 4v-6m2 10H7a2 2 0 01-2-2V7c0-1.1.9-2 2-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"></path></svg>
                        <h2 class="text-xl font-semibold">Esperando archivo de datos</h2>
                        <p class="mt-2 max-w-md">Por favor, selecciona un archivo CSV para comenzar la visualización. El gráfico aparecerá aquí.</p>
                    </div>
                    <div id="loading-indicator" class="hidden flex-col items-center justify-center h-full" style="min-height: 65vh;">
                        <div class="loader"></div>
                        <p class="mt-4 text-gray-600">Procesando datos y generando gráfico...</p>
                    </div>
                    <svg id="graph-svg"></svg>
                </main>
            </div>
        </div>
        
        <div id="info-panel" class="w-80 bg-white shadow-lg p-6 transform translate-x-full transition-transform duration-300 ease-in-out">
            <div id="info-content">
                <p class="text-gray-500">Seleccione un elemento para ver sus detalles.</p>
            </div>
        </div>
    </div>


    <script>
        // --- DOM Element Listeners ---
        document.getElementById('file-upload').addEventListener('change', handleFileSelect);
        document.getElementById('upload-sketch-file').addEventListener('change', handleUploadSketch);
        document.getElementById('download-sketch-btn').addEventListener('click', handleDownloadCurrentSketch);
        document.getElementById('delete-btn').addEventListener('click', handleDelete);
        document.getElementById('undo-btn').addEventListener('click', undo);
        document.getElementById('redo-btn').addEventListener('click', redo);
        document.getElementById('clear-drawings-btn').addEventListener('click', clearDrawings);
        document.getElementById('search-input').addEventListener('input', handleSearch);
        document.getElementById('copy-image-btn').addEventListener('click', copyDiagramAsImage);
        document.getElementById('save-sketch-btn').addEventListener('click', handleSaveSketch);
        document.getElementById('close-modal-btn').addEventListener('click', () => {
            const modal = document.getElementById('copy-image-modal');
            modal.classList.add('hidden');
            modal.classList.remove('flex');
        });


        // Drawing Tools Listeners
        const setupToolButton = (id, toolName, symbolType = null) => {
            const button = document.getElementById(id);
            button.addEventListener('click', (e) => {
                e.stopPropagation();
                if (toolName === 'custom-element' && symbolType) {
                    setCurrentTool(toolName, e.currentTarget, { symbolType });
                } else {
                    setCurrentTool(toolName, e.currentTarget);
                }
            });
        };
        setupToolButton('draw-ct-btn', 'custom-element', 'ct-default');
        setupToolButton('draw-seccionador-btn', 'custom-element', 'seccionador');
        setupToolButton('draw-ellipse-btn', 'ellipse');
        setupToolButton('draw-rect-btn', 'rect');
        setupToolButton('draw-line-btn', 'line');
        setupToolButton('draw-dashed-line-btn', 'dashed-line');
        setupToolButton('draw-text-btn', 'text');
        setupToolButton('draw-ground-btn', 'ground');
        
        document.addEventListener('keydown', (event) => {
            if (event.key === 'Escape') {
                setCurrentTool('select');
            }
        });

        // Dropdown Menus Logic
        const savedSketchesMenuButton = document.getElementById('saved-sketches-menu-button');
        const savedSketchesMenu = document.getElementById('saved-sketches-menu');

        savedSketchesMenuButton.addEventListener('click', (event) => {
            event.stopPropagation();
            savedSketchesMenu.classList.toggle('hidden');
        });

        window.addEventListener('click', (event) => {
            if (!savedSketchesMenuButton.contains(event.target) && !savedSketchesMenu.contains(event.target)) {
                savedSketchesMenu.classList.add('hidden');
            }
        });


        // --- Global State ---
        let currentGraphData = { nodes: [], edges: [], annotations: [], customElements: [], rootId: null };
        let savedSketches = [];
        let selectedNode = null;
        let selectedAnnotation = null;
        let selectedCustomElement = null;
        let nodeWidth = 90;
        let nodeHeight = 80;
        let history = [];
        let historyIndex = -1;
        let parentMap = null;
        let directedAdj = null;
        let rootNode = null; // To hold the D3 hierarchy root

        // Drawing State
        let currentTool = 'select';
        let currentToolOptions = {};
        let drawing = false;
        let startCoords = {};
        let currentAnnotation = null;

        const textPositions = [
            { name: 'bottom', offsetX: 0, offsetYFactor: 1, anchor: 'middle' },
            { name: 'top', offsetX: 0, offsetYFactor: -1, anchor: 'middle' },
            { name: 'left', offsetXFactor: -1, offsetY: 0, anchor: 'end' },
            { name: 'right', offsetXFactor: 1, offsetY: 0, anchor: 'start' }
        ];

        // --- Helper Functions ---
        const isBNode = (node) => node && node.data && node.data.baseName && node.data.baseName.match(/^B\d+/);
        const isTerminalOutput = (node) => {
            if (node.data.isPlaceholder) return false;
            if (!node || !node.parent || !isBNode(node.parent)) return false;
            return !node.children || node.children.length === 0;
        };
        const isXyyPatternNode = (node) => node && node.data && node.data.baseName && node.data.baseName.match(/^[A-Z0-9]+-\d+$/);
        const isConnectedToBNode = (node) => {
            if (!node) return false;
            if (node.parent && isBNode(node.parent)) return true;
            if (node.children && node.children.some(child => isBNode(child))) return true;
            return false;
        };
        
        const shouldHideSymbol = (node) => {
            if (!node) return false;
            if (node.data.isPlaceholder) return true;
            if (node.data.baseName && node.data.baseName.startsWith('SE-')) return false; 
            if (isXyyPatternNode(node) && isConnectedToBNode(node)) return true; 
            const isChildOfB = node.parent && isBNode(node.parent);
            const isParentOfB = node.children && node.children.some(child => isBNode(child));
            return isChildOfB || isParentOfB;
        };


        function showMessageBox(message, type = 'info', onConfirm = null) {
            const container = document.getElementById('message-box-container');
            container.innerHTML = `
                <div class="message-box">
                    <p>${message}</p>
                    <button id="message-box-ok" class="btn-confirm">OK</button>
                    ${onConfirm ? '<button id="message-box-cancel" class="btn-cancel">Cancelar</button>' : ''}
                </div>
            `;
            const okButton = document.getElementById('message-box-ok');
            okButton.focus();
            okButton.onclick = () => {
                container.innerHTML = '';
                if (onConfirm) onConfirm(true);
            };
            if (onConfirm) {
                document.getElementById('message-box-cancel').onclick = () => {
                    container.innerHTML = '';
                    onConfirm(false);
                };
            }
        }

        function showTextInputBox(message, defaultValue = '', onConfirm) {
            const container = document.getElementById('message-box-container');
            
            const keydownHandler = (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    confirmAction();
                } else if (e.key === 'Escape') {
                    cancelAction();
                }
            };

            const confirmAction = () => {
                const inputField = document.getElementById('text-input-field');
                const value = inputField ? inputField.value : null;
                container.innerHTML = '';
                document.removeEventListener('keydown', keydownHandler);
                onConfirm(value);
            };

            const cancelAction = () => {
                container.innerHTML = '';
                document.removeEventListener('keydown', keydownHandler);
                onConfirm(null);
            };
            
            container.innerHTML = `
                <div class="message-box">
                    <p class="mb-4">${message}</p>
                    <input type="text" id="text-input-field" class="w-full p-2 border border-gray-300 rounded-md mb-4" value="${defaultValue}">
                    <div>
                        <button id="message-box-ok" class="btn-confirm">OK</button>
                        <button id="message-box-cancel" class="btn-cancel">Cancelar</button>
                    </div>
                </div>
            `;
            
            const inputField = document.getElementById('text-input-field');
            const okButton = document.getElementById('message-box-ok');
            const cancelButton = document.getElementById('message-box-cancel');

            inputField.focus();
            inputField.select();

            okButton.onclick = confirmAction;
            cancelButton.onclick = cancelAction;
            document.addEventListener('keydown', keydownHandler);
        }

        function showError(message) {
            document.getElementById('loading-indicator').classList.add('hidden');
            document.getElementById('loading-indicator').classList.remove('flex');
            document.getElementById('graph-svg').classList.add('hidden');

            const initialMessage = document.getElementById('initial-message');
            initialMessage.classList.remove('hidden');
            initialMessage.innerHTML = `
                <svg class="w-16 h-16 mb-4 text-red-400" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
                <h2 class="text-xl font-semibold text-red-600">Error</h2>
                <p class="mt-2 max-w-md">${message}</p>
            `;
            updateDeleteButtonState();
        }

        function handleFileSelect(event) {
            const file = event.target.files[0];
            if (!file) return;

            parentMap = null;
            directedAdj = null;

            document.getElementById('file-name').textContent = file.name;
            document.getElementById('loading-indicator').classList.remove('hidden');
            document.getElementById('loading-indicator').classList.add('flex');
            
            d3.select("#graph-svg").selectAll("*").remove();
            clearSelections();
            updateDeleteButtonState();
            hideInfoPanel();
            updateClearDrawingsButtonState();
            document.getElementById('search-input').value = '';
            document.getElementById('search-suggestions').innerHTML = '';


            const reader = new FileReader();
            reader.onload = e => {
                setTimeout(() => {
                    try {
                        currentGraphData = processData(e.target.result);
                        console.log("Processed data:", currentGraphData);
                        if (currentGraphData.nodes.length > 0 && currentGraphData.rootId) {
                            document.getElementById('initial-message').classList.add('hidden');
                            document.getElementById('graph-svg').classList.remove('hidden');
                            history = [];
                            historyIndex = -1;
                            saveState();
                            drawGraph(currentGraphData);
                        } else {
                           showError("No se encontró un elemento raíz dibujable o no hay elementos válidos en el archivo. Por favor, revise el formato del archivo.");
                        }
                    } catch (error) {
                        console.error("Error processing file:", error);
                        showError(`Ocurrió un error al procesar el archivo: ${error.message}`);
                    } finally {
                        document.getElementById('loading-indicator').classList.add('hidden');
                        document.getElementById('loading-indicator').classList.remove('flex');
                    }
                }, 50);
            };
            reader.onerror = () => {
                showError("No se pudo leer el archivo.");
            };
            reader.readAsText(file, 'ISO-8859-1');
        }

        function processData(csvText) {
            const lines = csvText.split(/\r?\n/);
            const headers = lines[0].split('\t');
            
            const idIndex = headers.indexOf('ID');
            const nombreIndex = headers.indexOf('NOMBRE');
            const conexionesIndex = headers.indexOf('CONEXIONES');
            let descripcionClaseIndex = -1;
            for(let i = 0; i < headers.length; i++) {
                if(headers[i] === 'DESCRIPCION' && i < nombreIndex) {
                    descripcionClaseIndex = i;
                }
            }
            
            if (idIndex === -1 || nombreIndex === -1 || conexionesIndex === -1 || descripcionClaseIndex === -1) {
                throw new Error("El archivo CSV no contiene las columnas requeridas: 'ID', 'NOMBRE', 'DESCRIPCION' (antes de NOMBRE), y 'CONEXIONES'.");
            }

            const dataMap = new Map();
            let firstDrawableId = null;
            const drawableNodeIds = new Set();

            for (let i = 1; i < lines.length; i++) {
                if (lines[i].trim() === '') continue;
                const data = lines[i].split('\t');
                const id = data[idIndex];
                if (id) {
                    const nodeData = {
                        id: id,
                        nombre: data[nombreIndex],
                        descripcion: data[descripcionClaseIndex],
                        conexionesRaw: data[conexionesIndex]
                    };
                    dataMap.set(id, nodeData);
                    
                    const isDrawable = nodeData.nombre && 
                                         !nodeData.nombre.startsWith('DE-') &&
                                         !nodeData.nombre.startsWith('BC-') &&
                                         !nodeData.nombre.startsWith('SD_') && 
                                         !/TR\d+$/.test(nodeData.nombre) &&
                                         nodeData.descripcion !== 'UNI MT Interruptor'; 
                    
                    if (isDrawable) {
                        drawableNodeIds.add(id);
                        if (!firstDrawableId) {
                            firstDrawableId = id;
                        }
                    }
                }
            }

            const nodes = Array.from(drawableNodeIds).map(id => {
                const nodeData = dataMap.get(id);
                const node = { 
                    id: id, 
                    name: nodeData.nombre, 
                    baseName: nodeData.nombre, 
                    description: nodeData.descripcion,
                    state: 'closed'
                };
                if (node.baseName.match(/^B\d+/)) {
                    node.connections = [];
                }
                return node;
            });

            const edges = [];
            const processedEdges = new Set();

            drawableNodeIds.forEach(startNodeId => {
                const queue = [startNodeId];
                const visitedInPath = new Set([startNodeId]);

                while (queue.length > 0) {
                    const currentNodeId = queue.shift();
                    const currentNode = dataMap.get(currentNodeId);

                    if (!currentNode || !currentNode.conexionesRaw) continue;

                    const connections = currentNode.conexionesRaw.split('|');
                    connections.forEach(conn => {
                        const parts = conn.split(',');
                        if (parts.length > 2) {
                            const neighborId = parts[2];
                            if (!dataMap.has(neighborId) || visitedInPath.has(neighborId)) {
                                return;
                            }
                            visitedInPath.add(neighborId);

                            if (drawableNodeIds.has(neighborId)) {
                                const edgeKey = [startNodeId, neighborId].sort().join('-');
                                if (!processedEdges.has(edgeKey)) {
                                    edges.push({ source: startNodeId, target: neighborId, state: 'closed' });
                                    processedEdges.add(edgeKey);
                                }
                            } else {
                                queue.push(neighborId);
                            }
                        }
                    });
                }
            });

            return { nodes, edges, annotations: [], customElements: [], rootId: firstDrawableId };
        }
        
        // --- Drawing and Annotation ---

        function setCurrentTool(tool, buttonElement = null, options = {}) {
            if (currentTool === tool && JSON.stringify(currentToolOptions) === JSON.stringify(options) && tool !== 'select') {
                setCurrentTool('select');
                return;
            }

            currentTool = tool;
            currentToolOptions = options;
            const svg = d3.select("#graph-svg");
            const g = svg.select("g.graph-content");
            const toolsSidebar = document.getElementById('tools-sidebar');
            
            toolsSidebar.querySelectorAll('.tool-btn').forEach(btn => btn.classList.remove('active'));
            
            if (tool !== 'select' && buttonElement) {
                 buttonElement.classList.add('active');
            }

            if (tool === 'select') {
                svg.classed('drawing-mode', false);
                svg.style('cursor', 'default');
                g.style('pointer-events', 'all');
                initializeZoom();
                svg.on('.drag', null).on('click', null);
            } else {
                clearSelections();
                updateDeleteButtonState();
                svg.classed('drawing-mode', true);
                svg.style('cursor', 'crosshair');
                g.style('pointer-events', 'none');
                svg.on('.zoom', null);
                initializeDrawing();
            }
        }
        
        function initializeDrawing() {
            const svg = d3.select("#graph-svg");
            const g = svg.select("g.graph-content");
            const drawingArea = svg.select("#drawing-area").node();

            svg.on('.drag', null).on('click', null);

            const clickHandler = (event) => {
                if (event.target !== svg.node() && event.target !== drawingArea) return;

                const [x, y] = d3.pointer(event, g.node());

                if (currentTool === 'text') {
                    showTextInputBox("Ingrese el texto para la anotación:", "", (text) => {
                        if (text && text.trim() !== "") {
                            const annotationData = { id: `anno-${Date.now()}`, type: 'text', x, y, text };
                            currentGraphData.annotations.push(annotationData);
                            saveState();
                            drawAnnotations();
                            updateClearDrawingsButtonState();
                        }
                    });
                } else if (currentTool === 'ground') {
                    const annotationData = {
                        id: `anno-${Date.now()}`,
                        type: 'ground',
                        x: x,
                        y: y,
                        scale: 1.5,
                        rotation: 0
                    };
                    currentGraphData.annotations.push(annotationData);
                    saveState();
                    drawAnnotations();
                    updateClearDrawingsButtonState();
                } else if (currentTool === 'custom-element') {
                    const symbolType = currentToolOptions.symbolType;
                    const defaultName = symbolType === 'ct-default' ? "CT-Nuevo" : "Seccionador-Nuevo";
                    showTextInputBox(`Ingrese el nombre del nuevo elemento:`, defaultName, (name) => {
                        if (name && name.trim() !== "") {
                            showTextInputBox("Ingrese el número de salidas (1 por defecto):", "1", (numStr) => {
                                const numConnections = parseInt(numStr, 10);
                                if (numStr !== null && !isNaN(numConnections) && numConnections >= 0 && numConnections <= 8) {
                                    const newElement = {
                                        id: `custom-${Date.now()}`,
                                        name: name,
                                        x: x,
                                        y: y,
                                        symbolType: symbolType,
                                        numConnections: numConnections,
                                        distributionMode: 'auto',
                                        connections: [],
                                        state: 'closed' // NEW: Add default state
                                    };
                                    currentGraphData.customElements.push(newElement);
                                    updateCustomElementConnections(newElement);
                                    saveState();
                                    drawCustomElements();
                                } else if (numStr !== null) {
                                    showMessageBox("Por favor, ingrese un número válido entre 0 y 8.");
                                }
                            });
                        }
                    });
                }
            };
            
            if (['text', 'ground', 'custom-element'].includes(currentTool)) {
                svg.on('click', clickHandler);
            } else {
                const drawingDrag = d3.drag()
                    .on("start", (event) => {
                        if (event.sourceEvent.target !== svg.node() && event.sourceEvent.target !== drawingArea) {
                            drawing = false;
                            return;
                        }
                        drawing = true;
                        const [x, y] = d3.pointer(event, g.node());
                        startCoords = { x, y };
                        let newElement;
                        switch(currentTool) {
                            case 'ellipse': newElement = g.append('ellipse').attr('class', 'annotation'); break;
                            case 'rect': newElement = g.append('rect').attr('class', 'annotation'); break;
                            case 'line':
                            case 'dashed-line':
                                 newElement = g.append('line').attr('class', 'annotation');
                                 if (currentTool === 'dashed-line') newElement.attr('stroke-dasharray', '5,5');
                                 break;
                        }
                        currentAnnotation = { id: `anno-${Date.now()}`, type: currentTool, element: newElement, data: {} };
                    })
                    .on("drag", (event) => {
                        if (!drawing) return;
                        const [pointerX, pointerY] = d3.pointer(event, g.node());
                        const { element, data } = currentAnnotation;
                        
                        switch(currentTool) {
                            case 'ellipse':
                                const rx = Math.abs(pointerX - startCoords.x) / 2;
                                const ry = Math.abs(pointerY - startCoords.y) / 2;
                                const cx = startCoords.x + (pointerX - startCoords.x) / 2;
                                const cy = startCoords.y + (pointerY - startCoords.y) / 2;
                                element.attr('cx', cx).attr('cy', cy).attr('rx', rx).attr('ry', ry);
                                data.cx = cx; data.cy = cy; data.rx = rx; data.ry = ry;
                                break;
                            case 'rect':
                                element.attr('x', Math.min(startCoords.x, pointerX)).attr('y', Math.min(startCoords.y, pointerY))
                                       .attr('width', Math.abs(pointerX - startCoords.x)).attr('height', Math.abs(pointerY - startCoords.y));
                                data.x = +element.attr('x'); data.y = +element.attr('y'); data.width = +element.attr('width'); data.height = +element.attr('height');
                                break;
                            case 'line':
                            case 'dashed-line':
                                const dx = pointerX - startCoords.x;
                                const dy = pointerY - startCoords.y;
                                const angle = Math.atan2(dy, dx);
                                const fortyFive = Math.PI / 4;
                                const snapAngle = Math.round(angle / fortyFive) * fortyFive;
                                const dist = Math.sqrt(dx * dx + dy * dy);
                                const endX = startCoords.x + dist * Math.cos(snapAngle);
                                const endY = startCoords.y + dist * Math.sin(snapAngle);
                                element.attr('x1', startCoords.x).attr('y1', startCoords.y).attr('x2', endX).attr('y2', endY);
                                data.x1 = startCoords.x; data.y1 = startCoords.y; data.x2 = endX; data.y2 = endY;
                                break;
                        }
                        element.attr('fill', 'none');
                    })
                    .on("end", () => {
                        if (!drawing) return;
                        drawing = false;
                        const annotationData = { id: currentAnnotation.id, type: currentAnnotation.type, ...currentAnnotation.data };
                        currentGraphData.annotations.push(annotationData);
                        saveState();
                        currentAnnotation.element.remove();
                        currentAnnotation = null;
                        drawAnnotations();
                        updateClearDrawingsButtonState();
                    });
                svg.call(drawingDrag);
            }
        }
        
        function drawAnnotations() {
            const g = d3.select("g.graph-content");
            g.selectAll('.annotation-group').remove();

            const annotationGroups = g.selectAll('.annotation-group')
                .data(currentGraphData.annotations, d => d.id)
                .join('g')
                .attr('class', 'annotation-group')
                .classed('selected', d => selectedAnnotation && selectedAnnotation.id === d.id)
                .each(function(d) {
                    const group = d3.select(this);
                    let element;

                    if (d.type === 'ground') {
                        group.attr('transform', `translate(${d.x}, ${d.y}) rotate(${d.rotation || 0})`);
                    }

                    switch(d.type) {
                        case 'ellipse':
                            element = group.append('ellipse').attr('cx', d.cx).attr('cy', d.cy).attr('rx', d.rx).attr('ry', d.ry);
                            break;
                        case 'rect':
                            element = group.append('rect').attr('x', d.x).attr('y', d.y).attr('width', d.width).attr('height', d.height);
                            break;
                        case 'line':
                        case 'dashed-line':
                            group.append('line').attr('x1', d.x1).attr('y1', d.y1).attr('x2', d.x2).attr('y2', d.y2).attr('stroke', 'transparent').attr('stroke-width', 10);
                            element = group.append('line').attr('x1', d.x1).attr('y1', d.y1).attr('x2', d.x2).attr('y2', d.y2);
                            if (d.type === 'dashed-line') element.attr('stroke-dasharray', '5,5');
                            break;
                        case 'dashed-line-stub':
                            if (rootNode) {
                                const parentNode = rootNode.descendants().find(n => n.data.id === d.parentId);
                                if (parentNode) {
                                    const parentPos = { x: parentNode.data.customX ?? parentNode.x, y: parentNode.data.customY ?? parentNode.y };
                                    const radius = getNodeRadius(parentNode);
                                    
                                    if (d.direction === 'down') {
                                        d.x1 = parentPos.x;
                                        d.y1 = parentPos.y + radius;
                                    } else { // up
                                        d.x1 = parentPos.x;
                                        d.y1 = parentPos.y - radius;
                                    }
                                    d.x2 = d.x1 + d.offsetX;
                                    d.y2 = d.y1 + d.offsetY;

                                    group.append('line').attr('x1', d.x1).attr('y1', d.y1).attr('x2', d.x2).attr('y2', d.y2).attr('stroke', 'transparent').attr('stroke-width', 10);
                                    element = group.append('line').attr('x1', d.x1).attr('y1', d.y1).attr('x2', d.x2).attr('y2', d.y2);
                                    element.attr('stroke-dasharray', '5,5');
                                }
                            }
                            break;
                        case 'text':
                            element = group.append('text').attr('class', 'text-annotation').attr('x', d.x).attr('y', d.y).text(d.text);
                            break;
                        case 'ground':
                            const scale = d.scale || 1;
                            group.append('line').attr('class', 'annotation').attr('x1', 0).attr('y1', -12 * scale).attr('x2', 0).attr('y2', 6 * scale);
                            group.append('line').attr('class', 'annotation').attr('x1', -9 * scale).attr('y1', 6 * scale).attr('x2', 9 * scale).attr('y2', 6 * scale);
                            group.append('line').attr('class', 'annotation').attr('x1', -6 * scale).attr('y1', 12 * scale).attr('x2', 6 * scale).attr('y2', 12 * scale);
                            group.append('line').attr('class', 'annotation').attr('x1', -3 * scale).attr('y1', 18 * scale).attr('x2', 3 * scale).attr('y2', 18 * scale);
                            break;
                    }

                    if (element) {
                        element.attr('class', `annotation ${d.type}-annotation`);
                        if (d.type !== 'text') {
                            element.attr('fill', 'none');
                        }
                    }
                    
                    addResizeHandles(group, d);
                });

            annotationGroups.on("click", function(event, d) {
                event.stopPropagation();
                if (currentTool !== 'select') return;
                clearSelections();
                selectedAnnotation = d;
                d3.select(this).classed('selected', true);
                drawAnnotations();
                updateDeleteButtonState();
            });
            
            annotationGroups.on("dblclick", function(event, d) {
                if (currentTool !== 'select') return;
                event.preventDefault();
                event.stopPropagation();

                if (d.type === 'ground') {
                    d.rotation = (d.rotation || 0) + 45;
                    saveState();
                    drawAnnotations();
                } else if (d.type === 'text') {
                    showTextInputBox("Editar texto:", d.text, (newText) => {
                        if (newText !== null && newText !== d.text) {
                            d.text = newText;
                            saveState();
                            drawAnnotations();
                        }
                    });
                }
            });

            annotationGroups.call(d3.drag()
                .on("start", function(event, d) {
                    if (currentTool !== 'select' || d3.select(event.sourceEvent.target).classed('resize-handle')) return;
                    d3.select(this).raise();
                    if (!selectedAnnotation || selectedAnnotation.id !== d.id) {
                        clearSelections();
                        selectedAnnotation = d;
                        d3.select(this).classed('selected', true);
                        drawAnnotations();
                        updateDeleteButtonState();
                    }
                })
                .on("drag", function(event, d) {
                    if (currentTool !== 'select' || d3.select(event.sourceEvent.target).classed('resize-handle')) return;
                    
                    const transform = d3.zoomTransform(d3.select("#graph-svg").node());
                    const dx = event.dx / transform.k;
                    const dy = event.dy / transform.k;

                    if (d.type === 'ground' || d.type === 'rect' || d.type === 'text') {
                        d.x += dx;
                        d.y += dy;
                    } else if (d.type === 'ellipse') {
                        d.cx += dx;
                        d.cy += dy;
                    } else if (d.type === 'line' || d.type === 'dashed-line') {
                        d.x1 += dx; d.y1 += dy;
                        d.x2 += dx; d.y2 += dy;
                    }
                    drawAnnotations();
                })
                .on("end", function(event, d) {
                    if (currentTool !== 'select' || d3.select(event.sourceEvent.target).classed('resize-handle')) return;
                    saveState();
                })
            );
        }

        function addResizeHandles(group, d) {
            const handleRadius = 4;
            let handles = [];

            if (d.type === 'rect') {
                handles = [
                    { x: d.x, y: d.y, cursor: 'nwse-resize', type: 'top-left' },
                    { x: d.x + d.width, y: d.y, cursor: 'nesw-resize', type: 'top-right' },
                    { x: d.x, y: d.y + d.height, cursor: 'nesw-resize', type: 'bottom-left' },
                    { x: d.x + d.width, y: d.y + d.height, cursor: 'nwse-resize', type: 'bottom-right' }
                ];
            } else if (d.type === 'ellipse') {
                 handles = [
                    { x: d.cx, y: d.cy - d.ry, cursor: 'ns-resize', type: 'top' },
                    { x: d.cx + d.rx, y: d.cy, cursor: 'ew-resize', type: 'right' },
                    { x: d.cx, y: d.cy + d.ry, cursor: 'ns-resize', type: 'bottom' },
                    { x: d.cx - d.rx, y: d.cy, cursor: 'ew-resize', type: 'left' }
                ];
            } else if (d.type === 'line' || d.type === 'dashed-line') {
                handles = [
                    { x: d.x1, y: d.y1, cursor: 'move', type: 'start' },
                    { x: d.x2, y: d.y2, cursor: 'move', type: 'end' }
                ];
            } else if (d.type === 'ground') {
                const scale = d.scale || 1;
                handles = [{ x: 0, y: 18 * scale + 8, cursor: 'ns-resize', type: 'scale' }];
            } else if (d.type === 'dashed-line-stub') {
                if (d.x2 !== undefined && d.y2 !== undefined) {
                    handles = [ { x: d.x2, y: d.y2, cursor: 'move', type: 'end' } ];
                }
            }

            group.selectAll('.resize-handle')
                .data(handles)
                .join('circle')
                .attr('class', 'resize-handle')
                .attr('cx', h => h.x)
                .attr('cy', h => h.y)
                .attr('r', handleRadius)
                .style('cursor', h => h.cursor)
                .call(d3.drag()
                    .on('start', function(event) { event.sourceEvent.stopPropagation(); })
                    .on('drag', (event, h) => {
                        const transform = d3.zoomTransform(d3.select("#graph-svg").node());
                        const k = transform.k;
                        const dx = event.dx / k;
                        const dy = event.dy / k;

                        if (d.type === 'rect') {
                            if (h.type.includes('left')) { d.x += dx; d.width -= dx; }
                            if (h.type.includes('right')) { d.width += dx; }
                            if (h.type.includes('top')) { d.y += dy; d.height -= dy; }
                            if (h.type.includes('bottom')) { d.height += dy; }
                        } else if (d.type === 'ellipse') {
                            if (h.type === 'top') { d.ry -= dy; }
                            else if (h.type === 'bottom') { d.ry += dy; }
                            else if (h.type === 'left') { d.rx -= dx; }
                            else if (h.type === 'right') { d.rx += dx; }
                            d.rx = Math.max(5, d.rx);
                            d.ry = Math.max(5, d.ry);
                        } else if (d.type === 'line' || d.type === 'dashed-line') {
                            if (h.type === 'start') { d.x1 += dx; d.y1 += dy; }
                            else { d.x2 += dx; d.y2 += dy; }
                        } else if (d.type === 'ground') {
                            d.scale = Math.max(0.2, (d.scale || 1) + dy / 20);
                        } else if (d.type === 'dashed-line-stub') {
                            d.offsetX += dx;
                            d.offsetY += dy;
                        }
                        drawAnnotations();
                    })
                    .on('end', saveState)
                );
        }

        // --- Core D3 Graphing ---
        let zoom;

        function initializeZoom() {
            const svg = d3.select("#graph-svg");
            const g = svg.select("g.graph-content");
            zoom = d3.zoom()
                .scaleExtent([0.1, 2])
                .on("zoom", (event) => {
                    g.attr("transform", event.transform);
                });
            svg.call(zoom)
               .on("dblclick.zoom", null); 
        }

        function reorderGraphFromNode(node) {
            if (!node || !node.data || !node.data.id) {
                showMessageBox("No se pudo reordenar el gráfico. El nodo seleccionado no es válido.");
                return;
            }
            currentGraphData.nodes.forEach(n => {
                delete n.customX;
                delete n.customY;
            });
            currentGraphData.rootId = node.data.id;
            // When re-rooting, we need to rebuild the parent/child relationships
            directedAdj = null; 
            parentMap = null;
            clearSelections();
            updateDeleteButtonState();
            drawGraph(currentGraphData);
        }

        function getNodeRadius(node) {
            const circleRadius = 8;
            const symbolRadius = 15; // Half of symbolSize
            if (!node || shouldHideSymbol(node)) return 0;

            if (node.data.symbolType && node.data.symbolType !== 'default') {
                if (node.data.symbolType === 'triangle') return circleRadius * 0.75;
                return circleRadius;
            }
            if (isBNode(node)) return symbolRadius;
            if (node.data.description === 'UNI MT Reconectador') return circleRadius * 1.5;
            
            return circleRadius;
        }

        function getBNodeChildPathInfo(parentD, childD, symbolRadius) {
            const parentAbsX = parentD.data.customX !== undefined ? parentD.data.customX : parentD.x;
            const parentAbsY = parentD.data.customY !== undefined ? parentD.data.customY : parentD.y;
            const childAbsX = childD.data.customX !== undefined ? childD.data.customX : childD.x;
            const childAbsY = childD.data.customY !== undefined ? childD.data.customY : childD.y;
            let rhombusX, rhombusY, linkPath;
            const dx = childAbsX - parentAbsX;
            const dy = childAbsY - parentAbsY;

            if (Math.abs(dx) > Math.abs(dy)) { // More horizontal
                rhombusY = 0;
                if (dx > 0) { // Right
                    rhombusX = symbolRadius;
                    linkPath = `M ${parentAbsX + symbolRadius},${parentAbsY} H ${childAbsX} V ${childAbsY}`;
                } else { // Left
                    rhombusX = -symbolRadius;
                    linkPath = `M ${parentAbsX - symbolRadius},${parentAbsY} H ${childAbsX} V ${childAbsY}`;
                }
            } else { // More vertical
                rhombusX = 0;
                if (dy > 0) { // Down
                    rhombusY = symbolRadius;
                    linkPath = `M ${parentAbsX},${parentAbsY + symbolRadius} V ${childAbsY} H ${childAbsX}`;
                } else { // Up (this case is handled by the parent connection logic)
                    rhombusY = -symbolRadius;
                    linkPath = `M ${parentAbsX},${parentAbsY - symbolRadius} V ${childAbsY} H ${childAbsX}`;
                }
            }
            return { rhombusX, rhombusY, linkPath };
        }

        function redrawAllLinks(root) {
            const linksGroup = d3.select("g.links");
            linksGroup.selectAll("*").remove();

            const symbolSize = 30, symbolRadius = symbolSize / 2, circleRadius = 8;

            const updateLinkPath = (d) => {
                if (!d || !d.source || !d.target || !d.source.data || !d.target.data) return '';
                const sourceX = d.source.data.customX !== undefined ? d.source.data.customX : d.source.x;
                const sourceY = d.source.data.customY !== undefined ? d.source.data.customY : d.source.y;
                const targetX = d.target.data.customX !== undefined ? d.target.data.customX : d.target.x;
                const targetY = d.target.data.customY !== undefined ? d.target.data.customY : d.target.y;

                const sourceRadius = getNodeRadius(d.source);
                const adjustedSourceY = sourceY + sourceRadius;

                let targetRadius = getNodeRadius(d.target);
                const adjustedTargetY = targetY - targetRadius;
                
                const elbowY = adjustedSourceY + 25;
                return `M ${sourceX},${adjustedSourceY} V ${elbowY} H ${targetX} V ${adjustedTargetY}`;
            };

            if (root.children && root.children.length > 0) {
                const children = root.children;
                const rootY = root.data.customY !== undefined ? root.data.customY : root.y;
                const rootX = root.data.customX !== undefined ? root.data.customX : root.x;
                const xCoords = children.map(c => c.data.customX !== undefined ? c.data.customX : c.x);
                xCoords.push(rootX);
                const minX = Math.min(...xCoords);
                const maxX = Math.max(...xCoords);
                if (minX !== maxX) {
                    linksGroup.append('path').attr('class', 'link cable-line').attr('d', `M ${minX},${rootY} H ${maxX}`);
                }
                children.forEach(child => {
                    const childX = child.data.customX !== undefined ? child.data.customX : child.x;
                    const childY = child.data.customY !== undefined ? child.data.customY : child.y;
                    let targetRadius = getNodeRadius(child);
                    const adjustedChildY = childY - targetRadius;
                    linksGroup.append('path').attr('class', 'link cable-line').attr('id', `link-root-${child.data.id}`).attr('d', `M ${childX},${rootY} V ${adjustedChildY}`);
                });
            }

            linksGroup.selectAll('.link-standard').data(root.links().filter(d => d.source.parent != null && !isBNode(d.source))).enter().append('path').attr('class', 'link link-standard cable-line').attr('id', d => `link-${d.source.data.id}-${d.target.data.id}`).attr('d', updateLinkPath).style('stroke-dasharray', d => {
                const edge = currentGraphData.edges.find(e => (e.source === d.source.data.id && e.target === d.target.data.id) || (e.source === d.target.data.id && e.target === d.source.data.id));
                return edge && edge.isDashed ? '5,5' : 'none';
            });

            d3.selectAll('.node.b-node').each(function(bNode) {
                if (!bNode.children) return;
                bNode.children.forEach(child => {
                    if (!isTerminalOutput(child) && !child.data.isPlaceholder) {
                        const { linkPath } = getBNodeChildPathInfo(bNode, child, symbolRadius);
                        linksGroup.append('path').datum({source: bNode, target: child}).attr('class', 'link cable-line').attr('id', `link-${bNode.data.id}-${child.data.id}`).attr('d', linkPath);
                    }
                });
            });
        }


        function drawGraph({ nodes, edges, annotations, customElements, rootId }) {
            const svg = d3.select("#graph-svg");
            svg.selectAll("*").remove();
            const container = document.getElementById('visualization-container');

            const hasGraphElements = nodes && nodes.length > 0 && rootId;
            const hasDrawingElements = (annotations && annotations.length > 0) || (customElements && customElements.length > 0);

            if (!hasGraphElements && !hasDrawingElements) {
                initializeBlankCanvas();
                return;
            }
            
            document.getElementById('initial-message').classList.add('hidden');
            document.getElementById('graph-svg').classList.remove('hidden');

            // --- Common Setup ---
            const contextMenu = d3.select("#context-menu");
            d3.select('body').on('click', () => contextMenu.classed('hidden', true));
            
            const defs = svg.append('defs');
            defs.append('pattern').attr('id', 'grid').attr('width', 20).attr('height', 20).attr('patternUnits', 'userSpaceOnUse').append('path').attr('d', 'M 20 0 L 0 0 0 20').attr('fill', 'none').attr('stroke', '#e5e7eb').attr('stroke-width', '0.5');
            
            const drawingArea = svg.append('rect').attr('id', 'drawing-area').attr('width', '100%').attr('height', '100%').attr('fill', 'url(#grid)');

            drawingArea.on('click', (event) => {
                if (currentTool === 'select') {
                    clearSelections();
                    updateDeleteButtonState();
                }
            });

            const g = svg.append("g").attr("class", "graph-content");

            if (hasGraphElements) {
                // --- Existing Graph Drawing Logic ---
                const openColor = '#fff';
                const closedColor = '#4ade80';
                const blackColor = '#1f2937';
                const nodeMap = new Map(nodes.map(d => [d.id, d]));
                
                if (!directedAdj) {
                    const visibleEdges = edges.filter(e => {
                        const sourceNode = nodeMap.get(e.source);
                        const targetNode = nodeMap.get(e.target);
                        return sourceNode && !sourceNode.isPlaceholder && targetNode && !targetNode.isPlaceholder;
                    });
                    const initialAdj = new Map(nodes.map(d => [d.id, []]));
                    visibleEdges.forEach(({ source, target }) => {
                        if (!initialAdj.has(source)) initialAdj.set(source, []);
                        if (!initialAdj.has(target)) initialAdj.set(target, []);
                        initialAdj.get(source).push(target);
                        initialAdj.get(target).push(source);
                    });
                    directedAdj = new Map();
                    parentMap = new Map();
                    const queue = [rootId];
                    const visited = new Set([rootId]);
                    parentMap.set(rootId, null);
                    while (queue.length > 0) {
                        const u = queue.shift();
                        directedAdj.set(u, []);
                        const neighbors = initialAdj.get(u) || [];
                        for (const v of neighbors) {
                            if (!visited.has(v)) {
                                visited.add(v);
                                parentMap.set(v, u);
                                directedAdj.get(u).push(v);
                                const nodeData = nodeMap.get(v);
                                if (nodeData && nodeData.name && nodeData.name.startsWith('SE-')) {
                                    // Is a leaf node, do nothing.
                                } else {
                                    queue.push(v);
                                }
                            }
                        }
                    }
                }

                const buildReRootedHierarchy = (nId, pId) => {
                    const nodeData = { ...nodeMap.get(nId) };
                    if (!nodeData || nodeData.isPlaceholder) return null;
                    const originalChildren = directedAdj.get(nId) || [];
                    const originalParent = parentMap.get(nId);
                    const neighbors = [...originalChildren];
                    if (originalParent) {
                        neighbors.push(originalParent);
                    }
                    const newChildren = neighbors
                        .filter(neighborId => neighborId !== pId)
                        .map(childId => buildReRootedHierarchy(childId, nId))
                        .filter(Boolean);
                    nodeData.children = newChildren;
                    return nodeData;
                };

                const hierarchyData = buildReRootedHierarchy(rootId, null);
                if (!hierarchyData) { showError("No se pudo construir la jerarquía del gráfico a partir del nodo raíz."); return; }
                const root = d3.hierarchy(hierarchyData);
                rootNode = root;

                const customPositions = new Map(nodes.filter(n => n.customX !== undefined).map(n => [n.id, {x: n.customX, y: n.customY}]));
                root.descendants().forEach(d => {
                    if (customPositions.has(d.data.id)) { const pos = customPositions.get(d.data.id); d.data.customX = pos.x; d.data.customY = pos.y; }
                    if (!d.data.displayName) { d.data.displayName = d.data.baseName; }
                    if (isBNode(d) && d.parent && !d.data.wasRenamed) {
                        const parentName = d.parent.data.displayName;
                        const prefix = parentName.split('-')[0];
                        if (prefix) {
                            d.data.displayName = "CT-" + prefix;
                            d.data.wasRenamed = true;
                            const nodeRef = currentGraphData.nodes.find(n => n.id === d.data.id);
                            if (nodeRef) { nodeRef.displayName = d.data.displayName; nodeRef.wasRenamed = true; }
                        }
                    }
                });

                const margin = { top: 100, right: 50, bottom: 80, left: 50 };
                const width = Math.max(container.clientWidth, root.leaves().length * nodeWidth) + margin.left + margin.right;
                const height = Math.max(container.clientHeight, root.height * nodeHeight * 2) + margin.top + margin.bottom;
                svg.attr("width", width).attr("height", height);
                const treeLayout = d3.tree().nodeSize([nodeWidth, nodeHeight * 0.7]);
                treeLayout(root);
                
                const symbolSize = 30, symbolRadius = symbolSize / 2, circleRadius = 8, rhombusRadius = 4;
                const linksGroup = g.append("g").attr("class", "links");
                const nodesGroup = g.append("g").attr("class", "nodes");

                const nodeElements = nodesGroup.selectAll('.node').data(root.descendants().filter(d => !shouldHideSymbol(d))).enter().append('g').attr('class', d => `node ${isBNode(d) ? 'b-node' : 'standard-node'} ${d.data.baseName && d.data.baseName.startsWith('SE-') ? 'se-node' : ''} ${selectedNode && selectedNode.data.id === d.data.id ? 'selected' : ''}`).attr('transform', d => `translate(${d.data.customX !== undefined ? d.data.customX : d.x},${d.data.customY !== undefined ? d.data.customY : d.y})`)
                    .on("click", (event, d) => {
                        event.stopPropagation();
                        if (currentTool !== 'select') return;
                        clearSelections();
                        selectedNode = d;
                        d3.select(event.currentTarget).classed('selected', true);
                        updateInfoPanel(d);
                        updateDeleteButtonState();
                    }).on("dblclick", (event, d) => {
                        event.preventDefault();
                        event.stopPropagation();
                        reorderGraphFromNode(d);
                    }).on('contextmenu', function(event, d) {
                        event.preventDefault();
                        if (currentTool !== 'select' || !isBNode(d)) return;
                        const menuContent = contextMenu.select('ul');
                        menuContent.html(''); 
                        const symbols = [
                            { name: 'CT Aéreo Acc. Vía Pública', type: 'default' },
                            { name: 'CT Sub Acc. Vía Pública', type: 'circle-in-square' },
                            { name: 'CBP Nivel Acc. Vía Pública', type: 'circle-with-lines' },
                            { name: 'Caja Seccionadora', type: 'box-switch' }
                        ];
                        symbols.forEach(symbol => {
                            menuContent.append('li')
                                .attr('class', 'px-4 py-2 hover:bg-gray-100 cursor-pointer text-sm')
                                .text(symbol.name)
                                .on('click', () => {
                                    const nodeData = currentGraphData.nodes.find(n => n.id === d.data.id);
                                    if (nodeData) {
                                        if (symbol.type === 'default') {
                                            delete nodeData.symbolType;
                                        } else {
                                            nodeData.symbolType = symbol.type;
                                        }
                                        saveState();
                                        drawGraph(currentGraphData);
                                    }
                                    contextMenu.classed('hidden', true);
                                });
                        });
                        contextMenu.style('left', `${event.pageX}px`).style('top', `${event.pageY}px`).classed('hidden', false);
                    });

                const drawRhombus = (x, y, parentGroup, sourceNode, targetNode) => {
                    const rhombus = parentGroup.append('path').attr('class', 'connector-rhombus').attr('d', `M ${x},${y-rhombusRadius} L ${x+rhombusRadius},${y} L ${x},${y+rhombusRadius} L ${x-rhombusRadius},${y} Z`);
                    let fillColor = closedColor;
                    if (sourceNode && targetNode) {
                        const sourceData = currentGraphData.nodes.find(n => n.id === sourceNode.data.id);
                        if (sourceData && sourceData.connections) { 
                            const conn = sourceData.connections.find(c => c.targetId === targetNode.data.id); 
                            if (conn) { 
                                fillColor = conn.state === 'closed' ? closedColor : openColor; 
                            } 
                        }
                    }
                    rhombus.style('fill', fillColor);
                };

                nodeElements.each(function(d) {
                    const group = d3.select(this);
                    const isClosedState = d.data.state === 'closed';

                    if (isBNode(d)) {
                        const symbolType = d.data.symbolType || 'default';
                        const canvasGray = '#f5f5f0';
                        const innerSymbolGray = '#d4d4d8'; // Lighter gray
                        
                        group.append('rect').attr('x', -symbolRadius).attr('y', -symbolRadius).attr('width', symbolSize).attr('height', symbolSize).attr('fill', canvasGray).style('stroke', 'none');
                        group.append('rect').attr('class', 'symbol').attr('x', -symbolRadius).attr('y', -symbolRadius).attr('width', symbolSize).attr('height', symbolSize).attr('fill', innerSymbolGray); 
                        const innerRadius = symbolRadius * 0.8;

                        if (symbolType === 'circle-in-square') {
                            group.append('circle').attr('class', 'symbol').attr('r', innerRadius).attr('fill', innerSymbolGray);
                        } else if (symbolType === 'circle-with-lines') {
                            group.append('circle').attr('class', 'symbol').attr('r', innerRadius).attr('fill', innerSymbolGray);
                            const lineOffset = innerRadius * 0.4;
                            const lineLength = innerRadius * 0.8;
                            group.append('line').attr('x1', -lineLength).attr('y1', -lineOffset).attr('x2', lineLength).attr('y2', -lineOffset).style('stroke', '#16a34a').style('stroke-width', 1.5);
                            group.append('line').attr('x1', -lineLength).attr('y1', lineOffset).attr('x2', lineLength).attr('y2', lineOffset).style('stroke', '#16a34a').style('stroke-width', 1.5);
                        } else if (symbolType === 'box-switch') {
                            group.append('path').attr('class', 'symbol').attr('d', `M ${-symbolRadius},0 L ${-symbolRadius * 0.4},0`).attr('fill', 'none');
                            group.append('path').attr('class', 'symbol').attr('d', `M ${0},${-symbolRadius * 0.8} L ${symbolRadius * 0.4},0 L ${symbolRadius},0`).attr('fill', 'none');
                        } else if (symbolType === 'default') {
                            const s_2 = innerRadius;
                            const triangleHeight = (innerRadius * 2 * Math.sqrt(3)) / 2;
                            group.append('path').attr('class', 'symbol').attr('d', `M ${-s_2},${s_2} L ${s_2},${s_2} L 0,${s_2 - triangleHeight} Z`).attr('fill', innerSymbolGray);
                        }
                        
                        if (d.parent) { // This is the fix: only draw if there is a parent
                            drawRhombus(0, -symbolRadius, group, d, d.parent);
                        }
                        
                        if (d.children) {
                            d.children.forEach(child => {
                                if (!isTerminalOutput(child) && !child.data.isPlaceholder) {
                                    const { rhombusX, rhombusY } = getBNodeChildPathInfo(d, child, symbolRadius);
                                    drawRhombus(rhombusX, rhombusY, group, d, child);
                                }
                            });
                        }
                    } else {
                        if (d.data.baseName && d.data.baseName.startsWith('SE-')) { group.append('rect').attr('class', 'symbol').attr('x', -circleRadius).attr('y', -circleRadius).attr('width', circleRadius * 2).attr('height', circleRadius * 2).attr('fill', '#ef4444');
                        } else if (d.data.description === 'UNI MT Seccionador') { 
                            if (!shouldHideSymbol(d)) { 
                                const r = circleRadius;
                                group.append('path')
                                    .attr('class', 'symbol')
                                    .attr('d', `M 0,-${r} L ${r},0 L 0,${r} L -${r},0 Z`)
                                    .attr('fill', isClosedState ? closedColor : openColor);
                            }
                        } else if (d.data.description === 'UNI MT Secc. Autodesconectador') {
                            if (!shouldHideSymbol(d)) {
                                const r = circleRadius;
                                group.append('path')
                                    .attr('class', 'symbol')
                                    .attr('d', `M 0,-${r} L ${r},0 L 0,${r} L -${r},0 Z`)
                                    .attr('fill', openColor);

                                if (isClosedState) {
                                     group.append('path')
                                        .attr('d', `M 0,-${r} L -${r},0 L 0,${r} Z`)
                                        .attr('fill', closedColor)
                                        .style('stroke', 'none');
                                    group.append('text')
                                        .attr('x', r / 2.5)
                                        .attr('text-anchor', 'middle')
                                        .attr('dominant-baseline', 'central')
                                        .attr('font-size', '8px')
                                        .attr('font-weight', 'bold')
                                        .attr('fill', blackColor)
                                        .text('K');
                                }
                            }
                        } else if (d.data.description === 'Secc. Autodesc. B/C Unipolar') { if (!shouldHideSymbol(d)) { const r = circleRadius; group.append('circle').attr('class', 'symbol').attr('r', r).attr('fill', isClosedState ? closedColor : openColor); group.append('path').attr('class', 'symbol').attr('d', `M 0,-${r} L ${r},0 L 0,${r} L -${r},0 Z`).attr('fill', '#fff'); }
                        } else if (d.data.description === 'MD Barra CT') { if (!shouldHideSymbol(d)) { const r = circleRadius; group.append('rect').attr('class', 'symbol').attr('x', -r).attr('y', -r).attr('width', r * 2).attr('height', r * 2).attr('fill', isClosedState ? closedColor : openColor); group.append('path').attr('class', 'symbol').attr('d', `M 0,-${r/2} L ${r/2},${r/2} L -${r/2},${r/2} Z`).attr('fill', '#fff'); }
                        } else if (d.data.description === 'UNI MT Seccionalizador') { if (!shouldHideSymbol(d)) { const r = circleRadius; group.append('path').attr('class', 'symbol').attr('d', `M 0,-${r} L ${r},${r} L -${r},${r} Z`).attr('fill', isClosedState ? closedColor : openColor); group.append('line').attr('class', 'symbol').attr('x1', -r).attr('y1', -r - 5).attr('x2', r).attr('y2', -r - 5).attr('stroke', '#16a34a').attr('stroke-width', 1.5); }
                        } else if (d.data.description === 'UNI MT Reconectador') { if (!shouldHideSymbol(d)) { const r = circleRadius * 1.5; const tBW = r * 1.2; const tH = r * 0.7; group.append('circle').attr('class', 'symbol').attr('r', r).attr('fill', isClosedState ? closedColor : openColor).attr('stroke', '#16a34a').attr('stroke-width', 1.5); group.append('path').attr('class', 'symbol').attr('d', `M ${-tBW / 2},-${tH} L ${tBW / 2},-${tH} L 0,0 Z`).attr('fill', '#fff'); group.append('path').attr('class', 'symbol').attr('d', `M ${-tBW / 2},${tH} L ${tBW / 2},${tH} L 0,0 Z`).attr('fill', '#fff'); }
                        } else if (d.data.description === 'Seccionalizador Unipolar') { if (!shouldHideSymbol(d)) { const r = circleRadius; group.append('circle').attr('class', 'symbol').attr('r', r).attr('fill', isClosedState ? closedColor : openColor); const tS = 0.6; group.append('path').attr('class', 'symbol').attr('d', `M 0,-${r * tS} L ${r * tS},${r * tS} L -${r * tS},${r * tS} Z`).attr('fill', '#fff'); const bO = 0.1; group.append('line').attr('class', 'symbol').attr('x1', -r * tS).attr('y1', -r * tS - (r * bO)).attr('x2', r * tS).attr('y2', -r * tS - (r * bO)).attr('stroke', '#16a34a').attr('stroke-width', 1.5); }
                        } else { if (!shouldHideSymbol(d)) { const r = circleRadius; group.append('circle').attr('class', 'symbol').attr('r', r).attr('fill', isClosedState ? closedColor : openColor); } }
                    }
                });

                const textElements = nodeElements.append('text')
                    .attr('dy', '0.31em')
                    .attr('x', d => d.data.customTextX !== undefined ? d.data.customTextX : 0)
                    .attr('y', d => {
                        if (d.data.customTextY !== undefined) return d.data.customTextY;
                        if (isBNode(d)) return symbolRadius + 15;
                        if (isTerminalOutput(d)) return 0;
                        const radius = getNodeRadius(d);
                        return radius + 15;
                    })
                    .attr('text-anchor', d => d.data.textAnchor || 'middle')
                    .text(d => d.data.displayName)
                    .attr('pointer-events', 'auto');

                textElements.on("dblclick", (event, d) => {
                    event.preventDefault();
                    event.stopPropagation();
                    if (currentTool !== 'select') return;

                    let cpi = d.data.textPositionIndex === undefined ? 0 : d.data.textPositionIndex;
                    cpi = (cpi + 1) % textPositions.length;
                    d.data.textPositionIndex = cpi;

                    const sP = textPositions[cpi];
                    const bO = getNodeRadius(d);

                    let nX = sP.offsetX !== undefined ? sP.offsetX : sP.offsetXFactor * (bO + 12);
                    let nY = sP.offsetY !== undefined ? sP.offsetY : sP.offsetYFactor * (bO + 12);

                    d.data.customTextX = nX;
                    d.data.customTextY = nY;
                    d.data.textAnchor = sP.anchor;

                    d3.select(event.currentTarget)
                        .attr('x', nX)
                        .attr('y', nY)
                        .attr('text-anchor', sP.anchor);

                    const nodeInData = currentGraphData.nodes.find(n => n.id === d.data.id);
                    if (nodeInData) {
                        nodeInData.customTextX = nX;
                        nodeInData.customTextY = nY;
                        nodeInData.textAnchor = sP.anchor;
                        nodeInData.textPositionIndex = cpi;
                    }
                    saveState();
                });

                redrawAllLinks(root);
                
                nodeElements.call(d3.drag().on("start", dragstarted).on("drag", dragged).on("end", dragended));
                
                function dragstarted(event, d) {
                    if(currentTool === 'select') {
                        d3.select(this).raise();
                    }
                }
                
                function dragged(event, d) {
                    if(currentTool !== 'select') return;
                    d.data.customX = event.x;
                    d.data.customY = event.y;
                    d3.select(this).attr("transform", `translate(${d.data.customX},${d.data.customY})`);
                }
                
                function dragended(event, d) {
                    if(currentTool === 'select') {
                        const sourceNode = currentGraphData.nodes.find(n => n.id === d.data.id);
                        if (sourceNode) {
                            sourceNode.customX = d.data.customX;
                            sourceNode.customY = d.data.customY;
                        }
                        redrawAllLinks(root);
                        updateAllCustomConnections();
                        saveState();
                    }
                }

                initializeZoom();
                const initialTranslateX = container.clientWidth / 2 - root.x;
                const initialTranslateY = margin.top - root.y;
                const initialTransform = d3.zoomIdentity.translate(initialTranslateX, initialTranslateY);
                svg.call(zoom.transform, initialTransform);
                
                populateSearchSuggestions();

            } else {
                // --- Setup for Drawing-Only Canvas ---
                const width = container.clientWidth;
                const height = container.clientHeight;
                svg.attr("width", width).attr("height", height);
                rootNode = null; // Ensure rootNode is null for drawing-only mode
                initializeZoom();
            }

            // --- Common Drawing and UI Updates ---
            drawAnnotations();
            drawCustomElements();
            updateDeleteButtonState();
            updateUndoRedoButtons();
            updateClearDrawingsButtonState();
        }
        
        // --- Search and Zoom Functions ---
        function populateSearchSuggestions() {
            if (!rootNode) return;
            const suggestions = document.getElementById('search-suggestions');
            suggestions.innerHTML = ''; // Clear old suggestions
            const visibleNodes = rootNode.descendants().filter(d => !shouldHideSymbol(d));

            visibleNodes.forEach(d => {
                const option = document.createElement('option');
                option.value = d.data.displayName;
                suggestions.appendChild(option);
            });
        }

        function handleSearch(event) {
            const searchTerm = event.target.value;
            if (!rootNode) return;

            const targetNode = rootNode.descendants().find(d => d.data.displayName === searchTerm);

            if (targetNode) {
                zoomToNode(targetNode);
                event.target.value = '';
                event.target.blur();
            }
        }

        function zoomToNode(node) {
            if (!node) return;

            clearSelections();
            selectedNode = node;
            d3.selectAll('.node').filter(d => d.data.id === node.data.id).classed('selected', true);
            updateInfoPanel(node);
            updateDeleteButtonState();

            const svg = d3.select("#graph-svg");
            const container = document.getElementById('visualization-container');
            const width = container.clientWidth;
            
            const nodeX = node.data.customX !== undefined ? node.data.customX : node.x;
            const nodeY = node.data.customY !== undefined ? node.data.customY : node.y;

            const scale = 1.2;
            const yOffset = 100; // Position it 100px from the top of the container
            
            // Calculate the required translation to center the node horizontally
            // and position it at yOffset vertically.
            const tx = width / 2 - scale * nodeX;
            const ty = yOffset - scale * nodeY;

            const transform = d3.zoomIdentity.translate(tx, ty).scale(scale);

            svg.transition()
                .duration(750)
                .call(zoom.transform, transform);
        }


        // --- Custom Element Functions ---
        
        function getPointOnSquarePerimeter(angle, radius) {
            const cos = Math.cos(angle);
            const sin = Math.sin(angle);
            
            if (Math.abs(cos) < 1e-9) return { x: 0, y: radius * Math.sign(sin) };
            if (Math.abs(sin) < 1e-9) return { x: radius * Math.sign(cos), y: 0 };

            if (Math.abs(cos) > Math.abs(sin)) {
                return { x: radius * Math.sign(cos), y: radius * sin / Math.abs(cos) };
            } else {
                return { x: radius * cos / Math.abs(sin), y: radius * Math.sign(sin) };
            }
        }

        function drawCustomElements() {
            const g = d3.select("g.graph-content");
            g.selectAll('.custom-element-group').remove(); 

            const customGroups = g.selectAll('.custom-element-group')
                .data(currentGraphData.customElements, d => d.id)
                .join('g')
                .attr('class', 'custom-element-group')
                .classed('selected', d => selectedCustomElement && selectedCustomElement.id === d.id)
                .attr('transform', d => `translate(${d.x}, ${d.y}) rotate(${d.rotation || 0})`);

            customGroups.each(function(d) {
                const group = d3.select(this);
                group.selectAll("*").remove();

                const symbolType = d.symbolType || 'ct-default';
                const symbolRadius = 15;
                
                const symbolGroup = group.append('g').attr('class', 'symbol-container');
                getSymbolSVG(symbolType, symbolGroup, d);
                
                if (d.symbolType !== 'ground') {
                    group.append('text')
                        .attr('dy', '0.31em')
                        .attr('x', d => d.customTextX !== undefined ? d.customTextX : 0)
                        .attr('y', d => d.customTextY !== undefined ? d.customTextY : symbolRadius + 15)
                        .attr('text-anchor', d => d.textAnchor || 'middle')
                        .text(d => d.name);
                }

                const numOutputs = d.numConnections || 0;
                const rhombusRadius = 4;
                const openColor = '#fff';
                const closedColor = '#4ade80';

                for (let i = 0; i < numOutputs; i++) {
                    let angle;
                    if (d.distributionMode === 'manual' && d.connections[i] && typeof d.connections[i].angle === 'number') {
                        angle = d.connections[i].angle;
                    } else if (numOutputs === 1 && d.connections[0] && typeof d.connections[0].angle === 'number') {
                        angle = d.connections[0].angle;
                    }
                    else {
                        angle = (2 * Math.PI / numOutputs) * i - (Math.PI / 2);
                    }
                    
                    const { x: edgeX, y: edgeY } = getPointOnSquarePerimeter(angle, symbolRadius);
                    const rhombusX = edgeX + rhombusRadius * Math.cos(angle);
                    const rhombusY = edgeY + rhombusRadius * Math.sin(angle);

                    const state = d.connections[i] && d.connections[i].state === 'open' ? 'open' : 'closed';


                    const rhombus = group.append('path')
                        .datum({ connIndex: i })
                        .attr('class', 'connector-rhombus')
                        .classed('manual-mode', d.distributionMode === 'manual')
                        .attr('d', `M ${rhombusX},${rhombusY - rhombusRadius} L ${rhombusX + rhombusRadius},${rhombusY} L ${rhombusX},${rhombusY + rhombusRadius} L ${rhombusX - rhombusRadius},${rhombusY} Z`)
                        .style('fill', state === 'closed' ? closedColor : openColor);
                    
                    if (d.distributionMode === 'manual') {
                        rhombus.call(d3.drag()
                            .on('start', function(event) {
                                event.sourceEvent.stopPropagation();
                            })
                            .on('drag', function(event, rhombusData) {
                                const [pointerX, pointerY] = d3.pointer(event.sourceEvent, g.node());
                                const newAngle = Math.atan2(pointerY - d.y, pointerX - d.x);
                                d.connections[rhombusData.connIndex].angle = newAngle;
                                drawCustomElements();
                            })
                            .on('end', function() {
                                saveState();
                            })
                        );
                    }

                    if (numOutputs === 1 && d.connections[0] && d.connections[0].point) {
                        const connection = d.connections[0];
                        group.append('line')
                            .attr('class', 'connection-line')
                            .attr('x1', rhombusX)
                            .attr('y1', rhombusY)
                            .attr('x2', connection.point.x - d.x)
                            .attr('y2', connection.point.y - d.y);
                    }
                }
            });

            customGroups.on('click', function(event, d) {
                event.stopPropagation();
                if (currentTool !== 'select') return;
                clearSelections();
                selectedCustomElement = d;
                d3.select(this).classed('selected', true);
                updateDeleteButtonState();
                updateInfoPanel();
            }).on('dblclick', function(event, d) {
                if (currentTool !== 'select') return;
                event.preventDefault();
                event.stopPropagation();

                if (event.target.tagName === 'text') {
                    let cpi = d.textPositionIndex === undefined ? 0 : d.textPositionIndex;
                    cpi = (cpi + 1) % textPositions.length;
                    d.textPositionIndex = cpi;
                    const sP = textPositions[cpi];
                    const bO = 15;
                    d.customTextX = sP.offsetX !== undefined ? sP.offsetX : sP.offsetXFactor * (bO + 8);
                    d.customTextY = sP.offsetY !== undefined ? sP.offsetY : sP.offsetYFactor * (bO + 8);
                    d.textAnchor = sP.anchor;
                    saveState();
                    d3.select(this).select('text')
                        .attr('x', d.customTextX)
                        .attr('y', d.customTextY)
                        .attr('text-anchor', d.textAnchor);
                } else {
                    showTextInputBox("Editar nombre:", d.name, (newName) => {
                        if (newName && newName.trim() !== "" && newName !== d.name) {
                            d.name = newName;
                            saveState();
                            drawCustomElements();
                            updateInfoPanel();
                        }
                    });
                }
            }).call(d3.drag()
                .on("start", function(event, d) {
                    if (currentTool !== 'select') return;
                    d3.select(this).raise();
                    if (!selectedCustomElement || selectedCustomElement.id !== d.id) {
                        clearSelections();
                        selectedCustomElement = d;
                        d3.select(this).classed('selected', true);
                        updateDeleteButtonState();
                        updateInfoPanel();
                    }
                })
                .on("drag", function(event, d) {
                    if (currentTool !== 'select') return;
                    const transform = d3.zoomTransform(d3.select("#graph-svg").node());
                    const k = transform.k;
                    d.x += event.dx / k;
                    d.y += event.dy / k;
                    
                    // Update the connection data for the currently dragged element
                    updateCustomElementConnections(d);
                    
                    // Redraw all custom elements to visually update the connection line in real-time
                    drawCustomElements();
                })
                .on("end", function(event, d) {
                    if (currentTool !== 'select') return;
                    // The data is already up-to-date from the 'drag' event, so just save the state.
                    saveState();
                })
            );
        }
        
        function updateAllCustomConnections() {
            currentGraphData.customElements.forEach(updateCustomElementConnections);
            drawCustomElements();
        }

        function updateCustomElementConnections(element) {
            if (element.numConnections !== 1) {
                if (!element.connections || element.connections.length !== element.numConnections) {
                    element.connections = Array.from({ length: element.numConnections }, (_, i) => ({ id: i, state: 'closed' }));
                }
                return;
            }

            if (!element.connections || element.connections.length !== 1) {
                 element.connections = [{ id: 0, point: null, angle: -Math.PI / 2, state: 'closed' }];
            }
            
            const closestPathPoint = findClosestConnectionPoint({ x: element.x, y: element.y });
            element.connections[0].point = closestPathPoint;

            if (closestPathPoint) {
                const dx = closestPathPoint.x - element.x;
                const dy = closestPathPoint.y - element.y;
                element.connections[0].angle = Math.atan2(dy, dx);
            } else {
                element.connections[0].angle = -Math.PI / 2;
            }
        }

        function findClosestConnectionPoint(point) {
            const g = d3.select("g.graph-content");
            const cables = g.selectAll('.cable-line, .annotation.line-annotation').nodes();
            let bestCandidate = null;
            let minDistance = 150; // This is the final threshold for a valid connection
            const searchRadius = 200; // A larger radius to pre-filter candidate lines/paths

            // Helper function to check if a point is near a bounding box.
            // This quickly eliminates paths that are far away from the element.
            const isPointNearBBox = (p, bbox, threshold) => {
                const closestX = Math.max(bbox.x, Math.min(p.x, bbox.x + bbox.width));
                const closestY = Math.max(bbox.y, Math.min(p.y, bbox.y + bbox.height));
                const dx = p.x - closestX;
                const dy = p.y - closestY;
                // Using squared distance to avoid expensive square root operations
                return (dx * dx + dy * dy) < (threshold * threshold);
            };

            // 1. Filter to get only candidate cables that are reasonably close.
            const candidateCables = cables.filter(pathNode => {
                try {
                    const bbox = pathNode.getBBox();
                    // A quick check to see if the bounding box is valid.
                    if (bbox.width === 0 && bbox.height === 0 && pathNode.getTotalLength() === 0) return false;
                    return isPointNearBBox(point, bbox, searchRadius);
                } catch (e) {
                    // getBBox can fail on elements that are not rendered, so we ignore them.
                    return false;
                }
            });

            // 2. Of the nearby candidates, find the geometrically closest point.
            candidateCables.forEach(pathNode => {
                const result = getClosestPointOnPath(pathNode, point);
                if (result && result.distance < minDistance) {
                    minDistance = result.distance;
                    bestCandidate = result.point;
                }
            });

            return bestCandidate;
        }

        function getClosestPointOnPath(pathNode, point) {
            if (pathNode.tagName === 'line') {
                const x1 = pathNode.x1.baseVal.value;
                const y1 = pathNode.y1.baseVal.value;
                const x2 = pathNode.x2.baseVal.value;
                const y2 = pathNode.y2.baseVal.value;

                const A = point.x - x1;
                const B = point.y - y1;
                const C = x2 - x1;
                const D = y2 - y1;

                const dot = A * C + B * D;
                const len_sq = C * C + D * D;
                let param = -1;
                if (len_sq !== 0) 
                    param = dot / len_sq;

                let xx, yy;

                if (param < 0) {
                    xx = x1;
                    yy = y1;
                } else if (param > 1) {
                    xx = x2;
                    yy = y2;
                } else {
                    xx = x1 + param * C;
                    yy = y1 + param * D;
                }

                const dx = point.x - xx;
                const dy = point.y - yy;
                return { point: { x: xx, y: yy }, distance: Math.sqrt(dx * dx + dy * dy) };

            } else { // It's a path
                const pathLength = pathNode.getTotalLength();
                if (pathLength === 0) return null;
                let precision = 8;
                let bestPoint = null;
                let bestLength = 0;
                let bestDistance = Infinity;

                for (let scanLength = 0; scanLength <= pathLength; scanLength += precision) {
                    const p = pathNode.getPointAtLength(scanLength);
                    const dx = p.x - point.x;
                    const dy = p.y - point.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < bestDistance) {
                        bestPoint = p;
                        bestLength = scanLength;
                        bestDistance = dist;
                    }
                }
                
                precision /= 2;
                while (precision > 0.5) {
                    const beforeLength = Math.max(0, bestLength - precision);
                    const afterLength = Math.min(pathLength, bestLength + precision);
                    
                    const pBefore = pathNode.getPointAtLength(beforeLength);
                    const dBefore = Math.hypot(pBefore.x - point.x, pBefore.y - point.y);

                    const pAfter = pathNode.getPointAtLength(afterLength);
                    const dAfter = Math.hypot(pAfter.x - point.x, pAfter.y - point.y);

                    if (dBefore < bestDistance) {
                        bestDistance = dBefore;
                        bestPoint = pBefore;
                        bestLength = beforeLength;
                    }
                    if (dAfter < bestDistance) {
                        bestDistance = dAfter;
                        bestPoint = pAfter;
                        bestLength = afterLength;
                    }
                    precision /= 2;
                }
                return { point: bestPoint, distance: bestDistance };
            }
        }


        // --- History, State, and Sketch Management ---
        
        function clearSelections() {
            selectedNode = null;
            selectedAnnotation = null;
            selectedCustomElement = null;
            d3.selectAll('.node.selected').classed('selected', false);
            d3.selectAll('.annotation-group.selected').classed('selected', false);
            d3.selectAll('.custom-element-group.selected').classed('selected', false);
            hideInfoPanel();
        }

        function updateDeleteButtonState() {
            document.getElementById('delete-btn').disabled = !selectedNode && !selectedAnnotation && !selectedCustomElement;
        }

        function updateUndoRedoButtons() {
            document.getElementById('undo-btn').disabled = historyIndex <= 0;
            document.getElementById('redo-btn').disabled = historyIndex >= history.length - 1;
        }
        
        function updateClearDrawingsButtonState() {
            document.getElementById('clear-drawings-btn').disabled = currentGraphData.nodes.length === 0 && currentGraphData.annotations.length === 0 && currentGraphData.customElements.length === 0;
        }

        function saveState() {
            history = history.slice(0, historyIndex + 1);
            const newState = JSON.parse(JSON.stringify(currentGraphData));
            history.push(newState);
            historyIndex++;
            updateUndoRedoButtons();
        }

        function undo() {
            if (historyIndex <= 0) return;
            historyIndex--;
            currentGraphData = JSON.parse(JSON.stringify(history[historyIndex]));
            directedAdj = null;
            parentMap = null;
            clearSelections();
            drawGraph(currentGraphData);
            updateUndoRedoButtons();
        }

        function redo() {
            if (historyIndex >= history.length - 1) return;
            historyIndex++;
            currentGraphData = JSON.parse(JSON.stringify(history[historyIndex]));
            directedAdj = null;
            parentMap = null;
            clearSelections();
            drawGraph(currentGraphData);
            updateUndoRedoButtons();
        }
        
        function downloadObjectAsJson(exportObj, exportName){
            const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(exportObj, null, 2));
            const downloadAnchorNode = document.createElement('a');
            downloadAnchorNode.setAttribute("href", dataStr);
            downloadAnchorNode.setAttribute("download", exportName);
            document.body.appendChild(downloadAnchorNode); // required for firefox
            downloadAnchorNode.click();
            downloadAnchorNode.remove();
        }

        function handleDownloadCurrentSketch() {
            if (currentGraphData.nodes.length === 0 && currentGraphData.annotations.length === 0 && currentGraphData.customElements.length === 0) {
                showMessageBox("No hay nada que descargar en el lienzo actual.");
                return;
            }
            const filename = `esquema-${new Date().toISOString().slice(0,10)}.json`;
            downloadObjectAsJson(currentGraphData, filename);
        }

        function handleUploadSketch(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const uploadedData = JSON.parse(e.target.result);
                    
                    if (typeof uploadedData !== 'object' || uploadedData === null || !('nodes' in uploadedData) || !('edges' in uploadedData) || !('annotations' in uploadedData) || !('customElements' in uploadedData)) {
                        throw new Error("El archivo no parece ser un croquis válido.");
                    }

                    saveState();
                    currentGraphData = uploadedData;
                    directedAdj = null;
                    parentMap = null;
                    clearSelections();
                    drawGraph(currentGraphData);
                    
                    showMessageBox(`Croquis '${file.name}' cargado correctamente.`);

                } catch (error) {
                    console.error("Error al cargar el croquis:", error);
                    showError(`No se pudo cargar el archivo. Asegúrate de que es un archivo de croquis válido. (${error.message})`);
                } finally {
                    event.target.value = '';
                }
            };
            reader.onerror = () => {
                showError("No se pudo leer el archivo del croquis.");
                event.target.value = '';
            };
            reader.readAsText(file);
        }

        function handleSaveSketch() {
            if (currentGraphData.nodes.length === 0 && currentGraphData.annotations.length === 0 && currentGraphData.customElements.length === 0) {
                showMessageBox("No hay nada que guardar en el lienzo.");
                return;
            }
            const defaultName = `Croquis ${savedSketches.length + 1}`;
            showTextInputBox("Ingrese un nombre para el croquis:", defaultName, (name) => {
                if (name && name.trim() !== "") {
                    const currentState = {
                        name: name.trim(),
                        data: JSON.parse(JSON.stringify(currentGraphData))
                    };
                    savedSketches.push(currentState);
                    updateSavedSketchesDropdown();
                    showMessageBox(`'${name.trim()}' guardado correctamente.`);
                }
            });
        }

        function updateSavedSketchesDropdown() {
            const list = document.getElementById('saved-sketches-list');
            list.innerHTML = ''; // Clear list

            if (savedSketches.length === 0) {
                list.innerHTML = '<li class="text-center text-gray-500 py-4 px-2">No hay croquis guardados.</li>';
                return;
            }

            savedSketches.forEach((sketch, index) => {
                const li = document.createElement('li');
                li.className = 'flex justify-between items-center p-2 hover:bg-gray-100 rounded-md';
                li.innerHTML = `
                    <span class="truncate flex-grow cursor-pointer" onclick="loadSketch(${index})">${sketch.name}</span>
                    <div class="flex items-center flex-shrink-0">
                        <button onclick="downloadSavedSketch(${index}, event)" title="Descargar" class="p-1 text-gray-500 hover:text-green-600">
                            <svg class="w-4 h-4" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" d="M3 16.5v2.25A2.25 2.25 0 005.25 21h13.5A2.25 2.25 0 0021 18.75V16.5M16.5 12L12 16.5m0 0L7.5 12m4.5 4.5V3" />
                            </svg>
                        </button>
                        <button onclick="deleteSketch(${index}, event)" title="Eliminar" class="p-1 text-gray-500 hover:text-red-600">
                           <svg class="w-4 h-4" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm4 0a1 1 0 012 0v6a1 1 0 11-2 0V8z" clip-rule="evenodd" /></svg>
                        </button>
                    </div>
                `;
                list.appendChild(li);
            });
        }

        function loadSketch(index) {
            if (index < 0 || index >= savedSketches.length) return;
            
            saveState(); // Save current work to history before loading

            const sketchToLoad = savedSketches[index];
            currentGraphData = JSON.parse(JSON.stringify(sketchToLoad.data));
            
            directedAdj = null;
            parentMap = null;

            clearSelections();
            drawGraph(currentGraphData);
            document.getElementById('saved-sketches-menu').classList.add('hidden');
            showMessageBox(`'${sketchToLoad.name}' cargado.`);
        }
        
        function downloadSavedSketch(index, event) {
            event.stopPropagation();
            if (index < 0 || index >= savedSketches.length) return;
            const sketch = savedSketches[index];
            const filename = `${sketch.name.replace(/ /g, '_')}.json`;
            downloadObjectAsJson(sketch.data, filename);
        }

        function deleteSketch(index, event) {
            event.stopPropagation();
            if (index < 0 || index >= savedSketches.length) return;
            
            const sketchName = savedSketches[index].name;
            showMessageBox(`¿Seguro que quieres eliminar '${sketchName}'?`, 'confirm', (confirmed) => {
                if (confirmed) {
                    savedSketches.splice(index, 1);
                    updateSavedSketchesDropdown();
                }
            });
        }


        function handleDelete() {
            if (selectedNode) {
                showDeleteOptions();
            } else if (selectedAnnotation) {
                deleteSelectedAnnotation();
            } else if (selectedCustomElement) {
                deleteSelectedCustomElement();
            }
        }

        function clearDrawings() {
            if (currentGraphData.nodes.length === 0 && currentGraphData.annotations.length === 0 && currentGraphData.customElements.length === 0) return;

            showMessageBox("¿Estás seguro de que quieres limpiar todo el lienzo? Se eliminará el gráfico cargado y todos los dibujos.", 'confirm', (confirmed) => {
                if (confirmed) {
                    initializeBlankCanvas();
                    document.getElementById('file-name').textContent = 'Ningún archivo seleccionado';
                }
            });
        }
        
        function deleteSelectedAnnotation() {
            if (!selectedAnnotation) return;
            const index = currentGraphData.annotations.findIndex(a => a.id === selectedAnnotation.id);
            if (index > -1) {
                currentGraphData.annotations.splice(index, 1);
                clearSelections();
                updateDeleteButtonState();
                saveState();
                drawAnnotations();
                updateClearDrawingsButtonState();
            }
        }

        function deleteSelectedCustomElement() {
            if (!selectedCustomElement) return;
            const index = currentGraphData.customElements.findIndex(el => el.id === selectedCustomElement.id);
            if (index > -1) {
                currentGraphData.customElements.splice(index, 1);
                clearSelections();
                updateDeleteButtonState();
                saveState();
                drawCustomElements();
            }
        }

        function showDeleteOptions() {
            if (!selectedNode) return;
            const container = document.getElementById('message-box-container');
            const nodeName = selectedNode.data.displayName;
            container.innerHTML = `
                <div class="message-box">
                    <p class="mb-4">¿Qué deseas eliminar para el nodo <b>${nodeName}</b>?</p>
                    <button id="del-node" class="btn-danger">Solo este elemento</button>
                    <button id="del-downstream" class="btn-danger">Rama Inferior (hijos)</button>
                    <button id="del-upstream" class="btn-danger">Rama Superior (padres)</button>
                    <button id="del-cancel" class="btn-cancel">Cancelar</button>
                </div>
            `;
            document.getElementById('del-node').onclick = () => { container.innerHTML = ''; deleteSingleNode(); };
            document.getElementById('del-downstream').onclick = () => { container.innerHTML = ''; deleteBranch('downstream'); };
            document.getElementById('del-upstream').onclick = () => { container.innerHTML = ''; deleteBranch('upstream'); };
            document.getElementById('del-cancel').onclick = () => { container.innerHTML = ''; };
        }
        
        function deleteSingleNode() {
            if (!selectedNode) return;
            const nodeIdToDelete = selectedNode.data.id;
            const parent = selectedNode.parent;
            const children = selectedNode.children || [];
            const isCTNode = isBNode(selectedNode);

            if (isCTNode) {
                const terminalChildrenIds = new Set(children.filter(c => isTerminalOutput(c)).map(c => c.data.id));
                const visibleChildren = children.filter(c => !isTerminalOutput(c));
                const nodesToDelete = new Set([nodeIdToDelete, ...terminalChildrenIds]);
                currentGraphData.nodes = currentGraphData.nodes.filter(n => !nodesToDelete.has(n.id));
                currentGraphData.edges = currentGraphData.edges.filter(e => !nodesToDelete.has(e.source) && !nodesToDelete.has(e.target));
                if (parent) {
                    const parentId = parent.data.id;
                    visibleChildren.forEach(child => { currentGraphData.edges.push({ source: parentId, target: child.data.id }); });
                } else { pruneOrphanedNodes(); }
            } else { 
                if (parent) {
                    const parentId = parent.data.id;
                    currentGraphData.nodes = currentGraphData.nodes.filter(n => n.id !== nodeIdToDelete);
                    currentGraphData.edges = currentGraphData.edges.filter(e => e.source !== nodeIdToDelete && e.target !== nodeIdToDelete);
                    children.forEach(child => { currentGraphData.edges.push({ source: parentId, target: child.data.id }); });
                } else {
                    currentGraphData.nodes = currentGraphData.nodes.filter(n => n.id !== nodeIdToDelete);
                    currentGraphData.edges = currentGraphData.edges.filter(e => e.source !== nodeIdToDelete && e.target !== nodeIdToDelete);
                    pruneOrphanedNodes();
                }
            }

            directedAdj = null;
            parentMap = null;

            saveState();
            clearSelections();
            updateDeleteButtonState();
            if (currentGraphData.nodes.length === 0) {
                showError("Todos los elementos han sido eliminados. Carga un nuevo archivo CSV.");
            } else if (!currentGraphData.rootId || !currentGraphData.nodes.some(n => n.id === currentGraphData.rootId)) {
                pruneOrphanedNodes();
                if(!currentGraphData.rootId) { showError("No se pudo encontrar un nodo raíz válido después de la eliminación."); } 
                else { drawGraph(currentGraphData); }
            } else { drawGraph(currentGraphData); }
        }

        function deleteBranch(direction) {
            if (!selectedNode) return;
            const nodesToDelete = new Set();

            if (direction === 'downstream') {
                const collectDescendants = (node) => {
                    if (!node.children || node.children.length === 0) return;
                    node.children.forEach(child => {
                        nodesToDelete.add(child.data.id);
                        collectDescendants(child);
                    });
                };
                collectDescendants(selectedNode);
                
                const stubAnnotation = {
                    id: `anno-stub-${selectedNode.data.id}-${Date.now()}`,
                    type: 'dashed-line-stub',
                    parentId: selectedNode.data.id,
                    direction: 'down',
                    offsetX: 0,
                    offsetY: 40
                };
                const existingStub = currentGraphData.annotations.find(a => a.type === 'dashed-line-stub' && a.parentId === selectedNode.data.id && a.direction === 'down');
                if (!existingStub) {
                    currentGraphData.annotations.push(stubAnnotation);
                }

            } else if (direction === 'upstream') {
                const collectAncestors = (node) => {
                    if (!node || !node.parent) return;
                    nodesToDelete.add(node.parent.data.id);
                    collectAncestors(node.parent);
                };
                collectAncestors(selectedNode);
                
                const stubAnnotation = {
                    id: `anno-stub-${selectedNode.data.id}-${Date.now()}`,
                    type: 'dashed-line-stub',
                    parentId: selectedNode.data.id,
                    direction: 'up',
                    offsetX: 0,
                    offsetY: -40
                };
                const existingStub = currentGraphData.annotations.find(a => a.type === 'dashed-line-stub' && a.parentId === selectedNode.data.id && a.direction === 'up');
                if (!existingStub) {
                    currentGraphData.annotations.push(stubAnnotation);
                }
                currentGraphData.rootId = selectedNode.data.id;
            }
            
            currentGraphData.nodes = currentGraphData.nodes.filter(n => !nodesToDelete.has(n.id));
            currentGraphData.edges = currentGraphData.edges.filter(e => !nodesToDelete.has(e.source) && !nodesToDelete.has(e.target));

            directedAdj = null;
            parentMap = null;

            pruneOrphanedNodes();
            saveState();
            clearSelections();
            updateDeleteButtonState();
            if (currentGraphData.nodes.length === 0) { 
                showError("Todos los elementos han sido eliminados. Carga un nuevo archivo CSV."); 
            } else if (!currentGraphData.rootId || !currentGraphData.nodes.some(n => n.id === currentGraphData.rootId)) {
                pruneOrphanedNodes();
                if(!currentGraphData.rootId) { 
                    showError("No se pudo encontrar un nodo raíz válido después de la eliminación."); 
                } else { 
                    drawGraph(currentGraphData); 
                }
            } else { 
                drawGraph(currentGraphData); 
            }
        }

        function pruneOrphanedNodes() {
            if (currentGraphData.nodes.length === 0) { currentGraphData.rootId = null; return; }
            const rootExists = currentGraphData.nodes.some(n => n.id === currentGraphData.rootId);
            if (!rootExists) {
                const sourceIds = new Set(currentGraphData.edges.map(e => e.source));
                const targetIds = new Set(currentGraphData.edges.map(e => e.target));
                const newRootCandidates = [...sourceIds].filter(id => !targetIds.has(id));
                currentGraphData.rootId = newRootCandidates.length > 0 ? newRootCandidates[0] : currentGraphData.nodes[0].id;
            }
            const reachableNodes = new Set();
            const queue = [currentGraphData.rootId];
            const adj = new Map(currentGraphData.nodes.map(d => [d.id, []]));
            currentGraphData.edges.forEach(({ source, target }) => {
                if (!adj.has(source)) adj.set(source, []);
                if (!adj.has(target)) adj.set(target, []);
                adj.get(source).push(target);
                adj.get(target).push(source);
            });
            while (queue.length > 0) {
                const currentNodeId = queue.shift();
                if (!currentNodeId || reachableNodes.has(currentNodeId)) continue;
                reachableNodes.add(currentNodeId);
                (adj.get(currentNodeId) || []).forEach(neighborId => {
                    if (!reachableNodes.has(neighborId)) { queue.push(neighborId); }
                });
            }
            currentGraphData.nodes = currentGraphData.nodes.filter(n => reachableNodes.has(n.id));
            currentGraphData.edges = currentGraphData.edges.filter(e => reachableNodes.has(e.source) && reachableNodes.has(e.target));
            if (!reachableNodes.has(currentGraphData.rootId)) {
                currentGraphData.rootId = currentGraphData.nodes.length > 0 ? currentGraphData.nodes[0].id : null;
            }
        }

        function updateInfoPanel(d_node = null) {
            const panel = document.getElementById('info-panel');
            const content = document.getElementById('info-content');
            
            if (selectedNode) {
                const d = selectedNode;
                panel.classList.remove('translate-x-full');
                const nodeData = currentGraphData.nodes.find(n => n.id === d.data.id);
                if (!nodeData) {
                    content.innerHTML = `<p class="text-gray-500">Error: No se encontraron datos para el nodo seleccionado.</p>`;
                    return;
                }
                let html = `<h3 class="text-lg font-bold text-gray-800 mb-4">${d.data.displayName}</h3>`;
                if (isBNode(d)) {
                    html += `<div class="space-y-2">`;
                    if (d.parent) {
                        const conn = nodeData.connections.find(c => c.targetId === d.parent.data.id);
                        const state = conn ? conn.state : 'closed';
                        const stateText = state === 'closed' ? 'Cerrada' : 'Abierta';
                        const buttonClass = state === 'closed' ? 'bg-green-500' : 'bg-gray-400';
                        html += `<div class="flex justify-between items-center"><span class="text-sm text-gray-600">Entrada (${d.parent.data.displayName}): ${stateText}</span><button onclick="toggleConnectionState('${d.data.id}', '${d.parent.data.id}')" class="px-3 py-1 text-sm rounded ${buttonClass} text-white">Cambiar</button></div>`;
                    }
                    if (d.children) {
                        d.children.forEach(child => {
                            if (child.data.isPlaceholder) return;
                            const conn = nodeData.connections.find(c => c.targetId === child.data.id);
                            const state = conn ? conn.state : 'closed';
                            const stateText = state === 'closed' ? 'Cerrada' : 'Abierta';
                            const buttonClass = state === 'closed' ? 'bg-green-500' : 'bg-gray-400';
                            html += `<div class="flex justify-between items-center"><span class="text-sm text-gray-600">Salida (${child.data.displayName}): ${stateText}</span><button onclick="toggleConnectionState('${d.data.id}', '${child.data.id}')" class="px-3 py-1 text-sm rounded ${buttonClass} text-white">Cambiar</button></div>`;
                        });
                    }
                    html += `</div>`;
                } else {
                    const connectionCount = (d.parent ? 1 : 0) + (d.children ? d.children.length : 0);
                    html += `<div class="space-y-3"><p class="text-sm text-gray-600">Conexiones: ${connectionCount}</p><div class="flex justify-between items-center"><span class="text-sm text-gray-600">Estado: ${nodeData.state === 'closed' ? 'Cerrado' : 'Abierto'}</span><button onclick="toggleNodeState('${d.data.id}')" class="px-3 py-1 text-sm rounded ${nodeData.state === 'closed' ? 'bg-green-500' : 'bg-gray-400'} text-white">Cambiar</button></div></div>`;
                }
                content.innerHTML = html;
            } else if (selectedCustomElement) {
                panel.classList.remove('translate-x-full');
                const d = selectedCustomElement;
                const ct_symbols = [
                    { name: 'Personalizado', type: 'star' },
                    { name: 'CT Aéreo', type: 'ct-default' },
                    { name: 'CT Subterráneo', type: 'ct-circle-in-square' },
                    { name: 'CBP', type: 'ct-circle-with-lines' },
                    { name: 'Caja Seccionadora', type: 'ct-box-switch' }
                ];
                
                const seccionadores_symbols = [
                    { name: 'Seccionador', type: 'seccionador' },
                    { name: 'Secc. Autodesc.', type: 'secc-autodesc' },
                    { name: 'Secc. Autodesc. B/C Unipolar', type: 'secc-autodesc-b-c' },
                    { name: 'MD Barra CT', type: 'md-barra-ct' }
                ];

                const otros_symbols = [
                    { name: 'Seccionalizador', type: 'seccionalizador' },
                    { name: 'Seccionalizador Unipolar', type: 'seccionalizador-unipolar' },
                    { name: 'Reconectador', type: 'reconectador' }
                ];

                const buildSymbolOptions = (symbols) => symbols.map(symbol => {
                    const isActive = (d.symbolType || 'ct-default') === symbol.type;
                    return `<div class="symbol-option flex items-center gap-3 ${isActive ? 'active' : ''}" onclick="changeCustomElementSymbol('${d.id}', '${symbol.type}')">
                                <svg width="30" height="30" viewBox="-15 -15 30 30">${getSymbolSVGString(symbol.type)}</svg>
                                <span class="text-sm">${symbol.name}</span>
                            </div>`;
                }).join('');

                let distributionButtonHTML = '';
                if (d.numConnections > 1) {
                    const modeText = d.distributionMode === 'manual' ? 'Automática' : 'Manual';
                    const buttonClass = d.distributionMode === 'manual' ? 'bg-blue-500' : 'bg-gray-400';
                     distributionButtonHTML = `<div class="mt-4"><button onclick="toggleDistributionMode('${d.id}')" class="w-full px-3 py-2 text-sm rounded ${buttonClass} text-white">Distribución ${modeText}</button></div>`;
                }
                
                let connectionsHTML = '';
                if (d.numConnections > 0) {
                    connectionsHTML = '<h4 class="text-md font-semibold text-gray-700 mb-2 mt-4">Conexiones</h4><div class="space-y-2">';
                    for (let i = 0; i < d.numConnections; i++) {
                        const conn = d.connections[i] || { state: 'closed' };
                        const state = conn.state === 'open' ? 'Abierta' : 'Cerrada';
                        const buttonClass = conn.state === 'open' ? 'bg-gray-400' : 'bg-green-500';
                        connectionsHTML += `<div class="flex justify-between items-center">
                                                <span class="text-sm text-gray-600">Salida ${i + 1}: ${state}</span>
                                                <button onclick="toggleCustomConnectionState('${d.id}', ${i})" class="px-3 py-1 text-sm rounded ${buttonClass} text-white">Cambiar</button>
                                            </div>`;
                    }
                    connectionsHTML += '</div>';
                } else {
                    // NEW: Show a master state toggle if there are no connections
                    const state = d.state === 'open' ? 'Abierto' : 'Cerrado';
                    const buttonClass = d.state === 'open' ? 'bg-gray-400' : 'bg-green-500';
                    connectionsHTML = `<div class="mt-4"><div class="flex justify-between items-center">
                                            <span class="text-sm text-gray-600">Estado: ${state}</span>
                                            <button onclick="toggleCustomElementState('${d.id}')" class="px-3 py-1 text-sm rounded ${buttonClass} text-white">Cambiar</button>
                                        </div></div>`;
                }


                content.innerHTML = `
                    <h3 class="text-lg font-bold text-gray-800 mb-2">${d.name}</h3>
                    <div class="flex items-center gap-2">
                        <label for="num-outputs-input" class="text-sm text-gray-600">Salidas:</label>
                        <input type="number" id="num-outputs-input" value="${d.numConnections}" class="w-16 p-1 border border-gray-300 rounded-md text-sm">
                        <button onclick="updateCustomElementOutputs('${d.id}')" class="px-3 py-1 text-sm rounded bg-blue-500 text-white">Actualizar</button>
                    </div>
                    ${distributionButtonHTML}
                    ${connectionsHTML}
                    <details class="mt-4 border-t pt-2">
                        <summary class="font-semibold text-md text-gray-700">Símbolos CT</summary>
                        <div class="space-y-2 mt-2">${buildSymbolOptions(ct_symbols)}</div>
                    </details>
                    <details class="mt-2 border-t pt-2">
                        <summary class="font-semibold text-md text-gray-700">Seccionadores</summary>
                        <div class="space-y-2 mt-2">${buildSymbolOptions(seccionadores_symbols)}</div>
                    </details>
                    <details class="mt-2 border-t pt-2">
                        <summary class="font-semibold text-md text-gray-700">Otros</summary>
                        <div class="space-y-2 mt-2">${buildSymbolOptions(otros_symbols)}</div>
                    </details>
                `;
            } else {
                hideInfoPanel();
            }
        }

        function toggleDistributionMode(elementId) {
            const element = currentGraphData.customElements.find(el => el.id === elementId);
            if (element) {
                element.distributionMode = element.distributionMode === 'manual' ? 'auto' : 'manual';
                if (element.distributionMode === 'auto') {
                    // Clear custom angles when switching back to auto
                    element.connections.forEach(c => delete c.angle);
                }
                saveState();
                drawCustomElements();
                updateInfoPanel();
            }
        }
        
        function updateCustomElementOutputs(elementId) {
            const input = document.getElementById('num-outputs-input');
            const newCount = parseInt(input.value, 10);
            if (isNaN(newCount) || newCount < 0 || newCount > 8) {
                showMessageBox("Por favor, ingrese un número válido entre 0 y 8.");
                return;
            }
            const element = currentGraphData.customElements.find(el => el.id === elementId);
            if (element) {
                element.numConnections = newCount;
                // Reset connections array
                element.connections = Array.from({ length: newCount }, (_, i) => ({ id: i, state: 'closed' }));
                if (newCount === 1) {
                    updateCustomElementConnections(element); // Re-run auto-connection for single output
                }
                saveState();
                drawCustomElements();
                updateInfoPanel();
            }
        }

        function toggleCustomElementState(elementId) {
            const element = currentGraphData.customElements.find(el => el.id === elementId);
            if (element) {
                element.state = element.state === 'open' ? 'closed' : 'open';
                saveState();
                drawCustomElements();
                updateInfoPanel();
            }
        }

        function toggleCustomConnectionState(elementId, connIndex) {
            const element = currentGraphData.customElements.find(el => el.id === elementId);
            if (element && element.connections[connIndex]) {
                const currentState = element.connections[connIndex].state || 'closed';
                element.connections[connIndex].state = currentState === 'closed' ? 'open' : 'closed';
                saveState();
                drawCustomElements();
                updateInfoPanel();
            }
        }

        function getSymbolSVG(symbolType, group, elementData) {
            const symbolRadius = 15;
            const innerRadius = symbolRadius * 0.8;
            const innerSymbolGray = '#d4d4d8';
            const openColor = '#fff';
            const closedColor = '#4ade80';
            const blackColor = '#1f2937';
            
            let isClosedState;
            if (!elementData || elementData.numConnections === 0) {
                isClosedState = !elementData || elementData.state !== 'open';
            } else {
                isClosedState = !elementData.connections || elementData.connections.length === 0 || elementData.connections[0].state !== 'open';
            }

            const circleRadius = 8;
            
            switch(symbolType) {
                case 'star': group.append('path').attr('class', 'symbol star').attr('d', 'M0,-10 L2.939,-4.045 L9.511,-3.09 L4.755,1.545 L5.878,8.09 L0,5 L-5.878,8.09 L-4.755,1.545 L-9.511,-3.09 L-2.939,-4.045 Z'); break;
                case 'ct-default': 
                    group.append('rect').attr('class', 'symbol').attr('x', -symbolRadius).attr('y', -symbolRadius).attr('width', symbolRadius*2).attr('height', symbolRadius*2).attr('fill', innerSymbolGray);
                    const s_2 = innerRadius; const triangleHeight = (innerRadius * 2 * Math.sqrt(3)) / 2;
                    group.append('path').attr('class', 'symbol').attr('d', `M ${-s_2},${s_2} L ${s_2},${s_2} L 0,${s_2 - triangleHeight} Z`).attr('fill', innerSymbolGray);
                    break;
                case 'ct-circle-in-square':
                    group.append('rect').attr('class', 'symbol').attr('x', -symbolRadius).attr('y', -symbolRadius).attr('width', symbolRadius*2).attr('height', symbolRadius*2).attr('fill', innerSymbolGray);
                    group.append('circle').attr('class', 'symbol').attr('r', innerRadius).attr('fill', innerSymbolGray);
                    break;
                case 'ct-circle-with-lines':
                    group.append('rect').attr('class', 'symbol').attr('x', -symbolRadius).attr('y', -symbolRadius).attr('width', symbolRadius*2).attr('height', symbolRadius*2).attr('fill', innerSymbolGray);
                    group.append('circle').attr('class', 'symbol').attr('r', innerRadius).attr('fill', innerSymbolGray);
                    const lineOffset = innerRadius * 0.4; const lineLength = innerRadius * 0.8;
                    group.append('line').attr('x1', -lineLength).attr('y1', -lineOffset).attr('x2', lineLength).attr('y2', -lineOffset).style('stroke', '#16a34a').style('stroke-width', 1.5);
                    group.append('line').attr('x1', -lineLength).attr('y1', lineOffset).attr('x2', lineLength).attr('y2', lineOffset).style('stroke', '#16a34a').style('stroke-width', 1.5);
                    break;
                case 'ct-box-switch':
                    group.append('rect').attr('class', 'symbol').attr('x', -symbolRadius).attr('y', -symbolRadius).attr('width', symbolRadius*2).attr('height', symbolRadius*2).attr('fill', innerSymbolGray);
                    group.append('path').attr('class', 'symbol').attr('d', `M ${-symbolRadius},0 L ${-symbolRadius * 0.4},0`).attr('fill', 'none');
                    group.append('path').attr('class', 'symbol').attr('d', `M ${0},${-symbolRadius * 0.8} L ${symbolRadius * 0.4},0 L ${symbolRadius},0`).attr('fill', 'none');
                    break;
                case 'seccionador': { 
                    const r = circleRadius;
                    group.append('path')
                        .attr('class', 'symbol')
                        .attr('d', `M 0,-${r} L ${r},0 L 0,${r} L -${r},0 Z`)
                        .attr('fill', isClosedState ? closedColor : openColor);
                    break; 
                }
                case 'secc-autodesc': {
                    const r = circleRadius;
                    group.append('path')
                        .attr('class', 'symbol')
                        .attr('d', `M 0,-${r} L ${r},0 L 0,${r} L -${r},0 Z`)
                        .attr('fill', openColor);

                    if (isClosedState) {
                         group.append('path')
                            .attr('d', `M 0,-${r} L -${r},0 L 0,${r} Z`)
                            .attr('fill', closedColor)
                            .style('stroke', 'none');
                        group.append('text')
                            .attr('x', r / 2.5)
                            .attr('text-anchor', 'middle')
                            .attr('dominant-baseline', 'central')
                            .attr('font-size', '8px')
                            .attr('font-weight', 'bold')
                            .attr('fill', blackColor)
                            .text('K');
                    }
                    break;
                }
                case 'secc-autodesc-b-c': { const r = circleRadius; group.append('circle').attr('class', 'symbol').attr('r', r).attr('fill', isClosedState ? closedColor : openColor); group.append('path').attr('class', 'symbol').attr('d', `M 0,-${r} L ${r},0 L 0,${r} L -${r},0 Z`).attr('fill', '#fff'); break; }
                case 'md-barra-ct': { const r = circleRadius; group.append('rect').attr('class', 'symbol').attr('x', -r).attr('y', -r).attr('width', r * 2).attr('height', r * 2).attr('fill', isClosedState ? closedColor : openColor); group.append('path').attr('class', 'symbol').attr('d', `M 0,-${r/2} L ${r/2},${r/2} L -${r/2},${r/2} Z`).attr('fill', '#fff'); break; }
                case 'seccionalizador': { const r = circleRadius; group.append('path').attr('class', 'symbol').attr('d', `M 0,-${r} L ${r},${r} L -${r},${r} Z`).attr('fill', isClosedState ? closedColor : openColor); group.append('line').attr('class', 'symbol').attr('x1', -r).attr('y1', -r - 5).attr('x2', r).attr('y2', -r - 5).attr('stroke', '#16a34a').attr('stroke-width', 1.5); break; }
                case 'reconectador': { const r = circleRadius * 1.5; const tBW = r * 1.2; const tH = r * 0.7; group.append('circle').attr('class', 'symbol').attr('r', r).attr('fill', isClosedState ? closedColor : openColor).attr('stroke', '#16a34a').attr('stroke-width', 1.5); group.append('path').attr('class', 'symbol').attr('d', `M ${-tBW / 2},-${tH} L ${tBW / 2},-${tH} L 0,0 Z`).attr('fill', '#fff'); group.append('path').attr('class', 'symbol').attr('d', `M ${-tBW / 2},${tH} L ${tBW / 2},${tH} L 0,0 Z`).attr('fill', '#fff'); break; }
                case 'seccionalizador-unipolar': { const r = circleRadius; group.append('circle').attr('class', 'symbol').attr('r', r).attr('fill', isClosedState ? closedColor : openColor); const tS = 0.6; group.append('path').attr('class', 'symbol').attr('d', `M 0,-${r * tS} L ${r * tS},${r * tS} L -${r * tS},${r * tS} Z`).attr('fill', '#fff'); const bO = 0.1; group.append('line').attr('class', 'symbol').attr('x1', -r * tS).attr('y1', -r * tS - (r * bO)).attr('x2', r * tS).attr('y2', -r * tS - (r * bO)).attr('stroke', '#16a34a').attr('stroke-width', 1.5); break; }
                default: break;
            }
        }
        
        function getSymbolSVGString(symbolType) {
            const symbolRadius = 15;
            const innerRadius = symbolRadius * 0.8;
            const innerSymbolGray = '#d4d4d8';
            const openColor = '#fff';
            const closedColor = '#4ade80';
            const blackColor = '#1f2937';
            const strokeColor = '#1f2937';
            const strokeWidth = '1.5';
            const isClosedState = true;
            const circleRadius = 8;
            let r;
            switch(symbolType) {
                case 'star': return `<path class="symbol star" fill="#e0f2fe" stroke="#0ea5e9" stroke-width="1.5" d="M0,-10 L2.939,-4.045 L9.511,-3.09 L4.755,1.545 L5.878,8.09 L0,5 L-5.878,8.09 L-4.755,1.545 L-9.511,-3.09 L-2.939,-4.045 Z"></path>`;
                case 'ct-default': 
                    const s_2 = innerRadius;
                    const triangleHeight = (innerRadius * 2 * Math.sqrt(3)) / 2;
                    return `<rect class="symbol" x="-15" y="-15" width="30" height="30" fill="${innerSymbolGray}" stroke="${strokeColor}" stroke-width="${strokeWidth}"></rect>
                            <path class="symbol" d="M ${-s_2},${s_2} L ${s_2},${s_2} L 0,${s_2 - triangleHeight} Z" fill="${innerSymbolGray}" stroke="${strokeColor}" stroke-width="${strokeWidth}"></path>`;
                case 'ct-circle-in-square':
                    return `<rect class="symbol" x="-15" y="-15" width="30" height="30" fill="${innerSymbolGray}" stroke="${strokeColor}" stroke-width="${strokeWidth}"></rect>
                            <circle class="symbol" r="${innerRadius}" fill="${innerSymbolGray}" stroke="${strokeColor}" stroke-width="${strokeWidth}"></circle>`;
                case 'ct-circle-with-lines':
                    const lineOffset = innerRadius * 0.4;
                    const lineLength = innerRadius * 0.8;
                    return `<rect class="symbol" x="-15" y="-15" width="30" height="30" fill="${innerSymbolGray}" stroke="${strokeColor}" stroke-width="${strokeWidth}"></rect>
                            <circle class="symbol" r="${innerRadius}" fill="${innerSymbolGray}" stroke="${strokeColor}" stroke-width="${strokeWidth}"></circle>
                            <line x1="${-lineLength}" y1="${-lineOffset}" x2="${lineLength}" y2="${-lineOffset}" stroke="#16a34a" stroke-width="1.5"></line>
                            <line x1="${-lineLength}" y1="${lineOffset}" x2="${lineLength}" y2="${lineOffset}" stroke="#16a34a" stroke-width="1.5"></line>`;
                case 'ct-box-switch':
                    return `<rect class="symbol" x="-15" y="-15" width="30" height="30" fill="${innerSymbolGray}" stroke="${strokeColor}" stroke-width="${strokeWidth}"></rect>
                            <path class="symbol" d="M -15,0 L -6,0" fill="none" stroke="${strokeColor}" stroke-width="${strokeWidth}"></path>
                            <path class="symbol" d="M 0,-12 L 6,0 L 15,0" fill="none" stroke="${strokeColor}" stroke-width="${strokeWidth}"></path>`;
                case 'seccionador':
                    r = circleRadius; 
                    return `<path d="M 0,-${r} L ${r},0 L 0,${r} L -${r},0 Z" fill="${closedColor}" stroke="${strokeColor}" stroke-width="${strokeWidth}"></path>`;
                case 'secc-autodesc':
                     r = circleRadius; 
                    const bgAutodesc = `<path d="M 0,-${r} L ${r},0 L 0,${r} L -${r},0 Z" fill="${openColor}" stroke="${strokeColor}" stroke-width="${strokeWidth}"></path>`;
                    const halfClosed = `<path d="M 0,-${r} L -${r},0 L 0,${r} Z" fill="${closedColor}" stroke="none"></path>`;
                    const kText = `<text x="${r/2.5}" y="0" text-anchor="middle" dominant-baseline="central" font-size="8px" font-weight="bold" fill="${blackColor}">K</text>`;
                    return bgAutodesc + halfClosed + kText;
                case 'secc-autodesc-b-c': r = circleRadius; return `<circle class="symbol" r="${r}" fill="${isClosedState ? closedColor : openColor}" stroke="${strokeColor}" stroke-width="${strokeWidth}"></circle><path class="symbol" d="M 0,-${r} L ${r},0 L 0,${r} L -${r},0 Z" fill="#fff" stroke="${strokeColor}" stroke-width="${strokeWidth}"></path>`;
                case 'md-barra-ct': r = circleRadius; return `<rect class="symbol" x="${-r}" y="${-r}" width="${r * 2}" height="${r * 2}" fill="${isClosedState ? closedColor : openColor}" stroke="${strokeColor}" stroke-width="${strokeWidth}"></rect><path class="symbol" d="M 0,-${r/2} L ${r/2},${r/2} L -${r/2},${r/2} Z" fill="#fff" stroke="${strokeColor}" stroke-width="${strokeWidth}"></path>`;
                case 'seccionalizador': r = circleRadius; return `<path class="symbol" d="M 0,-${r} L ${r},${r} L -${r},${r} Z" fill="${isClosedState ? closedColor : openColor}" stroke="${strokeColor}" stroke-width="${strokeWidth}"></path><line class="symbol" x1="${-r}" y1="${-r - 5}" x2="${r}" y2="${-r - 5}" stroke="#16a34a" stroke-width="1.5"></line>`;
                case 'reconectador': r = circleRadius * 1.2; const tBW = r * 1.2; const tH = r * 0.7; return `<circle class="symbol" r="${r}" fill="${isClosedState ? closedColor : openColor}" stroke="${strokeColor}" stroke-width="${strokeWidth}"></circle><path class="symbol" d="M ${-tBW / 2},-${tH} L ${tBW / 2},-${tH} L 0,0 Z" fill="#fff" stroke="${strokeColor}" stroke-width="${strokeWidth}"></path><path class="symbol" d="M ${-tBW / 2},${tH} L ${tBW / 2},${tH} L 0,0 Z" fill="#fff" stroke="${strokeColor}" stroke-width="${strokeWidth}"></path>`;
                case 'seccionalizador-unipolar': r = circleRadius; const tS = 0.6; const bO = 0.1; return `<circle class="symbol" r="${r}" fill="${isClosedState ? closedColor : openColor}" stroke="${strokeColor}" stroke-width="${strokeWidth}"></circle><path class="symbol" d="M 0,-${r * tS} L ${r * tS},${r * tS} L -${r * tS},${r * tS} Z" fill="#fff" stroke="${strokeColor}" stroke-width="${strokeWidth}"></path><line class="symbol" x1="${-r * tS}" y1="${-r * tS - (r * bO)}" x2="${r * tS}" y2="${-r * tS - (r * bO)}" stroke="#16a34a" stroke-width="1.5"></line>`;
                default: return '';
            }
        }

        function changeCustomElementSymbol(elementId, symbolType) {
            const element = currentGraphData.customElements.find(el => el.id === elementId);
            if (element) {
                element.symbolType = symbolType;
                saveState();
                drawCustomElements();
                updateInfoPanel();
            }
        }

        function hideInfoPanel() {
            document.getElementById('info-panel').classList.add('translate-x-full');
        }

        function toggleNodeState(nodeId) {
            const node = currentGraphData.nodes.find(n => n.id === nodeId);
            if (node) {
                node.state = node.state === 'open' ? 'closed' : 'open';
                saveState();
                drawGraph(currentGraphData);
                const svgNode = d3.select("#graph-svg").selectAll('.node').filter(n => n.data.id === selectedNode.data.id).node().__data__;
                updateInfoPanel(svgNode);
            }
        }

        function toggleConnectionState(bNodeId, targetId) {
            const node = currentGraphData.nodes.find(n => n.id === bNodeId);
            if (node && node.baseName.match(/^B\d+/)) {
                if (!node.connections) {
                    node.connections = [];
                }
                let conn = node.connections.find(c => c.targetId === targetId);
                if (conn) {
                    conn.state = conn.state === 'open' ? 'closed' : 'open';
                } else {
                    node.connections.push({ targetId: targetId, state: 'open' });
                }
                saveState();
                drawGraph(currentGraphData);
                const svgNode = d3.select("#graph-svg").selectAll('.node').filter(n => n.data.id === selectedNode.data.id).node().__data__;
                updateInfoPanel(svgNode);
            }
        }
        
        async function generateDiagramCanvas() {
            return new Promise((resolve, reject) => {
                try {
                    const svgElement = document.getElementById('graph-svg');
                    if (!svgElement || !svgElement.children.length) {
                        return reject("No hay diagrama para procesar.");
                    }

                    const g = svgElement.querySelector('g.graph-content');
                    if (!g) {
                        return reject("No se encontró contenido en el diagrama.");
                    }
                    const bbox = g.getBBox();

                    const padding = 20;
                    let scale = 2; 
                    const MAX_DIMENSION = 16000; // Límite seguro para dimensiones del canvas

                    let canvasWidth = (bbox.width + padding * 2) * scale;
                    let canvasHeight = (bbox.height + padding * 2) * scale;

                    if (canvasWidth > MAX_DIMENSION || canvasHeight > MAX_DIMENSION) {
                        const max_bbox_dim = Math.max(bbox.width, bbox.height);
                        scale = MAX_DIMENSION / (max_bbox_dim + padding * 2);
                        canvasWidth = (bbox.width + padding * 2) * scale;
                        canvasHeight = (bbox.height + padding * 2) * scale;
                        showMessageBox("El diagrama es muy grande. La imagen se ha generado a una resolución menor para evitar errores.");
                    }

                    const canvas = document.createElement('canvas');
                    canvas.width = canvasWidth;
                    canvas.height = canvasHeight;
                    const ctx = canvas.getContext('2d');
                    
                    const styles = Array.from(document.styleSheets)
                        .map(sheet => {
                            try {
                                return Array.from(sheet.cssRules).map(rule => rule.cssText).join('\n');
                            } catch (e) {
                                console.warn("No se pudo acceder a las reglas de la hoja de estilo:", e);
                                return '';
                            }
                        }).join('\n');

                    const g_clone = g.cloneNode(true);
                    d3.select(g_clone).attr('transform', `translate(${-bbox.x + padding}, ${-bbox.y + padding})`);
                    
                    const svgString = `
                        <svg width="${(bbox.width + padding * 2)}" height="${(bbox.height + padding * 2)}" xmlns="http://www.w3.org/2000/svg">
                            <style>
                                ${styles}
                            </style>
                            <rect x="0" y="0" width="100%" height="100%" fill="#f5f5f0"></rect>
                            ${g_clone.outerHTML}
                        </svg>`;

                    const img = new Image();
                    const blob = new Blob([svgString], { type: 'image/svg+xml;charset=utf-8' });
                    const url = URL.createObjectURL(blob);

                    img.onload = () => {
                        ctx.scale(scale, scale);
                        ctx.drawImage(img, 0, 0);
                        URL.revokeObjectURL(url);
                        resolve(canvas);
                    };

                    img.onerror = (e) => {
                        URL.revokeObjectURL(url);
                        reject("Error al generar la imagen a partir del diagrama.");
                    };

                    img.src = url;
                } catch (error) {
                    reject(`Ocurrió un error inesperado: ${error.message}`);
                }
            });
        }

        async function copyDiagramAsImage() {
            try {
                const canvas = await generateDiagramCanvas();
                const dataUrl = canvas.toDataURL('image/png');
                
                const modal = document.getElementById('copy-image-modal');
                const imageElement = document.getElementById('image-to-copy');
                
                imageElement.src = dataUrl;
                modal.classList.remove('hidden');
                modal.classList.add('flex');

            } catch (error) {
                console.error('Error al preparar la imagen para copiar:', error);
                showMessageBox(error.toString());
            }
        }

        async function downloadDiagramAsImage() {
            try {
                const canvas = await generateDiagramCanvas();
                const link = document.createElement('a');
                link.download = 'diagrama_de_red.png';
                link.href = canvas.toDataURL('image/png');
                link.click();
                showMessageBox("La descarga del diagrama ha comenzado.");
            } catch (error) {
                console.error('Error al descargar el diagrama:', error);
                showMessageBox(error.toString());
            }
        }


        function initializeBlankCanvas() {
            const svg = d3.select("#graph-svg");
            svg.selectAll("*").remove();
            const container = document.getElementById('visualization-container');

            const width = container.clientWidth;
            const height = container.clientHeight;
            svg.attr("width", width).attr("height", height);

            const defs = svg.append('defs');
            defs.append('pattern')
                .attr('id', 'grid')
                .attr('width', 20)
                .attr('height', 20)
                .attr('patternUnits', 'userSpaceOnUse')
                .append('path')
                .attr('d', 'M 20 0 L 0 0 0 20')
                .attr('fill', 'none')
                .attr('stroke', '#e5e7eb')
                .attr('stroke-width', '0.5');
            
            const drawingArea = svg.append('rect').attr('id', 'drawing-area').attr('width', '100%').attr('height', '100%').attr('fill', 'url(#grid)');

            svg.append("g").attr("class", "graph-content");
            
            initializeZoom();

            currentGraphData = { nodes: [], edges: [], annotations: [], customElements: [], rootId: null };
            history = [];
            historyIndex = -1;
            rootNode = null;
            document.getElementById('search-input').value = '';
            document.getElementById('search-suggestions').innerHTML = '';
            saveState();
            updateUndoRedoButtons();
            updateClearDrawingsButtonState();
            updateSavedSketchesDropdown();
        }

        window.onload = function() {
            initializeBlankCanvas();
        };
    </script>
</body>
</html>
