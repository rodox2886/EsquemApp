<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EsquemApp</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #F3F4F6; /* bg-gray-100 */
        }
        /* --- Iconos y Botones de la Barra de Herramientas --- */
        .toolbox-icon {
            transition: all 0.2s ease-in-out;
            color: #E2E8F0; /* text-slate-200 */
        }
        .toolbox-icon:hover {
            background-color: #475569; /* bg-slate-600 */
            color: #FFFFFF; /* text-white */
        }
        .toolbox-icon.active {
            background-color: #3B82F6; /* Logo Blue */
            color: white;
            box-shadow: 0 0 10px rgba(59, 130, 246, 0.5);
        }
        .toolbox-icon:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }
        /* --- Elementos de la Lista Lateral --- */
        .list-item:hover {
            background-color: #E5E7EB; /* bg-gray-200 */
        }
        /* --- Input de Archivo --- */
        .file-input-wrapper {
            background-color: #F9FAFB; /* bg-gray-50 */
            border: 2px dashed #3B82F6; /* Logo Blue */
            transition: background-color 0.2s ease-in-out;
        }
        .file-input-wrapper:hover {
            background-color: #F3F4F6; /* bg-gray-100 */
        }
        /* --- Dropdowns --- */
        .dropdown {
            position: relative;
            display: inline-block;
        }
        .dropdown-content {
            display: none;
            position: absolute;
            background-color: #ffffff;
            min-width: 220px;
            box-shadow: 0px 10px 20px rgba(0,0,0,0.1);
            z-index: 50;
            border-radius: 0.5rem; /* rounded-lg */
            border: 1px solid #E5E7EB; /* border-gray-200 */
            overflow: hidden;
        }
        .dropdown-content button {
            color: #374151; /* text-gray-700 */
            padding: 12px 16px;
            text-decoration: none;
            display: flex;
            align-items: center;
            gap: 0.75rem; /* gap-3 */
            width: 100%;
            text-align: left;
            transition: background-color 0.2s ease-in-out, color 0.2s ease-in-out;
        }
        .dropdown-content button:hover {
            background-color: #3B82F6; /* Logo Blue */
            color: white;
        }
        .dropdown:hover .dropdown-content {
            display: block;
        }
        /* --- Scrollbars Personalizadas --- */
        ::-webkit-scrollbar {
            width: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #e5e7eb; /* bg-gray-200 */
            border-radius: 10px;
        }
        ::-webkit-scrollbar-thumb {
            background: #9ca3af; /* bg-gray-400 */
            border-radius: 10px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #6b7280; /* bg-gray-500 */
        }
    </style>
</head>
<body class="text-gray-800 flex h-screen overflow-hidden">

    <!-- Panel Lateral -->
    <aside class="w-1/3 max-w-sm flex flex-col bg-white/70 backdrop-blur-sm border-r border-gray-200/80 p-4 space-y-4 h-full overflow-y-auto">
        <div class="flex justify-center items-center py-4">
             <svg width="230" height="50" viewBox="0 0 230 50" xmlns="http://www.w3.org/2000/svg">
                <!-- Icono -->
                <g>
                    <!-- Borde del icono -->
                    <rect x="1" y="1" width="48" height="48" rx="10" stroke="#34D399" stroke-width="2" fill="none"/>
                    <!-- Símbolo eléctrico modificado -->
                    <g transform="translate(10, 8)" stroke="#4F46E5" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round">
                        <!-- Nodo superior -->
                        <circle cx="15" cy="6" r="3" fill="#4F46E5" stroke="none"/>
                        <!-- Linea vertical principal -->
                        <line x1="15" y1="9" x2="15" y2="18"/>
                        <!-- Linea horizontal (bus) -->
                        <line x1="5" y1="18" x2="25" y2="18"/>
                        
                        <!-- Rama izquierda con Triángulo hacia arriba -->
                        <line x1="8" y1="18" x2="8" y2="22"/>
                        <polygon points="4,28 12,28 8,22" stroke="none" fill="#4F46E5"/>

                        <!-- Rama derecha con Rombo -->
                        <line x1="22" y1="18" x2="22" y2="22"/>
                        <polygon points="22,22 25,26 22,30 19,26" stroke="none" fill="#4F46E5"/>
                    </g>
                </g>
                <!-- Texto del Logo -->
                <text x="60" y="34" font-family="Inter, sans-serif" font-size="28" font-weight="bold" fill="#3B82F6">
                    Esquem<tspan fill="#34D399">App</tspan>
                </text>
            </svg>
        </div>
        
        <!-- Carga de Archivo -->
        <div class="bg-white/50 p-4 rounded-xl border border-gray-200/80">
            <label for="csv-file-input" class="block text-sm font-medium text-gray-600 mb-2">Subir archivo CSV:</label>
            <div class="file-input-wrapper p-4 rounded-lg text-center cursor-pointer" onclick="document.getElementById('csv-file-input').click()">
                <span id="file-name" class="text-gray-500">Haz clic para seleccionar un archivo</span>
            </div>
            <input type="file" id="csv-file-input" accept=".csv" class="hidden">
            <button id="load-data-btn" class="mt-3 w-full bg-[#3B82F6] hover:bg-[#2563EB] text-white font-bold py-2 px-4 rounded-lg transition-all duration-200 shadow-md hover:shadow-lg">Cargar y Procesar</button>
        </div>

        <!-- Lista de Elementos -->
        <div class="flex-grow flex flex-col min-h-0 bg-white/50 p-4 rounded-xl border border-gray-200/80">
            <label for="search-input" class="block text-sm font-medium text-gray-600 mb-2">Buscar Elemento:</label>
            <input type="text" id="search-input" placeholder="Buscar por nombre..." class="w-full bg-white border border-gray-300 rounded-lg p-2 mb-3 focus:ring-[#3B82F6] focus:border-[#3B82F6] transition-colors text-gray-900">
            <div id="element-list" class="flex-grow bg-gray-50/70 rounded-lg border border-gray-200 overflow-y-auto p-2">
                <p class="text-gray-500 text-center p-4">Cargue datos para ver los elementos.</p>
            </div>
        </div>
    </aside>

    <!-- Contenido Principal -->
    <main class="flex-1 flex flex-col p-4">
        <!-- Barra de Herramientas -->
        <div class="bg-slate-800 rounded-xl p-3 mb-4 flex items-center flex-wrap gap-4 border border-slate-700/80" id="toolbox">
            
            <!-- Grupo: Edición -->
            <div class="flex items-center space-x-1">
                <button id="tool-select" class="toolbox-icon p-2 rounded-md" title="Seleccionar (V) | Arrastrar para mover elemento | Alt+Arrastrar para mover etiqueta"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" viewBox="0 0 16 16"><path d="M14.082 2.182a.5.5 0 0 1 .103.557L8.528 15.467a.5.5 0 0 1-.917-.007L5.57 10.694.803 8.652a.5.5 0 0 1-.006-.916l12.728-5.657a.5.5 0 0 1 .556.103z"/></svg></button>
            </div>
            <div class="border-l border-slate-600 h-6"></div>

            <!-- Grupo: Historial -->
            <div class="flex items-center space-x-1">
                <button id="tool-undo" class="toolbox-icon p-2 rounded-md" title="Deshacer (Ctrl+Z)" disabled><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M8 3a5 5 0 1 1-4.546 2.914.5.5 0 0 0-.908-.417A6 6 0 1 0 8 2v1z"/><path d="M8 4.466V.534a.25.25 0 0 0-.41-.192L5.23 2.308a.25.25 0 0 0 0 .384l2.36 1.966A.25.25 0 0 0 8 4.466z"/></svg></button>
                <button id="tool-redo" class="toolbox-icon p-2 rounded-md" title="Rehacer (Ctrl+Y)" disabled><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M8 3a5 5 0 1 0 4.546 2.914.5.5 0 0 1 .908-.417A6 6 0 1 1 8 2v1z"/><path d="M8 4.466V.534a.25.25 0 0 1 .41-.192l2.36 1.966a.25.25 0 0 1 0 .384L8.41 4.658A.25.25 0 0 1 8 4.466z"/></svg></button>
            </div>
            <div class="border-l border-slate-600 h-6"></div>

            <!-- Grupo: Archivo -->
            <div class="flex items-center space-x-1">
                 <div class="dropdown">
                     <button class="toolbox-icon p-2 rounded-md font-medium text-sm">Croquis Guardados</button>
                     <div id="saved-sketches-dropdown" class="dropdown-content">
                         <p class="p-3 text-gray-500 text-sm text-center">No hay croquis guardados.</p>
                     </div>
                 </div>
                 <button id="tool-save" class="toolbox-icon p-2 rounded-md" title="Guardar Croquis"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" viewBox="0 0 16 16"><path d="M4.5 1a.5.5 0 0 0-.5.5v4a.5.5 0 0 0 .5.5h7a.5.5 0 0 0 .5-.5v-4a.5.5 0 0 0-.5-.5h-7zM5 1.5h6v3H5v-3z"/><path d="M1.5 0A1.5 1.5 0 0 0 0 1.5v13A1.5 1.5 0 0 0 1.5 16h13a1.5 1.5 0 0 0 1.5-1.5v-13A1.5 1.5 0 0 0 14.5 0h-13zM1 1.5a.5.5 0 0 1 .5-.5h13a.5.5 0 0 1 .5.5v13a.5.5 0 0 1-.5-.5h-13a.5.5 0 0 1-.5-.5v-13zM10 12a1 1 0 1 0 0-2 1 1 0 0 0 0 2z"/></svg></button>
                 <button id="tool-copy-image" class="toolbox-icon p-2 rounded-md" title="Copiar Croquis como Imagen"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" viewBox="0 0 16 16"><path d="M6.002 5.5a1.5 1.5 0 1 1-3 0 1.5 1.5 0 0 1 3 0z"/><path d="M2 1.5A1.5 1.5 0 0 0 .5 3v10A1.5 1.5 0 0 0 2 14.5h12a1.5 1.5 0 0 0 1.5-1.5V3A1.5 1.5 0 0 0 14 1.5H2zM1 3a.5.5 0 0 1 .5-.5h13a.5.5 0 0 1 .5.5v10a.5.5 0 0 1-.5-.5h-13a.5.5 0 0 1-.5-.5V3zm11.5 5.5l-3.293 3.293a.5.5 0 0 1-.707 0L8.5 10.793l-1.793 1.793a.5.5 0 0 1-.707 0L2 8.5V13.5a.5.5 0 0 0 .5.5h11a.5.5 0 0 0 .5-.5V8.5z"/></svg></button>
            </div>
            <div class="border-l border-slate-600 h-6"></div>

            <!-- Grupo: Creación -->
            <div class="flex items-center space-x-1">
                 <div class="dropdown">
                   <button class="toolbox-icon p-2 rounded-md font-medium text-sm">Añadir</button>
                   <div class="dropdown-content">
                     <button id="tool-copy"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-eyedropper" viewBox="0 0 16 16"><path d="M13.354.646a1.207 1.207 0 0 0-1.708 0L8.5 3.793l-.646-.647a.5.5 0 1 0-.708.708L8.293 5l-7.147 7.146A.5.5 0 0 0 1 12.5v1.793l-.854.853a.5.5 0 1 0 .708.707L1.707 15H3.5a.5.5 0 0 0 .354-.146L11 7.707l1.146 1.147a.5.5 0 0 0 .708-.708l-.647-.646 3.147-3.146a1.207 1.207 0 0 0 0-1.708l-2-2zM2 12.707l7-7L10.293 7l-7 7H2v-1.293z"/></svg> Copiar Propiedades</button>
                     <button id="tool-add-element"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M8 4a.5.5 0 0 1 .5.5v3h3a.5.5 0 0 1 0 1h-3v3a.5.5 0 0 1-1 0v-3h-3a.5.5 0 0 1 0-1h3v-3A.5.5 0 0 1 8 4z"/></svg>Elemento</button>
                     <button id="tool-text"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M4.406 5.586V4h7.188v1.586h-2.184v6.626h-2.82V5.586H4.406zM3.337 3h9.326v2.324h-1.333V4.04H8.723v8.92h1.244v1.28H6.035v-1.28h1.244V4.04H5.903v1.284H4.57V3h-.634-.6z"/></svg> Texto</button>
                     <button id="tool-add-ground"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M1 1.5a.5.5 0 0 1 .5-.5h13a.5.5 0 0 1 0 1h-13a.5.5 0 0 1-.5-.5zM1.5 4a.5.5 0 0 0 0 1h13a.5.5 0 0 0 0-1h-13zM1.5 6.5a.5.5 0 0 0 0 1h13a.5.5 0 0 0 0-1h-13zM8 8.75a.5.5 0 0 1 .5.5v3.25a.5.5 0 0 1-1 0V9.25a.5.5 0 0 1 .5-.5z"/></svg>Tierra</button>
                     <button id="tool-add-workzone"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M8 15A7 7 0 1 1 8 1a7 7 0 0 1 0 14zm0 1A8 8 0 1 0 8 0a8 8 0 0 0 0 16z"/><path d="M11.5 8.5a.5.5 0 0 1 0-1h3a.5.5 0 0 1 0 1h-3zm-8 0a.5.5 0 0 1 0-1h3a.5.5 0 0 1 0 1h-3z"/></svg>Zona de Trabajo</button>
                     <button id="tool-add-protectedzone"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M5.072.56C6.157.265 7.31 0 8 0s1.843.265 2.928.56c1.11.3 2.229.655 2.887 1.177a5.015 5.015 0 0 1 1.946 2.424c.586 1.262.877 2.734.877 4.243s-.29 2.98-.877 4.243a5.015 5.015 0 0 1-1.946-2.424c-.658.522-1.777.877-2.887 1.177C9.843 15.735 8.69 16 8 16s-1.843-.265-2.928-.56c-1.11-.3-2.229-.655-2.887-1.177a5.015 5.015 0 0 1-1.946-2.424C.79 11.223.5 9.75.5 8.207s.29-2.98.877-4.243a5.015 5.015 0 0 1 1.946-2.424C3.984 1.215 5.103.86 6.213.56z"/></svg>Zona Protegida</button>
                   </div>
                 </div>
                 <div class="dropdown">
                   <button class="toolbox-icon p-2 rounded-md font-medium text-sm">Cables</button>
                   <div class="dropdown-content">
                     <button id="tool-dashed-line"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M2 8a.5.5 0 0 1 .5-.5h1a.5.5 0 0 1 0 1h-1a.5.5 0 0 1-.5-.5zm3.5 0a.5.5 0 0 1 .5-.5h1a.5.5 0 0 1 0 1h-1a.5.5 0 0 1-.5-.5zm3.5 0a.5.5 0 0 1 .5-.5h1a.5.5 0 0 1 0 1h-1a.5.5 0 0 1-.5-.5zm3.5 0a.5.5 0 0 1 .5-.5h1a.5.5 0 0 1 0 1h-1a.5.5 0 0 1-.5-.5z"/></svg>Línea Punteada</button>
                     <div class="border-t border-gray-200 my-1"></div>
                     <button id="tool-add-main-v-line"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16" transform="rotate(90)"><path fill-rule="evenodd" d="M2 8a.5.5 0 0 1 .5-.5h11a.5.5 0 0 1 0 1h-11A.5.5 0 0 1 2 8Z"/></svg>Añadir Cable Principal V</button>
                     <button id="tool-add-main-h-line"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M2 8a.5.5 0 0 1 .5-.5h11a.5.5 0 0 1 0 1h-11A.5.5 0 0 1 2 8Z"/></svg>Añadir Cable Principal H</button>
                   </div>
                 </div>
                 <div class="dropdown">
                   <button class="toolbox-icon p-2 rounded-md font-medium text-sm">Figuras</button>
                   <div class="dropdown-content">
                     <button id="tool-rect"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M14 1a1 1 0 0 1 1 1v12a1 1 0 0 1-1 1H2a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1h12zM2 0a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V2a2 2 0 0 0-2-2H2z"/></svg>Rectángulo</button>
                     <button id="tool-circle"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M8 15A7 7 0 1 1 8 1a7 7 0 0 1 0 14zm0 1A8 8 0 1 0 8 0a8 8 0 0 0 0 16z"/></svg>Círculo</button>
                     <button id="tool-ellipse"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M8 15A7 7 0 1 1 8 1a7 7 0 0 1 0 14zm0 1A8 8 0 1 0 8 0a8 8 0 0 0 0 16z"/></svg>Elipse</button>
                   </div>
                 </div>
            </div>

             <!-- Grupo: Acciones Peligrosas -->
             <div class="border-l border-slate-600 h-6"></div>
             <div class="flex items-center space-x-1">
                <button id="tool-clear" class="toolbox-icon p-2 rounded-md text-red-500 hover:bg-red-100 hover:text-red-600" title="Limpiar Croquis (Ctrl+Backspace)"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" viewBox="0 0 16 16"><path d="M5.5 5.5A.5.5 0 0 1 6 6v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5zm2.5 0a.5.5 0 0 1 .5.5v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5zm3 .5a.5.5 0 0 0-1 0v6a.5.5 0 0 0 1 0V6z"/><path fill-rule="evenodd" d="M14.5 3a1 1 0 0 1-1 1H13v9a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V4h-.5a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1H6a1 1 0 0 1 1-1h2a1 1 0 0 1 1 1h3.5a1 1 0 0 1 1 1v1zM4.118 4 4 4.059V13a1 1 0 0 0 1 1h6a1 1 0 0 0 1-1V4.059L11.882 4H4.118zM2.5 3V2h11v1h-11z"/></svg></button>
             </div>

             <div class="flex-grow"></div>
             <div id="status-bar" class="text-sm text-slate-400 text-right min-w-[200px]">Listo.</div>
        </div>

        <!-- Canvas -->
        <div class="flex-grow bg-white rounded-xl overflow-hidden relative shadow-inner border border-gray-200/80">
            <canvas id="main-canvas" tabindex="0"></canvas>
            
            <!-- Modals -->
            <div id="edit-modal" class="hidden absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 bg-white border border-gray-300 rounded-xl shadow-2xl p-6 z-50 w-80 max-h-[90vh] overflow-y-auto text-gray-800">
                <h3 class="text-lg font-bold mb-4" id="edit-modal-title">Editar Elemento</h3>
                <div class="space-y-4">
                    <div><label for="edit-modal-label" class="block text-sm font-medium text-gray-600">Etiqueta</label><input type="text" id="edit-modal-label" class="w-full bg-gray-100 border border-gray-300 rounded-lg p-2 mt-1 text-gray-900"></div>
                    <div id="edit-modal-state-options"></div>
                    <div id="edit-modal-symbol-options"></div>
                    <div id="edit-modal-rotation-options" class="hidden"></div>
                </div>
                <div class="mt-6 flex justify-end space-x-3"><button id="edit-modal-cancel" class="bg-gray-200 hover:bg-gray-300 text-gray-800 font-bold py-2 px-4 rounded-lg">Cancelar</button><button id="edit-modal-save" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-lg">Guardar</button></div>
            </div>

            <div id="add-modal" class="hidden absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 bg-white border border-gray-300 rounded-xl shadow-2xl p-6 z-50 w-96 text-gray-800">
                <h3 class="text-lg font-bold mb-4">Añadir Nuevo Elemento</h3>
                <div class="space-y-4">
                    <div><label for="add-modal-label" class="block text-sm font-medium text-gray-600">Etiqueta</label><input type="text" id="add-modal-label" class="w-full bg-gray-100 border border-gray-300 rounded-lg p-2 mt-1 text-gray-900"></div>
                    <div id="add-modal-common-options">
                        <div><span class="block text-sm font-medium text-gray-600">Estado</span><div class="flex items-center space-x-4 mt-1"><label><input type="radio" name="add-modal-state" value="closed" class="mr-1"> Cerrado</label><label><input type="radio" name="add-modal-state" value="open" class="mr-1"> Abierto</label></div></div>
                        <div>
                            <span class="block text-sm font-medium text-gray-600">Símbolo</span>
                            <div class="grid grid-cols-2 gap-2 mt-1">
                                <label><input type="radio" name="add-modal-symbol" value="CT" class="mr-1"> CT</label>
                                <label><input type="radio" name="add-modal-symbol" value="Seccionador" class="mr-1"> Seccionador</label>
                                <label><input type="radio" name="add-modal-symbol" value="Distribuidor" class="mr-1"> Distribuidor</label>
                                <label><input type="radio" name="add-modal-symbol" value="Seccionalizador" class="mr-1"> Seccionalizador</label>
                                <label><input type="radio" name="add-modal-symbol" value="SE" class="mr-1"> SE</label>
                                <label><input type="radio" name="add-modal-symbol" value="Autodesconector" class="mr-1"> Autodesconector</label>
                                <label><input type="radio" name="add-modal-symbol" value="Reconectador" class="mr-1"> Reconectador</label>
                                <label><input type="radio" name="add-modal-symbol" value="Seccionalizador Unipolar" class="mr-1"> Secc. Unipolar</label>
                            </div>
                        </div>
                    </div>
                    <div id="add-modal-distributor-options" class="hidden">
                         <div><label for="add-modal-num-outputs" class="block text-sm font-medium text-gray-600">Número de Salidas</label><input type="number" id="add-modal-num-outputs" min="1" value="4" class="w-full bg-gray-100 border border-gray-300 rounded-lg p-2 mt-1 text-gray-900"></div>
                    </div>
                </div>
                <div class="mt-6 flex justify-end space-x-3"><button id="add-modal-cancel" class="bg-gray-200 hover:bg-gray-300 text-gray-800 font-bold py-2 px-4 rounded-lg">Cancelar</button><button id="add-modal-save" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-lg">Añadir</button></div>
            </div>

            <div id="text-modal" class="hidden absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 bg-white border border-gray-300 rounded-xl shadow-2xl p-6 z-50 w-80 text-gray-800">
                <h3 class="text-lg font-bold mb-4">Añadir Texto</h3>
                <div class="space-y-4">
                    <div><label for="text-modal-input" class="block text-sm font-medium text-gray-600">Texto</label><input type="text" id="text-modal-input" class="w-full bg-gray-100 border border-gray-300 rounded-lg p-2 mt-1 text-gray-900"></div>
                </div>
                <div class="mt-6 flex justify-end space-x-3"><button id="text-modal-cancel" class="bg-gray-200 hover:bg-gray-300 text-gray-800 font-bold py-2 px-4 rounded-lg">Cancelar</button><button id="text-modal-save" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-lg">Añadir</button></div>
            </div>

            <div id="summary-modal" class="hidden absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 bg-white border border-gray-300 rounded-xl shadow-2xl p-6 z-50 w-96 max-h-[80vh] flex flex-col text-gray-800">
                <h3 class="text-lg font-bold mb-4 text-teal-600">Resumen y Selección de Afectados</h3>
                <div id="summary-content" class="space-y-2 text-gray-700 overflow-y-auto flex-grow p-1">
                </div>
                <div class="mt-6 flex justify-between">
                    <button id="summary-modal-save" class="bg-teal-600 hover:bg-teal-700 text-white font-bold py-2 px-4 rounded-lg">Guardar Resumen</button>
                    <button id="summary-modal-close" class="bg-gray-200 hover:bg-gray-300 text-gray-800 font-bold py-2 px-4 rounded-lg">Cerrar</button>
                </div>
            </div>

            <div id="select-main-line-modal" class="hidden absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 bg-white border border-gray-300 rounded-xl shadow-2xl p-6 z-50 w-96 text-gray-800">
                <h3 class="text-lg font-bold mb-4">Seleccionar Cable Principal</h3>
                <div id="main-line-options" class="space-y-2"></div>
                 <button id="select-main-line-cancel" class="mt-4 w-full bg-gray-200 hover:bg-gray-300 text-gray-800 font-bold py-2 px-4 rounded-lg">Cancelar</button>
            </div>
            
            <div id="copy-image-modal" class="hidden absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 bg-white border border-gray-300 rounded-xl shadow-2xl p-6 z-50 max-w-xl w-full text-gray-800">
                <h3 class="text-lg font-bold mb-4">Copiar Imagen del Croquis</h3>
                <p class="text-sm text-gray-600 mb-4">Haz clic derecho en la imagen y selecciona "Copiar imagen" para pegarla en otro programa.</p>
                <div class="bg-gray-100 p-2 rounded-lg border border-gray-200 max-h-[60vh] overflow-auto">
                    <img id="image-to-copy" src="" alt="Vista previa del croquis" class="mx-auto"/>
                </div>
                <div class="mt-6 flex justify-end">
                    <button id="copy-image-modal-close" class="bg-gray-200 hover:bg-gray-300 text-gray-800 font-bold py-2 px-4 rounded-lg">Cerrar</button>
                </div>
            </div>
        </div>
    </main>
    
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('main-canvas');
            let ctx = canvas.getContext('2d');
            const csvFileInput = document.getElementById('csv-file-input');
            const fileNameSpan = document.getElementById('file-name');
            const loadDataBtn = document.getElementById('load-data-btn');
            const searchInput = document.getElementById('search-input');
            const elementListContainer = document.getElementById('element-list');
            const statusBar = document.getElementById('status-bar');
            
            const editModal = document.getElementById('edit-modal');
            const addModal = document.getElementById('add-modal');
            const textModal = document.getElementById('text-modal');
            const summaryModal = document.getElementById('summary-modal');
            const selectMainLineModal = document.getElementById('select-main-line-modal');
            const copyImageModal = document.getElementById('copy-image-modal');

            const editModalTitle = document.getElementById('edit-modal-title');
            const editModalLabel = document.getElementById('edit-modal-label');
            const editModalSaveBtn = document.getElementById('edit-modal-save');
            const editModalCancelBtn = document.getElementById('edit-modal-cancel');
            const addModalLabel = document.getElementById('add-modal-label');
            const addModalSaveBtn = document.getElementById('add-modal-save');
            const addModalCancelBtn = document.getElementById('add-modal-cancel');
            const textModalInput = document.getElementById('text-modal-input');
            const textModalSaveBtn = document.getElementById('text-modal-save');
            const textModalCancelBtn = document.getElementById('text-modal-cancel');
            const summaryBtn = document.getElementById('summary-btn');
            const summaryContent = document.getElementById('summary-content');
            const summaryModalClose = document.getElementById('summary-modal-close');
            const summaryModalSave = document.getElementById('summary-modal-save');
            const selectMainLineOptions = document.getElementById('main-line-options');
            const selectMainLineCancelBtn = document.getElementById('select-main-line-cancel');
            const savedSketchesDropdown = document.getElementById('saved-sketches-dropdown');
            const imageToCopy = document.getElementById('image-to-copy');
            const copyImageModalCloseBtn = document.getElementById('copy-image-modal-close');


            const addModalSymbolRadios = document.querySelectorAll('input[name="add-modal-symbol"]');
            const addModalCommonOptions = document.getElementById('add-modal-common-options');
            const addModalDistributorOptions = document.getElementById('add-modal-distributor-options');
            const addModalNumOutputs = document.getElementById('add-modal-num-outputs');

            const editModalStateOptions = document.getElementById('edit-modal-state-options');
            const editModalSymbolOptions = document.getElementById('edit-modal-symbol-options');
            const editModalRotationOptions = document.getElementById('edit-modal-rotation-options');

            const toolbox = document.getElementById('toolbox');
            const undoBtn = document.getElementById('tool-undo');
            const redoBtn = document.getElementById('tool-redo');
            
            let rawData = [];
            let allParsedElements = new Map();
            let componentToParentMap = new Map();
            let elementsOnCanvas = [];
            let manualShapes = [];
            let mainLines = [];
            let savedSketches = [];
            let currentMainLineIndex = 0;
            let currentTool = 'select';
            let selectedObject = null;
            let sourceElementForCopy = null;
            let isDragging = false;
            let isDraggingText = false;
            let isResizing = null; // Can be 'start', 'end', or null
            let isDrawing = false;
            let isPanning = false;
            let dragStart = { x: 0, y: 0 };
            let panStart = { x: 0, y: 0 };
            let drawingStartPoint = {x: 0, y: 0};
            let textInsertPos = {x: 0, y: 0};
            let editingTextObject = null;
            let scaleFactor = 1;

            const snapThreshold = 15;
            let currentSnapPoint = null;

            let history = [];
            let redoStack = [];

            const CT_RHOMBUS_SIZE = 8;
            const CT_TRIANGLE_BASE_SIZE_MULTIPLIER = 4.5;
            const CT_SQUARE_PADDING = 2;
            const CT_TEXT_LABEL_OFFSET_SINGLE = 10;
            const FONT_HEIGHT_LABEL = 14;

            const DISTRIBUTOR_SIZE = 40;
            const OUTPUT_CIRCLE_RADIUS = 3;

            const SECCIONALIZADOR_SIZE = 30;
            const SECCIONALIZADOR_LINE_LENGTH = 15;
            const SECCIONALIZADOR_LINE_OFFSET = 5;

            function applyScale(value) {
                return value * scaleFactor;
            }

            function initializeMainLine() {
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;

                // Por defecto: línea vertical centrada
                mainLines = [{
                    id: Date.now(),
                    x1: centerX,
                    y1: centerY - 180,   // largo hacia arriba
                    x2: centerX,
                    y2: centerY + 180,   // largo hacia abajo
                    orientation: 'vertical'
                }];
                currentMainLineIndex = 0;
            }

            function resizeCanvas() {
                const parent = canvas.parentElement;
                canvas.width = parent.clientWidth;
                canvas.height = parent.clientHeight;
                if(mainLines.length === 0) {
                    initializeMainLine();
                }
                redrawAll();
            }

            function parseData(text) {
                if (!text) { 
                    if(statusBar) statusBar.textContent = 'Error: El archivo CSV está vacío.'; 
                    return; 
                }
                rawData = text.trim().split('\n').map(line => {
                    const parts = line.split(',');
                    if (parts.length < 2) return null;
                    const drawableItems = parts[1].split('|').filter(Boolean);
                    return { fullLine: line, id: parts[0], drawables: drawableItems, identifier: parts[parts.length - 2] };
                }).filter(Boolean);

                allParsedElements.clear();
                componentToParentMap.clear();
                const allDrawableItems = new Set();
                
                rawData.forEach(row => {
                    row.drawables.forEach(item => allDrawableItems.add(item));
                    if (/^\d+C$/i.test(row.identifier)) {
                        if (!allParsedElements.has(row.identifier)) {
                            allParsedElements.set(row.identifier, { type: 'CT' });
                        }
                        const numPart = row.identifier.replace(/C$/i, '');
                        row.drawables.forEach(item => {
                            if (/^\d+-\d+$/.test(item) && item.startsWith(numPart)) {
                                componentToParentMap.set(item, row.identifier);
                            }
                        });
                    }
                });
                
                allDrawableItems.forEach(item => {
                    if (!/^\d+-\d+$/.test(item) && !allParsedElements.has(item)) {
                        allParsedElements.set(item, { type: 'Seccionador' });
                    }
                });

                updateElementList();
                if(statusBar) statusBar.textContent = `Datos cargados. ${allParsedElements.size} elementos únicos encontrados.`;
            }

            function updateElementList(filter = '') {
                elementListContainer.innerHTML = '';
                const filtered = Array.from(allParsedElements.entries()).filter(([name]) => name.toLowerCase().includes(filter.toLowerCase()));
                if (filtered.length === 0) { elementListContainer.innerHTML = `<p class="text-gray-500 text-center p-4">No se encontraron elementos.</p>`; return; }
                filtered.sort((a,b) => a[0].localeCompare(b[0])).forEach(([name, data]) => {
                    const div = document.createElement('div');
                    div.className = 'list-item flex justify-between items-center p-2 rounded-lg cursor-pointer transition-colors';
                    const textSpan = document.createElement('span'); textSpan.textContent = name; textSpan.className = 'text-sm';
                    const typeBadge = document.createElement('span'); typeBadge.textContent = data.type;
                    typeBadge.className = `text-xs px-2 py-1 rounded-full text-white ${data.type === 'CT' ? 'bg-green-500' : 'bg-blue-500'}`;
                    div.appendChild(textSpan); div.appendChild(typeBadge);
                    div.addEventListener('click', () => {
                        if (mainLines.length > 1) {
                            openSelectMainLineModal(name, data.type);
                        } else {
                            plotElement(name, data.type, 0);
                        }
                    });
                    elementListContainer.appendChild(div);
                });
            }

            function openSelectMainLineModal(name, type) {
                if(!selectMainLineOptions || !selectMainLineModal) return;
                selectMainLineOptions.innerHTML = '';
                mainLines.forEach((line, index) => {
                    const button = document.createElement('button');
                    button.textContent = `Dibujar en Cable ${index + 1}`;
                    button.className = 'w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg transition-colors';
                    button.onclick = () => {
                        plotElement(name, type, index);
                        selectMainLineModal.classList.add('hidden');
                    };
                    selectMainLineOptions.appendChild(button);
                });
                selectMainLineModal.classList.remove('hidden');
            };

            if(selectMainLineCancelBtn) {
                selectMainLineCancelBtn.addEventListener('click', () => {
                    if(selectMainLineModal) selectMainLineModal.classList.add('hidden');
                });
            }


            function plotElement(name, type, mainLineIndex) {
                if(statusBar) statusBar.textContent = `Dibujando '${name}' en Cable ${mainLineIndex + 1}...`;
                let elementsToPlotNames = new Set();
                const activeMainLine = mainLines[mainLineIndex];

                const oldElementIdsOnThisLine = new Set(elementsOnCanvas.filter(el => el.mainLineId === activeMainLine.id).map(el => el.id));
                elementsOnCanvas = elementsOnCanvas.filter(el => el.mainLineId !== activeMainLine.id);
                manualShapes = manualShapes.filter(shape => !shape.attachedTo || !oldElementIdsOnThisLine.has(shape.attachedTo));

                if (type === 'CT') {
                    const row = rawData.find(r => r.identifier === name);
                    if (row) { row.drawables.forEach(item => elementsToPlotNames.add(item)); }
                } else if (type === 'Seccionador') {
                    rawData.forEach(row => { if (row.drawables.includes(name)) { row.drawables.forEach(item => elementsToPlotNames.add(item)); } });
                }
                
                const finalPlotItems = new Map();
                elementsToPlotNames.forEach(itemName => {
                    const parentName = componentToParentMap.get(itemName);
                    if (parentName) {
                        finalPlotItems.set(parentName, {type: 'CT'});
                    } else if (!allParsedElements.has(itemName)) {
                        finalPlotItems.set(itemName, {type: 'CT'});
                    } else {
                        finalPlotItems.set(itemName, {type: allParsedElements.get(itemName).type });
                    }
                });
                
                let plotList = Array.from(finalPlotItems.entries()).map(([name, data]) => ({ name, ...data }));
                
                let side = 1;
                plotList.forEach((el, i) => {
                    let xPos, yPos;
                    if (activeMainLine.orientation === 'vertical') {
                        xPos = activeMainLine.x1 + (100 * side);
                        yPos = activeMainLine.y1 + ((activeMainLine.y2 - activeMainLine.y1) / (plotList.length + 1)) * (i + 1);
                    } else {
                        xPos = activeMainLine.x1 + ((activeMainLine.x2 - activeMainLine.x1) / (plotList.length + 1)) * (i + 1);
                        yPos = activeMainLine.y1 + (100 * side);
                    }

                    let newEl = {
                        id: Date.now() + Math.random(),
                        label: el.name,
                        type: el.type,
                        x: xPos,
                        y: yPos,
                        state: 'closed',
                        rhombusStates: ['closed', 'closed'], // ADDED: Default states for CT rhombuses
                        textOffsetX: 0,
                        textOffsetY: 0,
                        mainLineId: activeMainLine.id,
                        visuals: {}
                    };
                    elementsOnCanvas.push(newEl);

                    if (el.type === 'Seccionador') {
                        const defaultDashedLineLength = 75;
                        const direction = activeMainLine.orientation === 'vertical' ? (newEl.x > activeMainLine.x1 ? 1 : -1) : (newEl.y > activeMainLine.y1 ? 1 : -1);
                        if(activeMainLine.orientation === 'vertical') {
                            manualShapes.push({
                                id: Date.now() + Math.random(),
                                type: 'dashed-line',
                                attachedTo: newEl.id,
                                x1: newEl.x, y1: newEl.y,
                                x2: newEl.x + (defaultDashedLineLength * direction), y2: newEl.y
                            });
                        } else {
                             manualShapes.push({
                                id: Date.now() + Math.random(),
                                type: 'dashed-line',
                                attachedTo: newEl.id,
                                x1: newEl.x, y1: newEl.y,
                                x2: newEl.x, y2: newEl.y + (defaultDashedLineLength * direction)
                            });
                        }
                    }
                    side *= -1;
                });

                redrawAll();
                saveState();
            }

            function findClosestConnectionPoint(element) {
                if(element.type === 'Distribuidor' || element.type === 'WorkZone' || element.type === 'ProtectedZone') return null;
                let closest = { dist: Infinity, point: null, line: null, clampedT: 0 };
                const checkLine = (line) => {
                    const { x1, y1, x2, y2 } = line; const px = element.x; const py = element.y;
                    const dx = x2 - x1; const dy = y2 - y1;
                    if (dx === 0 && dy === 0) return;
                    const t = ((px - x1) * dx + (py - y1) * dy) / (dx * dx + dy * dy);
                    const clampedT = Math.max(0, Math.min(1, t));
                    const closestX = x1 + clampedT * dx; const closestY = y1 + clampedT * dy;
                    const dist = Math.hypot(px - closestX, py - closestY);
                    if (dist < closest.dist) {
                        closest.dist = dist;
                        closest.point = { x: closestX, y: closestY };
                        closest.line = line;
                        closest.clampedT = clampedT;
                    }
                };
                mainLines.forEach(checkLine);
                manualShapes.filter(s => s.style === 'cable').forEach(checkLine);
                return (closest.dist < 150) ? closest : null;
            }

            function redrawAll() {
                ctx.fillStyle = '#F9FAFB'; // bg-gray-50
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.save();
                ctx.scale(scaleFactor, scaleFactor);

                mainLines.forEach(line => {
                    ctx.beginPath();
                    ctx.moveTo(line.x1, line.y1);
                    ctx.lineTo(line.x2, line.y2);
                    ctx.strokeStyle = '#9CA3AF'; // gray-400
                    ctx.lineWidth = 2 / scaleFactor;
                    ctx.stroke();
                });
                
                elementsOnCanvas.forEach(el => {
                    const connection = findClosestConnectionPoint(el);
                    
                    if (el.type === 'CT') { drawCT(ctx, el, connection); }
                    else if (el.type === 'Seccionador') { drawSeccionador(ctx, el, connection); }
                    else if (el.type === 'Tierra') { drawGround(ctx, el, connection); }
                    else if (el.type === 'Distribuidor') { drawDistributor(ctx, el); }
                    else if (el.type === 'Seccionalizador') { drawSeccionalizador(ctx, el, connection); }
                    else if (el.type === 'WorkZone') { drawWorkZone(ctx, el); }
                    else if (el.type === 'ProtectedZone') { drawProtectedZone(ctx, el); }
                    else if (el.type === 'SE') { drawSE(ctx, el, connection); }
                    else if (el.type === 'Autodesconector') { drawAutodesconector(ctx, el, connection); }
                    else if (el.type === 'Reconectador') { drawReconectador(ctx, el, connection); }
                    else if (el.type === 'Seccionalizador Unipolar') { drawSeccionalizadorUnipolar(ctx, el, connection); }
                });

                manualShapes.forEach(shape => {
                    ctx.fillStyle = 'rgba(0,0,0,0.1)';
                    if (shape.style === 'cable') {
                        ctx.strokeStyle = '#9CA3AF'; // gray-400
                        ctx.lineWidth = 2 / scaleFactor;
                        ctx.setLineDash([]);
                    } else if (shape.type === 'dashed-line') {
                        ctx.strokeStyle = '#4B5563'; // gray-600
                        ctx.lineWidth = 2 / scaleFactor;
                        ctx.setLineDash([5 / scaleFactor, 5 / scaleFactor]);
                    } else {
                        ctx.strokeStyle = '#1F2937'; // gray-800
                        ctx.lineWidth = 2 / scaleFactor;
                        ctx.setLineDash([]);
                    }
                    
                    if(shape.type.includes('line')) {
                        ctx.beginPath(); ctx.moveTo(shape.x1, shape.y1); ctx.lineTo(shape.x2, shape.y2); ctx.stroke();
                    } else if (shape.type === 'rect') { ctx.strokeRect(shape.x, shape.y, shape.w, shape.h);
                    } else if (shape.type === 'circle' || shape.type === 'ellipse') { ctx.beginPath(); ctx.ellipse(shape.x, shape.y, shape.rx, shape.ry, 0, 0, 2 * Math.PI); ctx.stroke();
                    } else if (shape.type === 'text') { ctx.fillStyle = '#1F2937'; ctx.font = `${16 / scaleFactor}px Inter`; ctx.fillText(shape.content, shape.x, shape.y); }
                });
                ctx.setLineDash([]);
                
                if (currentSnapPoint) { drawSnapIndicator(ctx, currentSnapPoint); }

                if (selectedObject && !isDragging && !isDraggingText) {
                    ctx.strokeStyle = 'rgba(79, 70, 229, 0.8)'; ctx.lineWidth = 3 / scaleFactor;
                    const b = getObjectBounds(selectedObject.item, selectedObject.source);
                    ctx.strokeRect(b.x - 4, b.y - 4, b.w + 8, b.h + 8);

                    if (selectedObject.source === 'mainLines') {
                        const line = selectedObject.item;
                        const handleRadius = 8 / scaleFactor;
                        ctx.fillStyle = 'rgba(79, 70, 229, 1)';
                        ctx.beginPath();
                        ctx.arc(line.x1, line.y1, handleRadius, 0, 2 * Math.PI);
                        ctx.fill();
                        ctx.beginPath();
                        ctx.arc(line.x2, line.y2, handleRadius, 0, 2 * Math.PI);
                        ctx.fill();
                    }
                }
                ctx.restore();
            }
            
            function drawConnectionLine(ctx, connection, toX, toY) {
                if (connection) {
                    ctx.beginPath();
                    ctx.moveTo(connection.point.x, connection.point.y);
                    ctx.lineTo(toX, toY);
                    ctx.strokeStyle = '#9CA3AF'; // gray-400
                    ctx.lineWidth = 2 / scaleFactor;
                    ctx.stroke();
                }
            }

            function drawRhombus(ctx, x, y, size, isClosedState, rotation = 0) {
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(rotation);
                
                ctx.beginPath();
                // Draw rhombus centered at (0,0)
                ctx.moveTo(0, -size);
                ctx.lineTo(size, 0);
                ctx.lineTo(0, size);
                ctx.lineTo(-size, 0);
                ctx.closePath();
                
                ctx.fillStyle = isClosedState ? '#4ade80' : '#FFFFFF';
                ctx.strokeStyle = isClosedState ? '#15803d' : '#6B7280';
                ctx.lineWidth = 2 / scaleFactor;
                
                ctx.fill();
                ctx.stroke();
                
                ctx.restore();
            }

            function drawTriangleInSquare(ctx, x, y, size) {
                const height = (Math.sqrt(3) / 2) * size;
                const squareSide = Math.max(size, height);

                ctx.strokeStyle = '#1F2937';
                ctx.lineWidth = 2 / scaleFactor;
                ctx.strokeRect(x - squareSide / 2, y - squareSide / 2, squareSide, squareSide);

                ctx.beginPath();
                ctx.moveTo(x, y - height / 2);
                ctx.lineTo(x + size / 2, y + height / 2);
                ctx.lineTo(x - size / 2, y + height / 2);
                ctx.closePath();
                ctx.fillStyle = '#D1D5DB'; // Gray color for the triangle
                ctx.fill();
                ctx.stroke(); // Add stroke to the triangle
            }
            
            function drawGround(ctx, element, connection) {
                drawConnectionLine(ctx, connection, element.x, element.y);
                const x = element.x;
                const y = element.y;
                const rotation = element.rotation || 0;
                
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(rotation * Math.PI / 180);
                
                ctx.strokeStyle = '#1F2937';
                ctx.lineWidth = 2 / scaleFactor;
                ctx.beginPath();
                
                const stemLength = 25;
                const lineLength1 = 30;
                const lineLength2 = 20;
                const lineLength3 = 12;
                const spacing = 5;
                
                ctx.moveTo(0, 0);
                ctx.lineTo(0, stemLength);

                ctx.moveTo(-lineLength1 / 2, stemLength); ctx.lineTo(lineLength1 / 2, stemLength);
                ctx.moveTo(-lineLength2 / 2, stemLength + spacing); ctx.lineTo(lineLength2 / 2, stemLength + spacing);
                ctx.moveTo(-lineLength3 / 2, stemLength + spacing * 2); ctx.lineTo(lineLength3 / 2, stemLength + spacing * 2);
                
                ctx.stroke();
                ctx.restore();
            }

            function isOnMainLine(element) {
                const tolerance = 5; // A small tolerance to check if the point is on the line
                for (const line of mainLines) {
                    if (line.orientation === 'vertical') {
                        if (Math.abs(element.x - line.x1) < tolerance && element.y >= Math.min(line.y1, line.y2) && element.y <= Math.max(line.y1, line.y2)) {
                            return line;
                        }
                    } else { // Horizontal
                        if (Math.abs(element.y - line.y1) < tolerance && element.x >= Math.min(line.x1, line.x2) && element.x <= Math.max(line.x1, line.x2)) {
                            return line;
                        }
                    }
                }
                return null;
            }

            function drawCT(ctx, element, connection) {
                const rhombusSize = CT_RHOMBUS_SIZE;
                const triangleBaseSize = rhombusSize * CT_TRIANGLE_BASE_SIZE_MULTIPLIER;
                const squareSize = Math.max(triangleBaseSize, (Math.sqrt(3) / 2) * triangleBaseSize) + 2 * CT_SQUARE_PADDING;
                const halfSquare = squareSize / 2;

                const symbolX = element.x;
                const symbolY = element.y;
                
                drawTriangleInSquare(ctx, symbolX, symbolY, triangleBaseSize);

                const lineOn = isOnMainLine(element);
                const isClosed = element.state === 'closed';

                if (lineOn) {
                    const offset = halfSquare;
                    const isClosed1 = (element.rhombusStates && element.rhombusStates[0] === 'closed');
                    const isClosed2 = (element.rhombusStates && element.rhombusStates[1] === 'closed');

                    if (lineOn.orientation === 'vertical') {
                        drawRhombus(ctx, symbolX, symbolY - offset, rhombusSize, isClosed1, Math.PI / 2);
                        drawRhombus(ctx, symbolX, symbolY + offset, rhombusSize, isClosed2, Math.PI / 2);
                    } else {
                        drawRhombus(ctx, symbolX - offset, symbolY, rhombusSize, isClosed1, 0);
                        drawRhombus(ctx, symbolX + offset, symbolY, rhombusSize, isClosed2, 0);
                    }
                } else {
                    let rhombusX = symbolX;
                    let rhombusY = symbolY;
                    let rotation = 0;

                    if (connection) {
                        const { point } = connection;
                        const dx = symbolX - point.x;
                        const dy = symbolY - point.y;

                        if (Math.abs(dx) > Math.abs(dy)) { // More horizontal connection
                            rhombusY = symbolY;
                            rhombusX = dx > 0 ? symbolX - halfSquare : symbolX + halfSquare;
                            rotation = 0; 
                        } else { // More vertical connection
                            rhombusX = symbolX;
                            rhombusY = dy > 0 ? symbolY - halfSquare : symbolY + halfSquare;
                            rotation = Math.PI / 2; 
                        }
                        drawConnectionLine(ctx, connection, rhombusX, rhombusY);
                    } else {
                        // Default position for floating CT
                        rhombusX = symbolX - halfSquare;
                        rhombusY = symbolY;
                    }
                    
                    drawRhombus(ctx, rhombusX, rhombusY, rhombusSize, isClosed, rotation);
                }

                const textX = symbolX + (element.textOffsetX || 0);
                const textY = symbolY - halfSquare - 5 + (element.textOffsetY || 0);
                ctx.fillStyle = '#1F2937';
                ctx.font = `bold ${12/scaleFactor}px Inter`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'bottom';
                ctx.fillText(element.label, textX, textY);
            }

            function drawSeccionador(ctx, element, connection) {
                const rhombusSize = 14;
                let rotation = 0;
                const lineOn = isOnMainLine(element);

                if (lineOn) {
                    if (lineOn.orientation === 'horizontal') {
                        rotation = Math.PI / 2;
                    }
                } else if (connection) {
                    const dx = element.x - connection.point.x;
                    const dy = element.y - connection.point.y;
                    if (Math.abs(dx) > Math.abs(dy)) {
                        rotation = Math.PI / 2; // Horizontal connection
                    }
                }

                if (!lineOn) {
                    drawConnectionLine(ctx, connection, element.x, element.y);
                }
                
                drawRhombus(ctx, element.x, element.y, rhombusSize, element.state === 'closed', rotation);

                let textX = element.x + (element.textOffsetX || 0);
                let textY = element.y - rhombusSize - 5 + (element.textOffsetY || 0);
                
                ctx.fillStyle = '#1F2937';
                ctx.font = `bold ${12/scaleFactor}px Inter`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'bottom';
                ctx.fillText(element.label, textX, textY);
            }

            function drawDistributor(ctx, element) {
                const size = DISTRIBUTOR_SIZE;
                const halfSize = size / 2;
                const x = element.x;
                const y = element.y;
                const outputRadius = OUTPUT_CIRCLE_RADIUS;

                ctx.strokeStyle = '#1F2937';
                ctx.lineWidth = 2 / scaleFactor;
                ctx.strokeRect(x - halfSize, y - halfSize, size, size);

                ctx.beginPath();
                ctx.arc(x, y, halfSize / 1.5, 0, 2 * Math.PI);
                ctx.fillStyle = '#D1D5DB';
                ctx.fill();
                ctx.stroke();

                const numOutputs = element.numOutputs || 0;
                for (let i = 0; i < numOutputs; i++) {
                    const angle = (i / numOutputs) * 2 * Math.PI;
                    const distance = halfSize + outputRadius;
                    const ox = x + distance * Math.cos(angle);
                    const oy = y + distance * Math.sin(angle);
                    ctx.beginPath();
                    ctx.arc(ox, oy, outputRadius, 0, 2 * Math.PI);
                    ctx.fillStyle = element.outputStates[i] === 'open' ? '#FFFFFF' : '#4ade80';
                    ctx.strokeStyle = element.outputStates[i] === 'open' ? '#6B7280' : '#22c55e';
                    ctx.fill();
                    ctx.stroke();
                }
                
                const textX = x + (element.textOffsetX || 0);
                const textY = y - halfSize - 10 + (element.textOffsetY || 0);
                ctx.fillStyle = '#1F2937';
                ctx.font = `bold ${12/scaleFactor}px Inter`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'bottom';
                ctx.fillText(element.label, textX, textY);
            }

            function drawSeccionalizador(ctx, element, connection) {
                const r = 14;
                const isClosedState = element.state === 'closed';
                
                drawConnectionLine(ctx, connection, element.x, element.y);

                ctx.save();
                ctx.translate(element.x, element.y);
                ctx.rotate((element.rotation || 0) * Math.PI / 180);
                
                ctx.beginPath();
                ctx.moveTo(0, -r);
                ctx.lineTo(r, r);
                ctx.lineTo(-r, r);
                ctx.closePath();
                ctx.fillStyle = isClosedState ? '#4ade80' : '#FFFFFF';
                ctx.strokeStyle = isClosedState ? '#15803d' : '#6B7280';
                ctx.lineWidth = 2 / scaleFactor;
                ctx.fill();
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(-r, -r - 5);
                ctx.lineTo(r, -r - 5);
                ctx.stroke();
                
                ctx.restore();

                const textX = element.x + (element.textOffsetX || 0);
                const textY = element.y - r - 10 + (element.textOffsetY || 0);
                ctx.fillStyle = '#1F2937';
                ctx.font = `bold ${12/scaleFactor}px Inter`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'bottom';
                ctx.fillText(element.label, textX, textY);
            }

            function drawWorkZone(ctx, element) {
                const { x, y, radius, textOffsetX, textOffsetY } = element;

                ctx.beginPath();
                ctx.arc(x, y, radius, 0, 2 * Math.PI);
                ctx.strokeStyle = '#3b82f6';
                ctx.lineWidth = 2 / scaleFactor;
                ctx.stroke();

                const textX = x + (textOffsetX || 0);
                const textY = y - radius - 15 + (textOffsetY || 0);
                ctx.fillStyle = '#1F2937';
                ctx.font = `bold ${14/scaleFactor}px Inter`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'bottom';
                ctx.fillText('Zona de Trabajo', textX, textY);

                drawGround(ctx, {x: x - radius, y: y, rotation: 0 });
                drawGround(ctx, {x: x + radius, y: y, rotation: 0 });
            }

            function drawProtectedZone(ctx, element) {
                const { x, y, radius, textOffsetX, textOffsetY } = element;

                ctx.beginPath();
                ctx.arc(x, y, radius, 0, 2 * Math.PI);
                ctx.strokeStyle = '#f97316'; // orange-500
                ctx.lineWidth = 2 / scaleFactor;
                ctx.stroke();

                const textX = x + (textOffsetX || 0);
                const textY = y - radius - 15 + (textOffsetY || 0);
                ctx.fillStyle = '#1F2937';
                ctx.font = `bold ${14/scaleFactor}px Inter`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'bottom';
                ctx.fillText('Zona Protegida', textX, textY);

                drawGround(ctx, {x: x - radius, y: y, rotation: 0 });
                drawGround(ctx, {x: x + radius, y: y, rotation: 0 });
            }

            function drawSE(ctx, element, connection) {
                const size = 20;
                drawConnectionLine(ctx, connection, element.x, element.y);
                ctx.fillStyle = '#ef4444'; // red-500
                ctx.fillRect(element.x - size / 2, element.y - size / 2, size, size);

                const textX = element.x + (element.textOffsetX || 0);
                const textY = element.y - size / 2 - 5 + (element.textOffsetY || 0);
                ctx.fillStyle = '#1F2937';
                ctx.font = `bold ${12/scaleFactor}px Inter`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'bottom';
                ctx.fillText(element.label, textX, textY);
            }

            function drawAutodesconector(ctx, element, connection) {
                const r = 14;
                const isClosedState = element.state === 'closed';
                let rotation = 0;
                const lineOn = isOnMainLine(element);

                if (lineOn) {
                    if (lineOn.orientation === 'horizontal') {
                        rotation = Math.PI / 2;
                    }
                } else if (connection) {
                    const dx = element.x - connection.point.x;
                    const dy = element.y - connection.point.y;
                    if (Math.abs(dx) > Math.abs(dy)) {
                        rotation = Math.PI / 2; // Horizontal connection
                    }
                }

                if (!lineOn) {
                    drawConnectionLine(ctx, connection, element.x, element.y);
                }
                
                ctx.beginPath();
                ctx.arc(element.x, element.y, r, 0, 2 * Math.PI);
                ctx.fillStyle = isClosedState ? '#4ade80' : '#FFFFFF';
                ctx.strokeStyle = isClosedState ? '#15803d' : '#6B7280';
                ctx.lineWidth = 2 / scaleFactor;
                ctx.fill();
                ctx.stroke();
                
                drawRhombus(ctx, element.x, element.y, r, isClosedState, rotation);

                const textX = element.x + (element.textOffsetX || 0);
                const textY = element.y - r - 5 + (element.textOffsetY || 0);
                ctx.fillStyle = '#1F2937';
                ctx.font = `bold ${12/scaleFactor}px Inter`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'bottom';
                ctx.fillText(element.label, textX, textY);
            }

            function drawReconectador(ctx, element, connection) {
                const r = 14;
                const isClosedState = element.state === 'closed';
                const tBW = r * 1.2;
                const tH = r * 0.7;

                drawConnectionLine(ctx, connection, element.x, element.y);

                ctx.beginPath();
                ctx.arc(element.x, element.y, r, 0, 2 * Math.PI);
                ctx.fillStyle = isClosedState ? '#4ade80' : '#FFFFFF';
                ctx.strokeStyle = isClosedState ? '#15803d' : '#6B7280';
                ctx.lineWidth = 2 / scaleFactor;
                ctx.fill();
                ctx.stroke();
                
                ctx.fillStyle = isClosedState ? '#4ade80' : '#FFFFFF';
                ctx.strokeStyle = isClosedState ? '#15803d' : '#6B7280';

                ctx.beginPath();
                ctx.moveTo(element.x - tBW / 2, element.y - tH);
                ctx.lineTo(element.x + tBW / 2, element.y - tH);
                ctx.lineTo(element.x, element.y);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(element.x - tBW / 2, element.y + tH);
                ctx.lineTo(element.x + tBW / 2, element.y + tH);
                ctx.lineTo(element.x, element.y);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();

                const textX = element.x + (element.textOffsetX || 0);
                const textY = element.y - r - 5 + (element.textOffsetY || 0);
                ctx.fillStyle = '#1F2937';
                ctx.font = `bold ${12/scaleFactor}px Inter`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'bottom';
                ctx.fillText(element.label, textX, textY);
            }

            function drawSeccionalizadorUnipolar(ctx, element, connection) {
                const r = 14;
                const isClosedState = element.state === 'closed';
                const tS = 0.6;
                const bO = 0.1;

                drawConnectionLine(ctx, connection, element.x, element.y);

                ctx.beginPath();
                ctx.arc(element.x, element.y, r, 0, 2 * Math.PI);
                ctx.fillStyle = isClosedState ? '#4ade80' : '#FFFFFF';
                ctx.strokeStyle = isClosedState ? '#15803d' : '#6B7280';
                ctx.lineWidth = 2 / scaleFactor;
                ctx.fill();
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(element.x, element.y - r * tS);
                ctx.lineTo(element.x + r * tS, element.y + r * tS);
                ctx.lineTo(element.x - r * tS, element.y + r * tS);
                ctx.closePath();
                ctx.fillStyle = isClosedState ? '#4ade80' : '#FFFFFF';
                ctx.fill();
                ctx.stroke();
                
                ctx.beginPath();
                ctx.moveTo(element.x - r * tS, element.y - r * tS - (r * bO));
                ctx.lineTo(element.x + r * tS, element.y - r * tS - (r * bO));
                ctx.stroke();
                
                const textX = element.x + (element.textOffsetX || 0);
                const textY = element.y - r - 5 + (element.textOffsetY || 0);
                ctx.fillStyle = '#1F2937';
                ctx.font = `bold ${12/scaleFactor}px Inter`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'bottom';
                ctx.fillText(element.label, textX, textY);
            }
            
            function getObjectBounds(item, source) {
                if (!item) return {x:0, y:0, w:0, h:0};
                if (source === 'elementsOnCanvas') {
                    if (item.type === 'CT') {
                        const padding = 30; 
                        const squareSize = CT_RHOMBUS_SIZE * CT_TRIANGLE_BASE_SIZE_MULTIPLIER;
                        const w = squareSize + (CT_RHOMBUS_SIZE * 2) + padding;
                        const h = squareSize + padding;
                        return { x: item.x - w / 2, y: item.y - h / 2, w: w, h: h };
                    }
                    if (item.type === 'WorkZone' || item.type === 'ProtectedZone') {
                        const { x, y, radius } = item;
                        const groundWidth = 30;
                        const totalWidth = radius * 2 + groundWidth * 2 + 40;
                        const totalHeight = radius * 2 + 50;
                        return { x: item.x - totalWidth / 2, y: item.y - totalHeight / 2, w: totalWidth, h: totalHeight };
                    }
                    const padding = 20;
                    let w = 40 + padding, h = 40 + padding;
                     if (item.type === 'Seccionador') { w=80; h=80; }
                     if (item.type === 'Distribuidor' || item.type === 'Seccionalizador') { w=70; h=70;}
                    return { x: item.x - w/2, y: item.y - h/2, w: w, h: h };
                }
                if (source === 'manualShapes') {
                    if (item.type === 'text') {
                        const fontSize = 16; // As defined in redrawAll
                        ctx.font = `${fontSize / scaleFactor}px Inter`;
                        const textMetrics = ctx.measureText(item.content);
                        return { x: item.x, y: item.y - fontSize, w: textMetrics.width, h: fontSize };
                    }
                    if(item.type === 'ellipse' || item.type === 'circle') {
                        return { x: item.x - item.rx, y: item.y - item.ry, w: item.rx * 2, h: item.ry * 2 };
                    }
                    if(item.type === 'rect') {
                        return { x: item.x, y: item.y, w: item.w, h: item.h };
                    }
                    if(item.type.includes('line')) {
                        return { x: Math.min(item.x1, item.x2), y: Math.min(item.y1, item.y2), w: Math.abs(item.x1-item.x2), h: Math.abs(item.y1-item.y2)};
                    }
                }
                if (source === 'mainLines') {
                    return { x: Math.min(item.x1, item.x2), y: Math.min(item.y1, item.y2), w: Math.abs(item.x1-item.x2), h: Math.abs(item.y1-item.y2)};
                }
                return {x:0, y:0, w:0, h:0};
            }
            
            function getObjectAtPos(x, y) {
                const handleRadius = 10;

                for (let i = elementsOnCanvas.length - 1; i >= 0; i--) {
                    const item = elementsOnCanvas[i];
                    const b = getObjectBounds(item, 'elementsOnCanvas');
                    if (x >= b.x && x <= b.x + b.w && y >= b.y && y <= b.y + b.h) {
                        if (item.type === 'WorkZone' || item.type === 'ProtectedZone') {
                           const dist = Math.hypot(x - item.x, y - item.y);
                           if (Math.abs(dist - item.radius) < handleRadius) {
                                return { item, source: 'elementsOnCanvas', index: i, handle: 'resize' };
                           }
                        }
                        return { item, source: 'elementsOnCanvas', index: i };
                    }
                }
                 for (let i = manualShapes.length - 1; i >= 0; i--) {
                    const item = manualShapes[i]; const b = getObjectBounds(item, 'manualShapes');
                    const pad = item.type.includes('line') ? 5 : 0;
                    if (x >= b.x - pad && x <= b.x + b.w + pad && y >= b.y - pad && y <= b.y + b.h + pad) return { item, source: 'manualShapes', index: i };
                }
                for (let i = mainLines.length - 1; i >= 0; i--) {
                    const line = mainLines[i];
                    if (Math.hypot(x - line.x1, y - line.y1) < handleRadius) return {item: line, source: 'mainLines', index: i, handle: 'start'};
                    if (Math.hypot(x - line.x2, y - line.y2) < handleRadius) return {item: line, source: 'mainLines', index: i, handle: 'end'};
                    
                    const dist = Math.abs((line.y2-line.y1)*x - (line.x2-line.x1)*y + line.x2*line.y1 - line.y2*line.x1) / Math.sqrt(Math.pow(line.y2-line.y1, 2) + Math.pow(line.x2-line.x1, 2));
                    if(dist < 5) return {item: line, source: 'mainLines', index: i};
                }
                return null;
            }

            function getMousePos(e) {
                const rect = canvas.getBoundingClientRect();
                return {
                    x: (e.clientX - rect.left) / scaleFactor,
                    y: (e.clientY - rect.top) / scaleFactor
                };
            }
            
            function setActiveTool(tool) {
                currentTool = tool;
                document.querySelectorAll('.dropdown-content button, .toolbox-icon').forEach(b => b.classList.remove('active'));
                
                if (tool !== 'undo' && tool !== 'redo' && tool !== 'clear' && tool !== 'zoom-in' && tool !== 'zoom-out' && tool !== 'copy-image') {
                    const activeBtn = document.getElementById(`tool-${tool}`);
                    if (activeBtn) activeBtn.classList.add('active');
                } else {
                    document.getElementById('tool-select').classList.add('active');
                }
                canvas.style.cursor = tool.includes('line') || tool.includes('rect') || tool.includes('circle') || tool.includes('ellipse') ? 'crosshair' : 'default';
            }
            
            function findSnapPoint(x, y) {
                let closestPoint = null; let minDistance = snapThreshold;
                const checkPoint = (px, py) => {
                    const dist = Math.hypot(x - px, y - py);
                    if (dist < minDistance) { minDistance = dist; closestPoint = { x: px, y: py }; }
                };
                elementsOnCanvas.forEach(el => checkPoint(el.x, el.y));
                manualShapes.forEach(shape => { if (shape.type.includes('line')) { checkPoint(shape.x1, shape.y1); checkPoint(shape.x2, shape.y2); }});
                return closestPoint;
            }

            function drawSnapIndicator(ctx, point) {
                ctx.beginPath(); ctx.arc(point.x, point.y, snapThreshold / 2, 0, 2 * Math.PI);
                ctx.fillStyle = 'rgba(139, 92, 246, 0.5)'; ctx.fill();
            }

            function saveState() {
                const state = {
                    elements: JSON.parse(JSON.stringify(elementsOnCanvas)),
                    shapes: JSON.parse(JSON.stringify(manualShapes)),
                    mainLines: JSON.parse(JSON.stringify(mainLines)),
                    currentMainLineIndex: currentMainLineIndex
                };
                history.push(state);
                redoStack = [];
                updateUndoRedoButtons();
            }

            function updateUndoRedoButtons() {
                undoBtn.disabled = history.length <= 1;
                redoBtn.disabled = redoStack.length === 0;
            }

            function restoreState(state) {
                elementsOnCanvas = JSON.parse(JSON.stringify(state.elements));
                manualShapes = JSON.parse(JSON.stringify(state.shapes));
                mainLines = JSON.parse(JSON.stringify(state.mainLines));
                currentMainLineIndex = state.currentMainLineIndex;
                redrawAll();
                updateUndoRedoButtons();
            }

            function undo() {
                if (history.length <= 1) return;
                const currentState = history.pop();
                redoStack.push(currentState);
                const previousState = history[history.length - 1];
                restoreState(previousState);
            }

            function redo() {
                if (redoStack.length === 0) return;
                const nextState = redoStack.pop();
                history.push(nextState);
                restoreState(nextState);
            }

            canvas.addEventListener('mousedown', (e) => {
                const pos = getMousePos(e);
                let hitObject = getObjectAtPos(pos.x, pos.y);

                isDragging = false;
                isDraggingText = false;
                isResizing = null;
                isDrawing = false;
                isPanning = false;

                if (hitObject) {
                    selectedObject = hitObject;
                    if (hitObject.handle) {
                        isResizing = hitObject.handle;
                    } else if (currentTool === 'select') {
                        if (e.altKey && hitObject.source === 'elementsOnCanvas') {
                            isDraggingText = true;
                        } else {
                            isDragging = true;
                        }
                    }
                    dragStart = pos;
                } else {
                    selectedObject = null;
                    if (currentTool.includes('line') || currentTool === 'rect' || currentTool === 'circle' || currentTool === 'ellipse') {
                        isDrawing = true;
                        drawingStartPoint = findSnapPoint(pos.x, pos.y) || pos;
                    } else {
                        isPanning = true;
                        panStart = pos;
                        canvas.style.cursor = 'grabbing';
                    }
                }
                canvas.focus();
                redrawAll();
            });

            canvas.addEventListener('mousemove', (e) => {
                const pos = getMousePos(e);
                
                if (isPanning) {
                    const deltaX = pos.x - panStart.x;
                    const deltaY = pos.y - panStart.y;
                    elementsOnCanvas.forEach(el => { el.x += deltaX; el.y += deltaY; });
                    manualShapes.forEach(shape => {
                        if(shape.type.includes('line')) {
                            shape.x1 += deltaX; shape.y1 += deltaY;
                            shape.x2 += deltaX; shape.y2 += deltaY;
                        } else {
                            shape.x += deltaX; shape.y += deltaY;
                        }
                    });
                    mainLines.forEach(line => {
                        line.x1 += deltaX; line.y1 += deltaY;
                        line.x2 += deltaX; line.y2 += deltaY;
                    });
                    panStart = pos;
                } else if (isResizing && selectedObject) {
                    const item = selectedObject.item;
                    if (selectedObject.source === 'mainLines') {
                        if (isResizing === 'start') {
                            item.x1 = pos.x;
                            item.y1 = pos.y;
                        } else { // 'end' handle
                            item.x2 = pos.x;
                            item.y2 = pos.y;
                        }
                    } else if (selectedObject.source === 'elementsOnCanvas' && (item.type === 'WorkZone' || item.type === 'ProtectedZone') && isResizing === 'resize') {
                        item.radius = Math.hypot(pos.x - item.x, pos.y - item.y);
                    }
                    redrawAll();
                } else if (isDraggingText && selectedObject) {
                    const deltaX = pos.x - dragStart.x;
                    const deltaY = pos.y - dragStart.y;
                    const item = selectedObject.item;
                    item.textOffsetX = (item.textOffsetX || 0) + deltaX;
                    item.textOffsetY = (item.textOffsetY || 0) + deltaY;
                    dragStart = pos;
                } else if (isDragging && selectedObject) {
                    const deltaX = pos.x - dragStart.x;
                    const deltaY = pos.y - dragStart.y;
                    const item = selectedObject.item;
                    if(selectedObject.source === 'manualShapes' && item.type === 'text') {
                        item.x += deltaX;
                        item.y += deltaY;
                    }
                    else if (item.type && item.type.includes('line')) {
                        item.x1 += deltaX; item.y1 += deltaY; item.x2 += deltaX; item.y2 += deltaY;
                    } else if (selectedObject.source === 'mainLines') {
                        item.x1 += deltaX; item.y1 += deltaY;
                        item.x2 += deltaX; item.y2 += deltaY;
                    } else { item.x += deltaX; item.y += deltaY; }
                    
                    if (selectedObject.source === 'elementsOnCanvas' && (item.type === 'Seccionador')) {
                        const activeMainLine = mainLines.find(line => line.id === item.mainLineId);
                        if (activeMainLine) {
                            manualShapes.forEach(shape => {
                                if(shape.attachedTo === item.id) {
                                    const lineLength = 75;
                                    const direction = activeMainLine.orientation === 'vertical' ? (item.x > activeMainLine.x1 ? 1 : -1) : (item.y > activeMainLine.y1 ? 1 : -1);
                                    shape.x1 = item.x;
                                    shape.y1 = item.y;
                                    if(activeMainLine.orientation === 'vertical') {
                                        shape.x2 = item.x + (lineLength * direction);
                                        shape.y2 = item.y;
                                    } else {
                                        shape.x2 = item.x;
                                        shape.y2 = item.y + (lineLength * direction);
                                    }
                                }
                            });
                        }
                    }
                    dragStart = pos;
                }
                
                currentSnapPoint = findSnapPoint(pos.x, pos.y);
                redrawAll();
                if(isDrawing) drawGhostShape(ctx, pos);
            });
            
            canvas.addEventListener('mouseup', (e) => {
                if (isPanning || isDragging || isDraggingText || isResizing) {
                    saveState();
                }
                isPanning = false;
                isDragging = false;
                isDraggingText = false;
                isResizing = null;
                canvas.style.cursor = 'default';

                const pos = getMousePos(e);
                currentSnapPoint = findSnapPoint(pos.x, pos.y);
                if (isDrawing) {
                    createManualShape(currentSnapPoint || pos);
                    isDrawing = false;
                    setActiveTool('select');
                    saveState();
                }
                
                redrawAll();
            });

            canvas.addEventListener('dblclick', (e) => {
                const pos = getMousePos(e);
                const target = getObjectAtPos(pos.x, pos.y);
                if (target && target.source === 'elementsOnCanvas') {
                    openEditModal(target.item);
                } else if (target && target.source === 'mainLines') {
                    const line = target.item;
                    const centerX = (line.x1 + line.x2) / 2;
                    const centerY = (line.y1 + line.y2) / 2;
                    const halfLength = Math.hypot(line.x2 - line.x1, line.y2 - line.y1) / 2;

                    if (line.orientation === 'vertical') {
                        line.x1 = centerX - halfLength;
                        line.x2 = centerX + halfLength;
                        line.y1 = centerY;
                        line.y2 = centerY;
                        line.orientation = 'horizontal';
                    } else {
                        line.x1 = centerX;
                        line.x2 = centerX;
                        line.y1 = centerY - halfLength;
                        line.y2 = centerY + halfLength;
                        line.orientation = 'vertical';
                    }
                    redrawAll();
                    saveState();
                } else if (target && target.source === 'manualShapes' && target.item.type === 'text') {
                    openTextModal(pos, target.item);
                }
            });

            canvas.addEventListener('keydown', (e) => {
                if ((e.key === 'Delete' || e.key === 'Backspace') && !e.ctrlKey) {
                    e.preventDefault();
                    if(selectedObject){
                        const itemId = selectedObject.item.id;
                        if (selectedObject.source === 'elementsOnCanvas') {
                            elementsOnCanvas.splice(selectedObject.index, 1);
                            manualShapes = manualShapes.filter(shape => shape.attachedTo !== itemId);
                        } else if (selectedObject.source === 'manualShapes' || selectedObject.source === 'mainLines') {
                           if (selectedObject.source === 'mainLines' && mainLines.length === 1) {
                               if(statusBar) statusBar.textContent = "No se puede eliminar la última línea principal.";
                               return;
                           }
                           const collection = selectedObject.source === 'manualShapes' ? manualShapes : mainLines;
                           collection.splice(selectedObject.index, 1);
                        }
                        selectedObject = null;
                        redrawAll();
                        saveState();
                        if(statusBar) statusBar.textContent = "Objeto eliminado. Listo.";
                    }
                } else if (e.ctrlKey && (e.key === 'Backspace' || e.key === 'Delete')) {
                    e.preventDefault();
                    clearCanvas();
                }
                if (e.ctrlKey && e.key === 'z') { e.preventDefault(); undo(); }
                if (e.ctrlKey && e.key === 'y') { e.preventDefault(); redo(); }
            });
            
            function createManualShape(pos) {
                let shape = { type: currentTool, id: Date.now() };
                if (currentTool.includes('line')) {
                    shape.x1 = drawingStartPoint.x; shape.y1 = drawingStartPoint.y;
                    if (currentTool === 'dashed-line') {
                        const dx = Math.abs(pos.x - drawingStartPoint.x);
                        const dy = Math.abs(pos.y - drawingStartPoint.y);
                        if (dx > dy) { shape.x2 = pos.x; shape.y2 = drawingStartPoint.y;
                        } else { shape.x2 = drawingStartPoint.x; shape.y2 = pos.y; }
                        const seccionador = elementsOnCanvas.find(el => el.type === 'Seccionador' && Math.hypot(el.x - shape.x1, el.y - shape.y1) < snapThreshold);
                        if (seccionador) shape.attachedTo = seccionador.id;
                    } else if (currentTool === 'h-line') {
                        shape.x2 = pos.x; shape.y2 = drawingStartPoint.y;
                    } else if (currentTool === 'v-line') {
                        shape.x2 = drawingStartPoint.x; shape.y2 = pos.y;
                    } else {
                        shape.x2 = pos.x; shape.y2 = pos.y;
                    }
                    if(currentTool === 'h-line' || currentTool === 'v-line') {
                        shape.style = 'cable';
                    }
                } else if (currentTool === 'rect') {
                    shape.x = drawingStartPoint.x; shape.y = drawingStartPoint.y; shape.w = pos.x - drawingStartPoint.x; shape.h = pos.y - drawingStartPoint.y;
                } else if (currentTool === 'circle' || currentTool === 'ellipse') {
                    const rx = Math.abs((pos.x - drawingStartPoint.x) / 2); const ry = Math.abs((pos.y - drawingStartPoint.y) / 2);
                    const cx = drawingStartPoint.x + (pos.x - drawingStartPoint.x) / 2; const cy = drawingStartPoint.y + (pos.y - drawingStartPoint.y) / 2;
                    ctx.beginPath(); ctx.ellipse(cx, cy, rx, ry, 0, 0, 2 * Math.PI); ctx.stroke();
                }
                manualShapes.push(shape);
            }
            
            function drawGhostShape(ctx, pos) {
                const snapPos = currentSnapPoint || pos;
                ctx.strokeStyle = 'rgba(79, 70, 229, 0.5)'; ctx.lineWidth = 1;
                if (currentTool === 'dashed-line') { ctx.setLineDash([5, 5]);
                } else { ctx.setLineDash([]); }
                
                if (currentTool.includes('line')) {
                    let endX = snapPos.x, endY = snapPos.y;
                    if (currentTool === 'h-line') endY = drawingStartPoint.y;
                    if (currentTool === 'v-line') endX = drawingStartPoint.x;
                    if (currentTool === 'dashed-line') {
                        const dx = Math.abs(pos.x - drawingStartPoint.x);
                        const dy = Math.abs(pos.y - drawingStartPoint.y);
                        if(dx > dy) { endY = drawingStartPoint.y; }
                        else { endX = drawingStartPoint.x; }
                    }
                    ctx.beginPath(); ctx.moveTo(drawingStartPoint.x, drawingStartPoint.y); ctx.lineTo(endX, endY); ctx.stroke();
                } else if (currentTool === 'rect') {
                    ctx.strokeRect(drawingStartPoint.x, drawingStartPoint.y, snapPos.x - drawingStartPoint.x, snapPos.y - drawingStartPoint.y);
                } else if (currentTool === 'circle' || currentTool === 'ellipse') {
                    const rx = Math.abs((pos.x - drawingStartPoint.x) / 2); const ry = Math.abs((pos.y - drawingStartPoint.y) / 2);
                    const cx = drawingStartPoint.x + (pos.x - drawingStartPoint.x) / 2; const cy = drawingStartPoint.y + (pos.y - drawingStartPoint.y) / 2;
                    ctx.beginPath(); ctx.ellipse(cx, cy, rx, ry, 0, 0, 2 * Math.PI); ctx.stroke();
                }
                ctx.setLineDash([]);
            }
            
            addModalSymbolRadios.forEach(radio => {
                radio.addEventListener('change', () => {
                    if (radio.value === 'Distribuidor') {
                        addModalDistributorOptions.classList.remove('hidden');
                        addModalCommonOptions.classList.add('hidden');
                    } else {
                        addModalDistributorOptions.classList.add('hidden');
                        addModalCommonOptions.classList.remove('hidden');
                    }
                });
            });

            function openAddModal(sourceElement = null) {
                sourceElementForCopy = sourceElement;
                if (sourceElement) {
                    addModal.querySelector('h3').textContent = 'Copiar Elemento';
                    let newLabel = `${sourceElement.label}_copia`;
                    let counter = 1;
                    while (elementsOnCanvas.some(el => el.label === newLabel && el.type === sourceElement.type)) {
                        counter++;
                        newLabel = `${sourceElement.label}_copia_${counter}`;
                    }
                    addModalLabel.value = newLabel;
                    const symbolRadio = document.querySelector(`input[name="add-modal-symbol"][value="${sourceElement.type}"]`);
                    if (symbolRadio) symbolRadio.checked = true;
                    
                    if (sourceElement.type === 'Distribuidor') {
                        addModalDistributorOptions.classList.remove('hidden');
                        addModalCommonOptions.classList.add('hidden');
                        addModalNumOutputs.value = sourceElement.numOutputs || 4;
                    } else {
                        addModalDistributorOptions.classList.add('hidden');
                        addModalCommonOptions.classList.remove('hidden');
                        const stateRadio = document.querySelector(`input[name="add-modal-state"][value="${sourceElement.state || 'closed'}"]`);
                        if (stateRadio) stateRadio.checked = true;
                    }
                } else {
                    addModal.querySelector('h3').textContent = 'Añadir Nuevo Elemento';
                    addModalLabel.value = '';
                    addModalNumOutputs.value = 4;
                    document.querySelector('input[name="add-modal-state"][value="closed"]').checked = true;
                    document.querySelector('input[name="add-modal-symbol"][value="Seccionador"]').checked = true;
                    addModalDistributorOptions.classList.add('hidden');
                    addModalCommonOptions.classList.remove('hidden');
                }
                
                addModal.classList.remove('hidden');
                addModalLabel.focus();
            }
            function closeAddModal() {
                addModal.classList.add('hidden');
                sourceElementForCopy = null;
            }
            addModalSaveBtn.addEventListener('click', () => {
                const label = addModalLabel.value;
                if (!label) {
                    const messageBox = document.createElement('div');
                    messageBox.className = 'absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 bg-red-700 text-white p-4 rounded-md shadow-lg z-50';
                    messageBox.textContent = 'Por favor, ingrese un nombre para el elemento.';
                    document.body.appendChild(messageBox);
                    setTimeout(() => messageBox.remove(), 2000);
                    return;
                }
                const type = document.querySelector('input[name="add-modal-symbol"]:checked').value;
                if (elementsOnCanvas.some(el => el.label === label && el.type === type)) {
                    const messageBox = document.createElement('div');
                    messageBox.className = 'absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 bg-red-700 text-white p-4 rounded-md shadow-lg z-50';
                    messageBox.textContent = 'Ya existe un elemento con ese nombre y tipo.';
                    document.body.appendChild(messageBox);
                    setTimeout(() => messageBox.remove(), 2000);
                    return;
                }
                let newElement;
                if (type === 'Distribuidor') {
                    const numOutputs = parseInt(addModalNumOutputs.value);
                    if (isNaN(numOutputs) || numOutputs < 1) {
                         const messageBox = document.createElement('div');
                        messageBox.className = 'absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 bg-red-700 text-white p-4 rounded-md shadow-lg z-50';
                        messageBox.textContent = 'Por favor, ingrese un número válido de salidas (mínimo 1).';
                        document.body.appendChild(messageBox);
                        setTimeout(() => messageBox.remove(), 2000);
                        return;
                    }
                    newElement = {
                        id: Date.now(), label: label, type: type,
                        numOutputs: numOutputs, outputStates: Array(numOutputs).fill('closed'),
                        textOffsetX: 0, textOffsetY: 0, visuals: {}
                    };
                } else {
                    const state = document.querySelector('input[name="add-modal-state"]:checked').value;
                    newElement = {
                        id: Date.now(), label: label, type: type,
                        state: state, textOffsetX: 0, textOffsetY: 0, visuals: {}
                    };
                    if (type === 'CT') { // ADDED: Initialize rhombus states for new CTs
                        newElement.rhombusStates = ['closed', 'closed'];
                    }
                }

                if (sourceElementForCopy) {
                    newElement.x = sourceElementForCopy.x + 20;
                    newElement.y = sourceElementForCopy.y + 20;
                } else {
                    newElement.x = 100;
                    newElement.y = 100;
                }

                elementsOnCanvas.push(newElement);
                if (type === 'Seccionador') {
                    const activeMainLine = mainLines[currentMainLineIndex];
                    if (activeMainLine) {
                        const defaultDashedLineLength = 75;
                        const direction = activeMainLine.orientation === 'vertical' ? (newElement.x > activeMainLine.x1 ? 1 : -1) : (newElement.y > activeMainLine.y1 ? 1 : -1);
                        if(activeMainLine.orientation === 'vertical') {
                            manualShapes.push({
                                id: Date.now() + Math.random(),
                                type: 'dashed-line',
                                attachedTo: newElement.id,
                                x1: newElement.x, y1: newElement.y,
                                x2: newElement.x + (defaultDashedLineLength * direction), y2: newElement.y
                            });
                        } else {
                             manualShapes.push({
                                id: Date.now() + Math.random(),
                                type: 'dashed-line',
                                attachedTo: newElement.id,
                                x1: newElement.x, y1: newElement.y,
                                x2: newElement.x, y2: newElement.y + (defaultDashedLineLength * direction)
                            });
                        }
                    }
                }
                closeAddModal();
                redrawAll();
                saveState();
                setActiveTool('select');
            });
            addModalCancelBtn.addEventListener('click', closeAddModal);

            function openTextModal(pos, itemToEdit = null) {
                editingTextObject = itemToEdit;
                if (itemToEdit) {
                    textModal.querySelector('h3').textContent = 'Editar Texto';
                    textModalInput.value = itemToEdit.content;
                } else {
                    textModal.querySelector('h3').textContent = 'Añadir Texto';
                    textInsertPos = pos;
                    textModalInput.value = '';
                }
                textModal.classList.remove('hidden');
                textModalInput.focus();
            }
            function closeTextModal() { 
                editingTextObject = null;
                textModal.classList.add('hidden'); 
            }
            textModalSaveBtn.addEventListener('click', () => {
                const text = textModalInput.value;
                if (text) {
                    if (editingTextObject) {
                        editingTextObject.content = text;
                    } else {
                        manualShapes.push({ id:Date.now(), type: 'text', content: text, x: textInsertPos.x, y: textInsertPos.y });
                    }
                    redrawAll();
                    saveState();
                }
                closeTextModal();
                setActiveTool('select');
            });
            textModalCancelBtn.addEventListener('click', closeTextModal);
            
            function clearCanvas() {
                elementsOnCanvas = [];
                manualShapes = [];
                mainLines = [];
                history = [];
                redoStack = [];
                initializeMainLine();
                saveState();
                redrawAll();
                if(statusBar) statusBar.textContent = "Croquis limpiado.";
            }

            function showCopyImageModal() {
                if (elementsOnCanvas.length === 0 && manualShapes.length === 0 && mainLines.length === 0) {
                    if(statusBar) statusBar.textContent = "El croquis está vacío. No hay nada que copiar.";
                    return;
                }

                let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                const padding = 30;

                const collections = [elementsOnCanvas, manualShapes, mainLines];
                const sources = ['elementsOnCanvas', 'manualShapes', 'mainLines'];

                for(let i = 0; i < collections.length; i++) {
                    const collection = collections[i];
                    const source = sources[i];
                    collection.forEach(item => {
                        const bounds = getObjectBounds(item, source);
                        if(bounds.w === 0 && bounds.h === 0 && (item.type !== 'dashed-line' && item.type !== 'main-line')) return;
                        minX = Math.min(minX, bounds.x);
                        minY = Math.min(minY, bounds.y);
                        maxX = Math.max(maxX, bounds.x + bounds.w);
                        maxY = Math.max(maxY, bounds.y + bounds.h);
                    });
                }
                
                if (!isFinite(minX)) {
                    if(statusBar) statusBar.textContent = "No se pudo determinar el tamaño del croquis.";
                    return;
                }

                const canvasWidth = (maxX - minX) + padding * 2;
                const canvasHeight = (maxY - minY) + padding * 2;

                const offscreenCanvas = document.createElement('canvas');
                offscreenCanvas.width = canvasWidth;
                offscreenCanvas.height = canvasHeight;
                const offscreenCtx = offscreenCanvas.getContext('2d');

                offscreenCtx.fillStyle = '#ffffff';
                offscreenCtx.fillRect(0, 0, canvasWidth, canvasHeight);
                offscreenCtx.translate(-minX + padding, -minY + padding);
                
                const tempScale = scaleFactor;
                scaleFactor = 1;
                
                mainLines.forEach(line => {
                    offscreenCtx.beginPath(); offscreenCtx.moveTo(line.x1, line.y1); offscreenCtx.lineTo(line.x2, line.y2);
                    offscreenCtx.strokeStyle = '#9CA3AF'; offscreenCtx.lineWidth = 2; offscreenCtx.stroke();
                });
                
                elementsOnCanvas.forEach(el => {
                    const connection = findClosestConnectionPoint(el);
                    if (el.type === 'CT') { drawCT(offscreenCtx, el, connection); }
                    else if (el.type === 'Seccionador') { drawSeccionador(offscreenCtx, el, connection); }
                    else if (el.type === 'Tierra') { drawGround(offscreenCtx, el, connection); }
                    else if (el.type === 'Distribuidor') { drawDistributor(offscreenCtx, el); }
                    else if (el.type === 'Seccionalizador') { drawSeccionalizador(offscreenCtx, el, connection); }
                    else if (el.type === 'WorkZone') { drawWorkZone(offscreenCtx, el); }
                    else if (el.type === 'ProtectedZone') { drawProtectedZone(offscreenCtx, el); }
                    else if (el.type === 'SE') { drawSE(offscreenCtx, el, connection); }
                    else if (el.type === 'Autodesconector') { drawAutodesconector(offscreenCtx, el, connection); }
                    else if (el.type === 'Reconectador') { drawReconectador(offscreenCtx, el, connection); }
                    else if (el.type === 'Seccionalizador Unipolar') { drawSeccionalizadorUnipolar(offscreenCtx, el, connection); }
                });

                manualShapes.forEach(shape => {
                    if (shape.style === 'cable') {
                        offscreenCtx.strokeStyle = '#9CA3AF'; offscreenCtx.lineWidth = 2; offscreenCtx.setLineDash([]);
                    } else if (shape.type === 'dashed-line') {
                        offscreenCtx.strokeStyle = '#4B5563'; offscreenCtx.lineWidth = 2; offscreenCtx.setLineDash([5, 5]);
                    } else {
                        offscreenCtx.strokeStyle = '#1F2937'; offscreenCtx.lineWidth = 2; offscreenCtx.setLineDash([]);
                    }
                    
                    if(shape.type.includes('line')) {
                        offscreenCtx.beginPath(); offscreenCtx.moveTo(shape.x1, shape.y1); offscreenCtx.lineTo(shape.x2, shape.y2); offscreenCtx.stroke();
                    } else if (shape.type === 'rect') { offscreenCtx.strokeRect(shape.x, shape.y, shape.w, shape.h);
                    } else if (shape.type === 'circle' || shape.type === 'ellipse') { ctx.beginPath(); ctx.ellipse(shape.x, shape.y, shape.rx, shape.ry, 0, 0, 2 * Math.PI); ctx.stroke();
                    } else if (shape.type === 'text') { offscreenCtx.fillStyle = '#1F2937'; offscreenCtx.font = `bold 12px Inter`; offscreenCtx.fillText(shape.content, shape.x, shape.y); }
                });
                
                scaleFactor = tempScale;

                imageToCopy.src = offscreenCanvas.toDataURL('image/png');
                copyImageModal.classList.remove('hidden');
            }


            toolbox.addEventListener('click', (e) => {
                const btn = e.target.closest('button'); if (!btn) return; const toolId = btn.id;
                
                if (toolId === 'tool-undo') { undo(); return; }
                if (toolId === 'tool-redo') { redo(); return; }
                if (toolId === 'tool-clear') { clearCanvas(); return; }
                if (toolId === 'tool-save') {
                    const currentState = {
                        elements: JSON.parse(JSON.stringify(elementsOnCanvas)),
                        shapes: JSON.parse(JSON.stringify(manualShapes)),
                        mainLines: JSON.parse(JSON.stringify(mainLines)),
                        currentMainLineIndex: currentMainLineIndex
                    };
                    savedSketches.push(currentState);
                    updateSavedSketchesDropdown();
                    if(statusBar) statusBar.textContent = `Croquis ${savedSketches.length} guardado.`;
                    return;
                }
                 if (toolId === 'tool-copy-image') {
                    showCopyImageModal();
                    return;
                }
                
                setActiveTool(toolId.replace('tool-', ''));

                if(toolId === 'tool-add-main-v-line') {
                    const lastLine = mainLines.length > 0 ? mainLines[mainLines.length-1] : {x1: canvas.width/2 - 150, y1: 50, x2: canvas.width/2 - 150, y2: 650};
                    mainLines.push({ id: Date.now(), x1: lastLine.x1 + 150, y1: 50, x2: lastLine.x1 + 150, y2: 650, orientation: 'vertical', isManual: true });
                    redrawAll();
                    saveState();
                } else if (toolId === 'tool-add-main-h-line') {
                    const lastLine = mainLines.length > 0 ? mainLines[mainLines.length-1] : {x1: 50, y1: canvas.height/2 - 150, x2: 650, y2: canvas.height/2 - 150};
                    mainLines.push({ id: Date.now(), x1: 50, y1: lastLine.y1 + 150, x2: 650, y2: lastLine.y1 + 150, orientation: 'horizontal', isManual: true });
                    redrawAll();
                    saveState();
                }
                else if(toolId === 'tool-add-element') { openAddModal(); }
                else if(toolId === 'tool-add-workzone') {
                    elementsOnCanvas.push({ id: Date.now(), type: 'WorkZone', isManual: true, x: canvas.width / 2, y: canvas.height / 2, radius: 50, textOffsetX: 0, textOffsetY: 0 });
                    redrawAll();
                    saveState();
                    setActiveTool('select');
                }
                else if(toolId === 'tool-add-protectedzone') {
                    elementsOnCanvas.push({ id: Date.now(), type: 'ProtectedZone', isManual: true, x: canvas.width / 2, y: canvas.height / 2, radius: 60, textOffsetX: 0, textOffsetY: 0 });
                    redrawAll();
                    saveState();
                    setActiveTool('select');
                }
                else if (toolId === 'tool-add-ground') {
                    elementsOnCanvas.push({ id: Date.now(), label: '', type: 'Tierra', x: canvas.width - 100, y: 100, state: 'closed', rotation: 0, textOffsetX: 0, textOffsetY: 0, visuals: {} });
                    redrawAll();
                    saveState();
                    setActiveTool('select');
                }
                else if (toolId === 'tool-add-distributor') {
                    openAddModal();
                    if(document.querySelector('input[name="add-modal-symbol"][value="Distribuidor"]')) document.querySelector('input[name="add-modal-symbol"][value="Distribuidor"]').checked = true;
                    if(addModalDistributorOptions) addModalDistributorOptions.classList.remove('hidden');
                    if(addModalCommonOptions) addModalCommonOptions.classList.add('hidden');
                }
                else if (toolId === 'tool-add-seccionalizador') {
                    openAddModal();
                    if(document.querySelector('input[name="add-modal-symbol"][value="Seccionador"]')) document.querySelector('input[name="add-modal-symbol"][value="Seccionador"]').checked = true;
                    if(addModalDistributorOptions) addModalDistributorOptions.classList.add('hidden'); 
                    if(addModalCommonOptions) addModalCommonOptions.classList.remove('hidden');
                }
                else if (toolId === 'tool-text') {
                    if(canvas) canvas.style.cursor = 'text';
                }
            });
            canvas.addEventListener('click', (e) => {
                const pos = getMousePos(e);
                if(currentTool === 'text') {
                    openTextModal(getMousePos(e));
                } else if (currentTool === 'copy') {
                    const hitObject = getObjectAtPos(pos.x, pos.y);
                    if (hitObject && hitObject.source === 'elementsOnCanvas') {
                        openAddModal(hitObject.item);
                    } else {
                        if(statusBar) statusBar.textContent = 'Por favor, haga clic en un elemento válido para copiar.';
                    }
                    setActiveTool('select');
                }
            })

            function openEditModal(element) {
                selectedObject = {item: element, source: 'elementsOnCanvas', index: elementsOnCanvas.findIndex(el => el.id === element.id) };
                if(editModalTitle) editModalTitle.textContent = `Editar ${element.type}: ${element.label}`;
                if(editModalLabel) editModalLabel.value = element.label;
                
                if(editModalStateOptions) editModalStateOptions.innerHTML = '';
                if(editModalSymbolOptions) editModalSymbolOptions.innerHTML = '';
                if(editModalRotationOptions) {
                    editModalRotationOptions.innerHTML = '';
                    editModalRotationOptions.classList.add('hidden');
                }

                const lineOn = isOnMainLine(element);

                if (element.type === 'CT' && lineOn) {
                    editModalStateOptions.innerHTML = `
                        <div>
                            <span class="block text-sm font-medium text-gray-600">Estado Rombo 1 (Superior/Izquierdo)</span>
                            <div class="flex items-center space-x-4 mt-1">
                                <label><input type="radio" name="edit-modal-state-1" value="closed" class="mr-1"> Cerrado</label>
                                <label><input type="radio" name="edit-modal-state-1" value="open" class="mr-1"> Abierto</label>
                            </div>
                        </div>
                        <div>
                            <span class="block text-sm font-medium text-gray-600">Estado Rombo 2 (Inferior/Derecho)</span>
                            <div class="flex items-center space-x-4 mt-1">
                                <label><input type="radio" name="edit-modal-state-2" value="closed" class="mr-1"> Cerrado</label>
                                <label><input type="radio" name="edit-modal-state-2" value="open" class="mr-1"> Abierto</label>
                            </div>
                        </div>
                    `;
                    const state1 = (element.rhombusStates && element.rhombusStates[0]) || element.state;
                    const state2 = (element.rhombusStates && element.rhombusStates[1]) || element.state;
                    document.querySelector(`input[name="edit-modal-state-1"][value="${state1}"]`).checked = true;
                    document.querySelector(`input[name="edit-modal-state-2"][value="${state2}"]`).checked = true;
                } else if (element.type === 'Distribuidor') {
                    editModalStateOptions.innerHTML = `<span class="block text-sm font-medium text-gray-600">Estado de Salidas</span>`;
                    const grid = document.createElement('div');
                    grid.className = 'grid grid-cols-2 gap-2 mt-1';
                    for(let i = 0; i < element.numOutputs; i++) {
                        const label = document.createElement('label');
                        label.className = 'flex items-center space-x-2';
                        const checkbox = document.createElement('input');
                        checkbox.type = 'checkbox';
                        checkbox.dataset.index = i;
                        checkbox.checked = element.outputStates[i] === 'open';
                        label.appendChild(checkbox);
                        label.append(` Salida ${i + 1}`);
                        grid.appendChild(label);
                    }
                    editModalStateOptions.appendChild(grid);
                } else if (element.type === 'CT' || element.type === 'Seccionador' || element.type === 'Seccionalizador' || element.type === 'Autodesconector' || element.type === 'Reconectador' || element.type === 'Seccionalizador Unipolar') {
                    if(editModalStateOptions) {
                        editModalStateOptions.innerHTML = `
                            <span class="block text-sm font-medium text-gray-600">Estado</span>
                            <div class="flex items-center space-x-4 mt-1">
                                <label><input type="radio" name="edit-modal-state" value="closed" class="mr-1"> Cerrado</label>
                                <label><input type="radio" name="edit-modal-state" value="open" class="mr-1"> Abierto</label>
                            </div>
                        `;
                    }
                    const stateRadio = document.querySelector(`input[name="edit-modal-state"][value="${element.state}"]`);
                    if (stateRadio) {
                        stateRadio.checked = true;
                    }
                }

                if (element.type === 'Seccionalizador' || element.type === 'Tierra') {
                    if(editModalRotationOptions) {
                        editModalRotationOptions.classList.remove('hidden');
                        let options = '';
                        if (element.type === 'Tierra') {
                            for(let i = 0; i < 360; i += 45) {
                                options += `<option value="${i}">${i}°</option>`;
                            }
                        } else { // Seccionalizador
                            options = `
                                <option value="0">0°</option>
                                <option value="90">90°</option>
                                <option value="180">180°</option>
                                <option value="270">270°</option>
                            `;
                        }
                        editModalRotationOptions.innerHTML = `
                            <span class="block text-sm font-medium text-gray-600">Rotación</span>
                            <select id="edit-modal-rotation-select" class="w-full bg-gray-100 border border-gray-300 rounded-lg p-2 mt-1 text-gray-900">
                                ${options}
                            </select>
                        `;
                        document.getElementById('edit-modal-rotation-select').value = element.rotation || 0;
                    }
                }
                
                if(editModal) editModal.classList.remove('hidden');
            }
            function closeEditModal() { 
                if(editModal) editModal.classList.add('hidden'); 
                selectedObject = null; redrawAll();
            }
            
            if(editModalSaveBtn) {
                editModalSaveBtn.addEventListener('click', () => {
                    if(selectedObject && selectedObject.source === 'elementsOnCanvas') {
                        const item = selectedObject.item;
                        item.label = editModalLabel.value;
                        const lineOn = isOnMainLine(item);

                        if (item.type === 'CT' && lineOn) {
                            const state1Input = document.querySelector('input[name="edit-modal-state-1"]:checked');
                            const state2Input = document.querySelector('input[name="edit-modal-state-2"]:checked');
                            if (state1Input && state2Input) {
                                item.rhombusStates = [state1Input.value, state2Input.value];
                                item.state = (state1Input.value === 'open' && state2Input.value === 'open') ? 'open' : 'closed';
                            }
                        } else if (item.type === 'Distribuidor') {
                            const checkboxes = editModalStateOptions.querySelectorAll('input[type="checkbox"]');
                            checkboxes.forEach((checkbox, i) => {
                                item.outputStates[i] = checkbox.checked ? 'open' : 'closed';
                            });
                        } else {
                            const stateInput = document.querySelector('input[name="edit-modal-state"]:checked');
                            if (stateInput) {
                                item.state = stateInput.value;
                            }
                        }

                        const rotationSelect = document.getElementById('edit-modal-rotation-select');
                        if (rotationSelect) {
                            item.rotation = parseInt(rotationSelect.value);
                        }
                    }
                    closeEditModal();
                    saveState();
                });
            }

            if(editModalCancelBtn) {
                editModalCancelBtn.addEventListener('click', closeEditModal);
            }
            
            if(csvFileInput) {
                csvFileInput.addEventListener('change', () => {
                    const file = csvFileInput.files[0];
                    if (file) { if(fileNameSpan) fileNameSpan.textContent = file.name; if(fileNameSpan) fileNameSpan.classList.add('text-indigo-400'); }
                    else { if(fileNameSpan) fileNameSpan.textContent = 'Haz clic para seleccionar un archivo'; }
                });
            }

            if(loadDataBtn) {
                loadDataBtn.addEventListener('click', () => {
                    const file = csvFileInput.files[0];
                    if (file) { const reader = new FileReader(); reader.onload = (e) => parseData(e.target.result); reader.readAsText(file); }
                    else { if(statusBar) statusBar.textContent = 'Por favor, seleccione un archivo CSV primero.'; }
                });
            }
            
            if(summaryBtn) {
                summaryBtn.addEventListener('click', () => {
                    if(!summaryContent || !summaryModal) return;
                    summaryContent.innerHTML = `
                        <h4 class="font-bold text-lg text-yellow-500 mb-2">Marque los elementos afectados:</h4>
                        <div class="space-y-1">
                            ${elementsOnCanvas.filter(el => el.type === 'CT' || el.type === 'Seccionador' || el.type === 'Distribuidor' || el.type === 'Seccionalizador').map(el => `
                                <label class="flex items-center space-x-2 p-2 hover:bg-gray-100 rounded-lg cursor-pointer">
                                    <input type="checkbox" ${el.isAffected !== false ? 'checked' : ''} class="form-checkbox h-4 w-4 text-indigo-600 bg-gray-100 border-gray-300 rounded focus:ring-indigo-500" data-id="${el.id}">
                                    <span>${el.label} (${el.type}) - ${el.state || 'N/A'}</span>
                                </label>
                            `).join('')}
                        </div>
                    `;
                    summaryModal.classList.remove('hidden');
                });
            }

            if(summaryModalSave && summaryContent && summaryModal) {
                summaryModalSave.addEventListener('click', () => {
                    const affectedElementsLabels = [];
                    summaryContent.querySelectorAll('input[type="checkbox"]').forEach(checkbox => {
                        const elementId = parseFloat(checkbox.dataset.id);
                        const element = elementsOnCanvas.find(el => el.id === elementId);
                        if (element) {
                            element.isAffected = checkbox.checked;
                            if(element.isAffected) {
                                affectedElementsLabels.push(element.label);
                            }
                        }
                    });
                    console.log("Elementos afectados guardados:", affectedElementsLabels);
                    summaryModal.classList.add('hidden');
                });
            }

            if(summaryModalClose && summaryModal) {
                summaryModalClose.addEventListener('click', () => {
                    summaryModal.classList.add('hidden');
                });
            }
            
            if(searchInput) {
                searchInput.addEventListener('input', (e) => {
                    updateElementList(e.target.value);
                });
            }
            
            if(copyImageModalCloseBtn) {
                copyImageModalCloseBtn.addEventListener('click', () => {
                    copyImageModal.classList.add('hidden');
                });
            }
            
            function updateSavedSketchesDropdown() {
                if(!savedSketchesDropdown) return;
                savedSketchesDropdown.innerHTML = '';
                if (savedSketches.length === 0) {
                    savedSketchesDropdown.innerHTML = '<p class="p-3 text-gray-500 text-sm text-center">No hay croquis guardados.</p>';
                    return;
                }
                
                savedSketches.forEach((sketch, index) => {
                    const button = document.createElement('button');
                    button.className = 'w-full';
                    
                    const container = document.createElement('div');
                    container.className = 'flex items-center justify-between w-full';
                    
                    const loadText = document.createElement('span');
                    loadText.textContent = `Croquis ${index + 1}`;
                    loadText.onclick = () => {
                        restoreState(sketch);
                        saveState();
                        if(statusBar) statusBar.textContent = `Croquis ${index + 1} cargado.`;
                    };
                    
                    const deleteButton = document.createElement('span');
                    deleteButton.innerHTML = '&times;';
                    deleteButton.className = 'p-1 text-red-500 hover:text-red-400 font-bold text-xl leading-none cursor-pointer';
                    deleteButton.title = `Eliminar Croquis ${index + 1}`;
                    deleteButton.onclick = (e) => {
                        e.stopPropagation();
                        savedSketches.splice(index, 1);
                        updateSavedSketchesDropdown();
                    };
                    
                    container.appendChild(loadText);
                    container.appendChild(deleteButton);
                    button.appendChild(container);
                    savedSketchesDropdown.appendChild(button);
                });
            }

            // Manejador del evento wheel para hacer zoom
            canvas.addEventListener('wheel', (e) => {
                e.preventDefault();
                const scale = e.deltaY > 0 ? 0.9 : 1.1;
                scaleFactor *= scale;
                redrawAll();
            });

            window.addEventListener('resize', resizeCanvas);
            setActiveTool('select');
            resizeCanvas();
            saveState();
        });
    </script>
</body>
</html>