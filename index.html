<!DOCTYPE html>
<html lang="es">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>EsquemApp - Visualizador de Red</title>
	<script src="https://cdn.tailwindcss.com"></script>
	<script src="https://d3js.org/d3.v7.min.js"></script>
	<style>
		body {
			font-family: 'Inter', sans-serif;
			background-color: #f7fafc;
		}
		.link, .cable-line {
			fill: none;
			/* stroke is now set dynamically in JS */
			stroke-width: 1.5px;
		}
		.connection-line {
			fill: none;
			/* stroke is now set dynamically in JS */
			stroke-width: 1.5px;
		}
		.node .symbol, .custom-element-group .symbol, .connector-group .symbol {
			/* stroke is now set dynamically in JS */
			stroke-width: 1.5px;
		}
		.custom-element-group .symbol.star {
			stroke: #0ea5e9; /* Sky blue */
			fill: #e0f2fe;
		}

		.annotation {
			/* stroke is now set dynamically in JS */
			stroke-width: 1.5px;
		}
		.node.se-node .symbol {
			fill: #ef4444;
		}
		
		.node text, .custom-element-group text {
			font-size: 9px;
			font-family: 'Inter', sans-serif;
			fill: #1f2937;
			font-weight: 500;
			cursor: pointer;
			user-select: none;
		}
		
		.terminal-output-label {
			font-size: 8px;
			font-family: 'Inter', sans-serif;
			fill: #4b5563; /* Gray-600 */
			font-weight: 500;
			cursor: pointer;
			user-select: none;
		}

		.text-annotation {
			font-size: 9px;
			font-family: 'Inter', sans-serif;
			font-weight: 500;	
			/* fill is set dynamically */
			cursor: pointer;
			user-select: none;
			stroke: none;
		}
		.node.b-node text, .custom-element-group .custom-ct-text {
			fill: #800000; /* Burgundy */
			font-size: 18px;
		}

		#tooltip {
			position: absolute;
			text-align: center;
			padding: 8px;
			font: 12px sans-serif;
			background: rgba(0, 0, 0, 0.75);
			color: white;
			border-radius: 8px;
			pointer-events: none;
			opacity: 0;
			transition: opacity 0.2s;
		}
		.loader {
			border: 4px solid #f3f3f3;
			border-top: 4px solid #2563eb; /* Blue */
			border-radius: 50%;
			width: 40px;
			height: 40px;
			animation: spin 1s linear infinite;
		}
		@keyframes spin {
			0% { transform: rotate(0deg); }
			100% { transform: rotate(360deg); }
		}

		/* New Selection Style */
		.node.selected, .annotation-group.selected, .custom-element-group.selected, .link-visual.selected {
			filter: drop-shadow(0px 0px 4px rgba(37, 99, 235, 0.8)); /* Blue glow */
		}
		.node.selected .symbol, .node.selected > rect, .node.selected > circle, .node.selected > path,
		.annotation-group.selected .annotation,
		.custom-element-group.selected .symbol, .custom-element-group.selected > g > .symbol,
		.node.multi-selected .symbol, .node.multi-selected > rect, .node.multi-selected > circle, .node.multi-selected > path,
		.connector-group.connection-selected .symbol,
		.link-visual.selected {
			stroke-width: 2.5px !important;
		}


		.message-box {
			position: fixed;
			top: 50%;
			left: 50%;
			transform: translate(-50%, -50%);
			background-color: white;
			padding: 24px;
			border-radius: 12px;
			box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
			z-index: 1000;
			text-align: center;
			min-width: 320px;
		}
		.message-box button {
			margin-top: 15px;
			margin-left: 5px;
			margin-right: 5px;
			padding: 8px 15px;
			color: white;
			border: none;
			border-radius: 8px;
			cursor: pointer;
			transition: background-color: 0.2s;
		}
		.message-box .preset-btn,
		.message-box .adjust-btn {
			color: #374151;
			background-color: #f3f4f6;
			border: 1px solid #e5e7eb;
			font-weight: 600;
			padding: 8px 12px;
		}
		.message-box .preset-btn:hover,
		.message-box .adjust-btn:hover {
			background-color: #e5e7eb;
		}
		 .message-box .btn-confirm { background-color: #2563eb; } /* Blue */
		 .message-box .btn-confirm:hover { background-color: #1d4ed8; }
		 .message-box .btn-danger { background-color: #ef4444; }
		 .message-box .btn-danger:hover { background-color: #dc2626; }
		 .message-box .btn-cancel { background-color: #6b7280; }
		 .message-box .btn-cancel:hover { background-color: #4b5563; }

		 /* Warning button for dual confirm dialogs */
		 .message-box .btn-warning { background-color: #d97706; }
		 .message-box .btn-warning:hover { background-color: #b45309; }

		.connector-group {
			cursor: pointer;
			transition: all 0.2s ease-in-out;
		}
		.connector-group.manual-mode {
			cursor: move;
		}
		.connector-group:hover {
			filter: brightness(1.2);
		}
		.node, .custom-element-group {
			transition: filter 0.2s ease-in-out;
		}
		.node:hover, .custom-element-group:hover {
			filter: drop-shadow(0 4px 6px rgba(0,0,0,0.1));
		}
		#info-panel {
			transition: transform 0.3s ease-in-out;
		}
		.tool-btn.active {
			background-color: #10b981 !important; /* Green */
			color: white !important;
		}
		.selection-tool-btn {
            background-color: rgba(16, 185, 129, 0.1);
        }
        .selection-tool-btn:hover {
            background-color: rgba(16, 185, 129, 0.2);
        }
        .shape-tool-btn {
            background-color: rgba(59, 130, 246, 0.1); /* Blue */
        }
        .shape-tool-btn:hover {
            background-color: rgba(59, 130, 246, 0.2); /* Blue */
        }
        .ct-tool-btn {
             background-color: rgba(245, 158, 11, 0.1); /* Amber */
        }
        .ct-tool-btn:hover {
             background-color: rgba(245, 158, 11, 0.2);
        }
		#graph-svg.drawing-mode, #graph-svg.lasso-select-mode, #graph-svg.marquee-select-mode {
			cursor: crosshair;
		}
		.annotation-group, .custom-element-group {
			cursor: move;
		}
		.symbol-option {
			cursor: pointer;
			padding: 8px;
			border-radius: 6px;
			transition: background-color: 0.2s;
		}
		.symbol-option:hover {
			background-color: #f3f4f6;
		}
		.symbol-option.active {
			background-color: #d1fae5; /* Lightest Green */
			border: 1px solid #a7f3d0; /* Lighter Green */
		}
		details > summary {
			list-style: none;
			cursor: pointer;
		}
		details > summary::-webkit-details-marker {
			display: none;
		}
		details > summary::after {
			content: '▸';
			float: right;
			transition: transform 0.2s;
		}
		details[open] > summary::after {
			transform: rotate(90deg);
		}
		.resize-handle {
			fill: #10b981; /* Green */
			stroke: white;
			stroke-width: 1px;
			opacity: 0;
			pointer-events: none;
		}
		.annotation-group.selected .resize-handle {
			opacity: 1;
			pointer-events: all;
		}
		.lasso-path {
			fill: rgba(16, 185, 129, 0.1);
			stroke: #10b981;
			stroke-width: 1.5px;
			stroke-dasharray: 4 2;
		}
		.selection-marquee {
			fill: rgba(16, 185, 129, 0.1);
			stroke: #10b981;
			stroke-width: 1px;
			stroke-dasharray: 4 2;
		}
		#dxf-canvas {
			cursor: grab;
		}
		#help-content details > summary {
			list-style: none;
			cursor: pointer;
			transition: color 0.2s;
		}
		#help-content details > summary:hover {
			color: #2563eb;
		}
		#help-content details > summary::-webkit-details-marker {
			display: none;
		}
		#help-content details > summary::before {
			content: '▸';
			margin-right: 8px;
			display: inline-block;
			transition: transform 0.2s;
		}
		#help-content details[open] > summary::before {
			transform: rotate(90deg);
		}
		#help-content kbd {
			padding: 2px 6px;
			font-size: 0.8em;
			font-weight: 600;
			color: #374151; /* gray-700 */
			background-color: #f3f4f6; /* gray-100 */
			border: 1px solid #e5e7eb; /* gray-200 */
			border-radius: 4px;
		}
	</style>
	<link rel="preconnect" href="https://fonts.googleapis.com">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;700&display=swap" rel="stylesheet">
</head>
<body class="bg-gray-100 text-gray-800">

	<div id="tooltip"></div>
	<div id="message-box-container"></div>
	<div id="context-menu" class="absolute hidden bg-white border border-gray-300 rounded-md shadow-lg z-50">
		<ul class="py-1"></ul>
	</div>
	
	<div id="copy-image-modal" class="fixed inset-0 bg-black bg-opacity-50 hidden items-center justify-center z-50">
		<div class="bg-white p-6 rounded-lg shadow-xl max-w-5xl w-full">
			<div class="flex justify-between items-center mb-4">
				<h3 class="text-lg font-bold">Exportar Imagen del Diagrama</h3>
				<button id="close-modal-btn" class="text-gray-500 hover:text-gray-800 text-2xl leading-none">&times;</button>
			</div>
			<p class="text-sm text-gray-600 mb-4">Elige formato, resolución y fondo antes de copiar o descargar la vista actual.</p>
			<div class="grid md:grid-cols-3 gap-4">
				<div class="md:col-span-2 space-y-3">
					<div class="relative border rounded-md p-2 bg-gray-50 max-h-[60vh] overflow-auto flex items-center justify-center">
						<div id="export-preview-loading" class="absolute inset-0 bg-white bg-opacity-75 flex items-center justify-center rounded-md hidden">
							<div class="loader"></div>
						</div>
						<img id="image-to-copy" src="" alt="Vista previa del diagrama" class="max-w-full h-auto mx-auto rounded shadow-sm border border-gray-100">
					</div>
					<div class="flex items-center justify-between text-xs sm:text-sm text-gray-600">
						<span id="export-dimensions-label">Dimensiones: --</span>
						<span id="export-size-label" class="font-semibold text-gray-800">Tamaño: --</span>
					</div>
					<p id="clipboard-notice" class="text-xs text-yellow-700 bg-yellow-50 border border-yellow-200 rounded px-3 py-2 hidden">El navegador puede bloquear el acceso al portapapeles. Si ocurre, usa "Descargar" como alternativa.</p>
				</div>
				<div class="space-y-4">
					<div>
						<label for="export-format" class="block text-sm font-semibold text-gray-700 mb-1">Formato</label>
						<select id="export-format" class="w-full border rounded-md px-3 py-2 text-sm text-gray-700 focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
							<option value="png">PNG</option>
							<option value="svg">SVG</option>
						</select>
					</div>
					<div>
						<label for="export-resolution" class="block text-sm font-semibold text-gray-700 mb-1">Resolución</label>
						<select id="export-resolution" class="w-full border rounded-md px-3 py-2 text-sm text-gray-700 focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
							<option value="1">1x (predeterminada)</option>
							<option value="1.5">1.5x</option>
							<option value="2">2x</option>
							<option value="4">4x</option>
						</select>
						<p class="text-xs text-gray-500 mt-1">Escala relativa al tamaño visible del lienzo.</p>
					</div>
					<div>
						<label for="export-bg-color" class="block text-sm font-semibold text-gray-700 mb-1">Color de fondo</label>
						<div class="flex items-center gap-3">
							<input id="export-bg-color" type="color" value="#f0f0f0" class="h-10 w-16 border rounded cursor-pointer">
							<span class="text-sm text-gray-600">Ajusta el color de la base antes de exportar.</span>
						</div>
					</div>
					<div class="flex flex-col sm:flex-row gap-2 pt-1">
						<button id="copy-to-clipboard-btn" class="flex-1 px-3 py-2 rounded-md bg-blue-600 text-white hover:bg-blue-700 transition-colors text-sm font-semibold">Copiar al portapapeles</button>
						<button id="download-image-btn" class="flex-1 px-3 py-2 rounded-md bg-emerald-600 text-white hover:bg-emerald-700 transition-colors text-sm font-semibold">Descargar</button>
					</div>
					<p class="text-xs text-gray-500">Si el portapapeles no está disponible, usa el botón “Descargar”.</p>
				</div>
			</div>
		</div>
	</div>

	<!-- CT Symbol Picker Modal -->
	<div id="ct-symbol-picker-modal" class="fixed inset-0 bg-black bg-opacity-50 hidden items-center justify-center z-50">
		<div class="bg-white p-6 rounded-lg shadow-xl max-w-3xl w-full">
			<div class="flex justify-between items-center mb-4">
				<h3 class="text-lg font-bold">Seleccionar Símbolo de CT</h3>
				<button id="close-ct-picker-btn" class="text-gray-500 hover:text-gray-800 text-2xl leading-none">&times;</button>
			</div>
			<div id="ct-symbol-grid" class="grid grid-cols-3 sm:grid-cols-4 md:grid-cols-5 gap-4">
				<!-- Symbols will be populated by JS -->
			</div>
		</div>
	</div>

	<!-- Mundo Interno Symbol Picker Modal -->
	<div id="mundo-interno-picker-modal" class="fixed inset-0 bg-black bg-opacity-50 hidden items-center justify-center z-50">
		<div class="bg-white p-6 rounded-lg shadow-xl max-w-lg w-full">
			<div class="flex justify-between items-center mb-4">
				<h3 class="text-lg font-bold">Seleccionar Símbolo de Mundo Interno</h3>
				<button id="close-mundo-interno-picker-btn" class="text-gray-500 hover:text-gray-800 text-2xl leading-none">&times;</button>
			</div>
			<div id="mundo-interno-symbol-grid" class="grid grid-cols-2 sm:grid-cols-3 gap-4">
				<!-- Symbols will be populated by JS -->
			</div>
		</div>
	</div>

	<!-- Seccionador Symbol Picker Modal -->
		<div id="seccionador-symbol-picker-modal" class="fixed inset-0 bg-black bg-opacity-50 hidden items-center justify-center z-50">
			<div class="bg-white p-6 rounded-lg shadow-xl max-w-3xl w-full">
				<div class="flex justify-between items-center mb-4">
					<h3 class="text-lg font-bold">Seleccionar Símbolo de Elemento de Red</h3>
					<button id="close-seccionador-picker-btn" class="text-gray-500 hover:text-gray-800 text-2xl leading-none">&times;</button>
				</div>
				<div id="seccionador-symbol-grid" class="grid grid-cols-3 sm:grid-cols-4 md:grid-cols-5 gap-4">
					<!-- Symbols will be populated by JS -->
				</div>
			</div>
		</div>

		<!-- Subgrafo Modal -->
		<div id="subgraph-modal" class="fixed inset-0 bg-black bg-opacity-50 hidden items-center justify-center z-50 p-4">
			<div class="bg-white p-6 rounded-lg shadow-xl max-w-2xl w-full space-y-4">
				<div class="flex items-start justify-between">
					<div>
						<h3 class="text-lg font-bold text-gray-800">Filtrar subgrafo A-B</h3>
						<p class="text-sm text-gray-600 mt-1">Selecciona dos o más puntos (seccionadores u otros elementos) para mostrar todo lo que hay en el camino entre ellos.</p>
					</div>
					<button id="close-subgraph-modal-btn" class="text-gray-500 hover:text-gray-800 text-2xl leading-none">&times;</button>
				</div>
				<div id="subgraph-points-list" class="max-h-72 overflow-y-auto border border-gray-200 rounded-lg divide-y divide-gray-100 bg-gray-50"></div>
				<div class="flex items-center justify-between pt-2">
				<button id="clear-subgraph-filter-btn" class="px-3 py-2 text-sm rounded bg-gray-100 text-gray-700 hover:bg-gray-200 transition-colors">Quitar filtro</button>
				<div class="flex items-center gap-2">
					<button id="cancel-subgraph-btn" class="px-3 py-2 text-sm rounded bg-gray-100 text-gray-700 hover:bg-gray-200 transition-colors">Cancelar</button>
					<button id="apply-subgraph-btn" class="px-4 py-2 text-sm rounded bg-blue-600 text-white hover:bg-blue-700 transition-colors font-semibold">Aplicar</button>
				</div>
			</div>
		</div>
	</div>

	<!-- Help Modal -->
    <div id="help-modal" class="fixed inset-0 bg-black bg-opacity-50 hidden items-center justify-center z-50 p-4">
		<div class="bg-white p-6 rounded-lg shadow-xl max-w-4xl w-full max-h-[90vh] flex flex-col">
			<div class="flex justify-between items-center mb-4 pb-4 border-b">
				<h3 class="text-xl font-bold text-gray-800">Guía de Funcionalidades</h3>
				<button id="close-help-modal-btn" class="text-gray-500 hover:text-gray-800 text-3xl leading-none">&times;</button>
			</div>
			<div id="help-content" class="overflow-y-auto pr-4 text-gray-700 space-y-4 text-sm">
				<details open>
					<summary class="font-bold text-lg cursor-pointer py-2">Navegación Básica</summary>
					<div class="pl-4 pt-2 space-y-3 border-l-2 border-gray-200 ml-1">
						<div class="flex items-start gap-3">
							<span class="flex-shrink-0 w-6 h-6 flex items-center justify-center mt-1">
								<svg class="w-5 h-5 text-gray-600" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
									<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 2 L12 22 M2 12 L22 12 M8 6 L12 2 L16 6 M8 18 L12 22 L16 18 M6 8 L2 12 L6 16 M18 8 L22 12 L18 16"></path>
								</svg>
							</span>
							<p><strong class="font-semibold text-gray-800">Mover (Pan):</strong> Mantén presionado el botón izquierdo del ratón en un área vacía y arrastra para moverte por el lienzo.</p>
						</div>
						<div class="flex items-start gap-3">
							<span class="flex-shrink-0 w-6 h-6 flex items-center justify-center mt-1">
								<svg class="w-5 h-5 text-gray-600" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0zM10 7v3m0 0v3m0-3h3m-3 0H7"></path></svg>
							</span>
							<p><strong class="font-semibold text-gray-800">Zoom:</strong> Usa la rueda del ratón para acercar o alejar la vista.</p>
						</div>
						<div class="flex items-start gap-3">
							<span class="flex-shrink-0 w-6 h-6 flex items-center justify-center bg-gray-200 rounded-md mt-1">
								<svg class="w-4 h-4 text-gray-800" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
									<path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"></path>
									<path d="M3 3v5h5"></path>
								</svg>
							</span>
							<p><strong class="font-semibold text-gray-800">Restablecer Vista:</strong> Si has usado la herramienta 'Recortar', aparecerá un botón 'Restablecer' para volver a la vista completa del diagrama.</p>
						</div>
					</div>
				</details>
			
				<details>
					<summary class="font-bold text-lg cursor-pointer py-2">Carga y Guardado de Archivos</summary>
					<div class="pl-4 pt-2 space-y-3 border-l-2 border-gray-200 ml-1">
						<div class="flex items-start gap-3">
							<span class="flex-shrink-0 w-6 h-6 flex items-center justify-center bg-purple-100 rounded-md mt-1">
								<svg class="w-4 h-4 text-purple-700" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M4 3h16v18H4z"></path><path stroke-linecap="round" stroke-linejoin="round" d="M4 7h16"></path></svg>
							</span>
							<p><strong class="font-semibold text-gray-800">Cargar DXF:</strong> Usa el botón 'DXF' para cargar un archivo `.dxf`. Puedes cargar múltiples archivos DXF y se añadirán al lienzo uno al lado del otro.</p>
						</div>
						<div class="flex items-start gap-3">
							<div class="flex-shrink-0 w-auto flex items-center justify-center gap-1 bg-blue-100 rounded-md mt-1 p-1">
								<svg class="w-4 h-4 text-blue-600" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M3 16.5v2.25A2.25 2.25 0 005.25 21h13.5A2.25 2.25 0 0021 18.75V16.5m-13.5-9L12 3m0 0l4.5 4.5M12 3v13.5"></path></svg>
								<svg class="w-4 h-4 text-blue-600" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M12 4.5v15m0 0l6.75-6.75M12 19.5l-6.75-6.75"></path></svg>
							</div>
							<p><strong class="font-semibold text-gray-800">Cargar/Descargar JSON:</strong> Los botones 'JSON' te permiten guardar todo tu trabajo (incluyendo dibujos y la vista actual) en un archivo `.json` en tu computadora, o cargar uno para continuar trabajando.</p>
						</div>
						<div class="flex items-start gap-3">
							<div class="flex-shrink-0 w-auto flex items-center justify-center gap-1 bg-gray-100 rounded-md mt-1 p-1">
								<svg class="w-5 h-5 text-gray-700" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M9 13.5l3 3m0 0l3-3m-3 3v-6m1.06-4.19l-2.12-2.12a1.5 1.5 0 00-1.061-.44H4.5A2.25 2.25 0 002.25 6v12a2.25 2.25 0 002.25 2.25h15A2.25 2.25 0 0021.75 18V9a2.25 2.25 0 00-2.25-2.25h-5.379a1.5 1.5 0 01-1.06-.44z"></path></svg>
								<svg class="w-5 h-5 text-gray-700" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M2.25 12.75V12A2.25 2.25 0 014.5 9.75h15A2.25 2.25 0 0121.75 12v.75m-8.69-6.44l-2.12-2.12a1.5 1.5 0 00-1.061-.44H4.5A2.25 2.25 0 002.25 6v12a2.25 2.25 0 002.25 2.25h15A2.25 2.25 0 0021.75 18V9a2.25 2.25 0 00-2.25-2.25h-5.379a1.5 1.5 0 01-1.06-.44z"></path></svg>
							</div>
							<p><strong class="font-semibold text-gray-800">Guardado Rápido (Navegador):</strong> El botón de guardar te permite guardar el croquis actual en la memoria de tu navegador. Puedes acceder a ellos desde el botón de la carpeta.</p>
						</div>
					</div>
				</details>
				
				<details>
					<summary class="font-bold text-lg cursor-pointer py-2">Barra de Herramientas (Izquierda)</summary>
					<div class="pl-4 pt-2 space-y-3 border-l-2 border-gray-200 ml-1">
						<div class="flex items-start gap-3">
							<span class="flex-shrink-0 w-6 h-6 flex items-center justify-center bg-green-100 rounded-md mt-1">
								<svg class="w-6 h-6 text-gray-600 p-0.5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M6.13 1L6 16a2 2 0 0 0 2 2h15"></path><path d="M1 6.13L16 6a2 2 0 0 1 2 2v15"></path></svg>
							</span>
							<p><strong class="font-semibold text-gray-800">Recortar Vista:</strong> Selecciona esta herramienta y arrastra para definir una nueva área visible del diagrama.</p>
						</div>
						<div class="flex items-start gap-3">
							<span class="flex-shrink-0 w-6 h-6 flex items-center justify-center bg-green-100 rounded-md mt-1">
								<svg class="w-6 h-6 text-gray-600 p-0.5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2" stroke-dasharray="4 2"></rect></svg>
							</span>
							<p><strong class="font-semibold text-gray-800">Selección de Marco:</strong> Permite seleccionar múltiples elementos arrastrando un rectángulo sobre ellos.</p>
						</div>
						<div class="flex items-start gap-3">
							<span class="flex-shrink-0 w-6 h-6 flex items-center justify-center bg-amber-100 rounded-md mt-1">
								<svg class="w-6 h-6 text-gray-600 p-0.5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="-1 -1 26 26" stroke-width="1.5" stroke="currentColor"><rect x="2" y="2" width="20" height="20" stroke="currentColor" fill="none"></rect><path stroke-linecap="round" stroke-linejoin="round" d="M12 6L6 16h12z"></path></svg>
							</span>
							<p><strong class="font-semibold text-gray-800">Añadir Símbolos (CT, Elemento Red, etc.):</strong> Haz clic en el botón para abrir un selector de símbolos. Elige uno y haz clic en el lienzo para colocarlo.</p>
						</div>
						<div class="flex items-start gap-3">
							<span class="flex-shrink-0 w-6 h-6 flex items-center justify-center bg-blue-100 rounded-md mt-1">
								<svg class="w-6 h-6 text-gray-600 p-0.5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M2.25 3h19.5a2.25 2.25 0 012.25 2.25v13.5A2.25 2.25 0 0121.75 21H2.25A2.25 2.25 0 010 18.75V5.25A2.25 2.25 0 012.25 3z"></path></svg>
							</span>
							<p><strong class="font-semibold text-gray-800">Herramientas de Dibujo:</strong> Selecciona una forma (rectángulo, elipse, línea, etc.), un texto o una toma de tierra y dibuja directamente sobre el lienzo.</p>
						</div>
					</div>
				</details>
			
				<details>
					<summary class="font-bold text-lg cursor-pointer py-2">Interacción y Edición</summary>
					<div class="pl-4 pt-2 space-y-3 border-l-2 border-gray-200 ml-1">
						<p><strong class="font-semibold text-gray-800">Seleccionar:</strong> Haz clic en cualquier elemento (símbolo, línea, dibujo) para seleccionarlo. Sus detalles aparecerán en el panel derecho para editarlo.</p>
						<p><strong class="font-semibold text-gray-800">Selección Múltiple:</strong> Mantén presionada la tecla <kbd>Shift</kbd> mientras haces clic en varios elementos para seleccionarlos todos.</p>
						<div class="flex items-start gap-3">
							<span class="flex-shrink-0 w-12 h-6 flex items-center justify-center mt-1">
								<svg class="w-11 h-6" viewBox="0 0 44 24"><rect x="0" y="0" width="44" height="24" rx="12" fill="#34d399"></rect><circle cx="32" cy="12" r="10" fill="white"></circle></svg>
							</span>
							<p><strong class="font-semibold text-gray-800">Movimiento Manual:</strong> Activa el interruptor 'Movimiento' en la esquina superior derecha. Ahora puedes arrastrar elementos individuales o grupos seleccionados para reposicionarlos.</p>
						</div>
						<p><strong class="font-semibold text-gray-800">Mover Etiquetas:</strong> Haz doble clic sobre el nombre de un CT o Seccionador para entrar en modo de edición de posición. Mueve el ratón y haz otro doble clic para fijar la nueva posición de la etiqueta.</p>
						 <p><strong class="font-semibold text-gray-800">Redimensionar Dibujos:</strong> Al seleccionar un dibujo hecho a mano, aparecerán manejadores en sus bordes. Arrástralos para cambiar el tamaño del dibujo.</p>
						<div class="flex items-start gap-3">
							<span class="flex-shrink-0 w-6 h-6 flex items-center justify-center bg-red-100 rounded-full mt-1">
								<svg class="w-5 h-5 text-red-600" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002 2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm4 0a1 1 0 012 0v6a1 1 0 11-2 0V8z" clip-rule="evenodd"></path></svg>
							</span>
							<p><strong class="font-semibold text-gray-800">Eliminar:</strong> Selecciona uno o más elementos y presiona el botón de la papelera.</p>
						</div>
					</div>
				</details>
			
				<details>
					<summary class="font-bold text-lg cursor-pointer py-2">Atajos de Teclado</summary>
					<div class="pl-4 pt-2 space-y-3 border-l-2 border-gray-200 ml-1">
						<div class="flex items-start gap-3">
							<span class="flex-shrink-0 w-6 h-6 flex items-center justify-center mt-1">
								<svg class="w-5 h-5 text-gray-600" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M9 15L3 9m0 0l6-6M3 9h12a6 6 0 010 12h-3"></path></svg>
							</span>
							<p><strong class="font-semibold text-gray-800">Deshacer:</strong> <kbd>Ctrl</kbd> + <kbd>Z</kbd></p>
						</div>
						<div class="flex items-start gap-3">
							<span class="flex-shrink-0 w-6 h-6 flex items-center justify-center mt-1">
								<svg class="w-5 h-5 text-gray-600" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M15 15l6-6m0 0l-6-6m6 6H9a6 6 0 000 12h3"></path></svg>
							</span>
							<p><strong class="font-semibold text-gray-800">Rehacer:</strong> <kbd>Ctrl</kbd> + <kbd>Y</kbd></p>
						</div>
						<div class="flex items-start gap-3">
							<span class="flex-shrink-0 w-6 h-6 flex items-center justify-center mt-1">
								<svg class="w-5 h-5 text-gray-600" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M15 15l-2 5L8 9l9-5-5 11z"></path><path stroke-linecap="round" stroke-linejoin="round" d="M18 12h3m-1.5-1.5v3"></path></svg>
							</span>
							<p><strong class="font-semibold text-gray-800">Selección Múltiple:</strong> Mantén <kbd>Shift</kbd> y haz clic para añadir/quitar elementos de la selección.</p>
						</div>
						<div class="flex items-start gap-3">
							<span class="flex-shrink-0 w-6 h-6 flex items-center justify-center mt-1">
								<svg class="w-5 h-5 text-red-600" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002 2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm4 0a1 1 0 012 0v6a1 1 0 11-2 0V8z" clip-rule="evenodd"></path></svg>
							</span>
							<p><strong class="font-semibold text-gray-800">Eliminar:</strong> <kbd>Supr</kbd> / <kbd>Del</kbd></p>
						</div>
					</div>
				</details>

				<details>
					<summary class="font-bold text-lg cursor-pointer py-2">Funciones Avanzadas</summary>
					<div class="pl-4 pt-2 space-y-3 border-l-2 border-gray-200 ml-1">
						<div class="flex items-start gap-3">
							<span class="flex-shrink-0 w-6 h-6 flex items-center justify-center bg-gray-100 rounded-full mt-1">
								<svg class="w-5 h-5 text-gray-700" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M8 3v3a2 2 0 0 1-2 2H3m18 0h-3a2 2 0 0 1-2-2V3m0 18v-3a2 2 0 0 1 2-2h3M3 16h3a2 2 0 0 1 2 2v3"></path></svg>
							</span>
							<p><strong class="font-semibold text-gray-800">Comprimir Diseño:</strong> Reduce el espacio entre los componentes del diagrama de forma proporcional, ya sea en horizontal, vertical o en ambas direcciones.</p>
						</div>
						<div class="flex items-start gap-3">
							<span class="flex-shrink-0 w-6 h-6 flex items-center justify-center mt-1">
								<svg class="w-5 h-5 text-gray-400" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"></path></svg>
							</span>
							<p><strong class="font-semibold text-gray-800">Buscar Elemento:</strong> Usa la barra de búsqueda para encontrar rápidamente un CT o seccionador por su nombre. La vista se centrará en él.</p>
						</div>
						<div class="flex items-start gap-3">
							<span class="flex-shrink-0 w-6 h-6 flex items-center justify-center bg-gray-100 rounded-full mt-1">
								<svg class="w-5 h-5 text-gray-700" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M6.827 6.175A2.31 2.31 0 015.186 7.23c-.38.054-.757.112-1.134.175C2.999 7.58 2.25 8.507 2.25 9.574V18a2.25 2.25 0 002.25 2.25h15A2.25 2.25 0 0021.75 18V9.574c0-1.067-.75-1.994-1.802-2.169a47.865 47.865 0 00-1.134-.175 2.31 2.31 0 01-1.64-1.055l-.822-1.316a2.192 2.192 0 00-1.736-1.039 48.776 48.776 0 00-5.232 0 2.192 2.192 0 00-1.736 1.039l-.821 1.316z"></path><path stroke-linecap="round" stroke-linejoin="round" d="M16.5 12.75a4.5 4.5 0 11-9 0 4.5 4.5 0 019 0zM18.75 10.5h.008v.008h-.008V10.5z"></path></svg>
							</span>
							<p><strong class="font-semibold text-gray-800">Copiar Imagen:</strong> Genera una imagen PNG del estado actual del lienzo que puedes copiar y pegar en informes o documentos.</p>
						</div>
						<div class="flex items-start gap-3">
							<span class="flex-shrink-0 w-6 h-6 flex items-center justify-center bg-gray-100 rounded-full mt-1">
								<svg class="w-5 h-5 text-gray-700" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M4.5 15.75L9.25 5h1.5l4.75 10.75h-1.5l-1.125-2.75h-5.25L6 15.75h-1.5zM8.375 12h3.25L10 7.25 8.375 12zM15.5 15.75l2-4.5h.75l2 4.5h-1.125l-.5-1.25h-2.25l-.5 1.25h-1.125zM16.75 13.5h1.5l-.75-1.75-.75 1.75z"></path></svg>
							</span>
							<p><strong class="font-semibold text-gray-800">Cambiar Tamaño de Textos:</strong> Permite aumentar o disminuir el tamaño de todas las etiquetas del diagrama a la vez mediante un porcentaje.</p>
						</div>
						<div class="flex items-start gap-3">
							<span class="flex-shrink-0 w-6 h-6 flex items-center justify-center bg-gray-100 rounded-full mt-1">
								<svg class="w-5 h-5 text-gray-700" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M6 6.878V6a2.25 2.25 0 012.25-2.25h7.5A2.25 2.25 0 0118 6v.878m-12 0c.235-.083.487-.128.75-.128h10.5c.263 0 .515.045.75.128m-12 0A2.25 2.25 0 004.5 9v.878m13.5-3A2.25 2.25 0 0119.5 9v.878m0 0a2.246 2.246 0 00-.75-.128H5.25c-.263 0-.515.045-.75.128m15 0A2.25 2.25 0 0121 12v6a2.25 2.25 0 01-2.25 2.25H5.25A2.25 2.25 0 013 18v-6c0-.98.626-1.813 1.5-2.122"></path></svg>
							</span>
							<p><strong class="font-semibold text-gray-800">Cambiar Símbolo de CTs (Global):</strong> Abre el selector de símbolos para cambiar el ícono de TODOS los CTs del diagrama a la vez.</p>
						</div>
					</div>
				</details>
			</div>
		</div>
	</div>


	<div class="flex h-screen">
		<div id="tools-sidebar" class="flex flex-col items-center space-y-2 p-2 bg-white shadow-md z-20 border-r border-gray-200">
			<button id="crop-btn" title="Recortar Vista" class="tool-btn p-2 text-gray-600 rounded-md transition-colors selection-tool-btn">
				<svg class="w-6 h-6" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
					<path d="M6.13 1L6 16a2 2 0 0 0 2 2h15"></path>
					<path d="M1 6.13L16 6a2 2 0 0 1 2 2v15"></path>
				</svg>
			</button>
			<button id="marquee-select-btn" title="Selección de Marco" class="tool-btn p-2 text-gray-600 rounded-md transition-colors selection-tool-btn">
				<svg class="w-6 h-6" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
					<rect x="3" y="3" width="18" height="18" rx="2" ry="2" stroke-dasharray="4 2"></rect>
				</svg>
			</button>
			<hr class="w-full border-gray-200 my-1">
			<button id="draw-ct-btn" title="Añadir CT" class="tool-btn p-2 text-gray-600 rounded-md transition-colors ct-tool-btn">
				<svg class="w-6 h-6" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="-1 -1 26 26" stroke-width="1.5" stroke="currentColor">
					<rect x="2" y="2" width="20" height="20" stroke="currentColor" fill="none"/>
					<path stroke-linecap="round" stroke-linejoin="round" d="M12 6L6 16h12z" />
				</svg>
			</button>
			<button id="draw-seccionador-btn" title="Añadir Elemento de Red" class="tool-btn p-2 text-gray-600 rounded-md transition-colors ct-tool-btn">
				<svg class="w-6 h-6" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
					<path stroke-linecap="round" stroke-linejoin="round" d="M12 2L2 12l10 10 10-10L12 2z" />
				</svg>
			</button>
			<button id="draw-mundo-interno-btn" title="Añadir Mundo Interno" class="tool-btn p-2 text-gray-600 rounded-md transition-colors ct-tool-btn">
				<svg class="w-6 h-6" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
					<circle cx="12" cy="12" r="10"></circle>
					<circle cx="12" cy="12" r="3" fill="currentColor"></circle>
				</svg>
			</button>
			<button id="draw-ellipse-btn" title="Elipse" class="tool-btn p-2 text-gray-600 rounded-md transition-colors shape-tool-btn">
			 <svg class="w-6 h-6" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><ellipse cx="12" cy="12" rx="10" ry="6"/></svg>
			</button>
			<button id="draw-rect-btn" title="Rectángulo" class="tool-btn p-2 text-gray-600 rounded-md transition-colors shape-tool-btn">
				<svg class="w-6 h-6" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M2.25 3h19.5a2.25 2.25 0 012.25 2.25v13.5A2.25 2.25 0 0121.75 21H2.25A2.25 2.25 0 010 18.75V5.25A2.25 2.25 0 012.25 3z" /></svg>
			</button>
			  <button id="draw-line-btn" title="Línea" class="tool-btn p-2 text-gray-600 rounded-md transition-colors shape-tool-btn">
				<svg class="w-6 h-6" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><line x1="5" y1="19" x2="19" y2="5" /></svg>
			</button>
			<button id="draw-dashed-line-btn" title="Línea Punteada" class="tool-btn p-2 text-gray-600 rounded-md transition-colors shape-tool-btn">
				<svg class="w-6 h-6" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" stroke-dasharray="4 4"><line x1="5" y1="19" x2="19" y2="5" /></svg>
			</button>
			<button id="draw-text-btn" title="Texto" class="tool-btn p-2 text-gray-600 rounded-md transition-colors shape-tool-btn">
				<svg class="w-6 h-6" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
					<text x="0" y="18" font-family="Inter, sans-serif" font-size="14" font-weight="bold">Abc</text>
				</svg>
			</button>
			  <button id="draw-ground-btn" title="Tierra Eléctrica" class="tool-btn p-2 text-gray-600 rounded-md transition-colors shape-tool-btn">
				<svg class="w-6 h-6" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
					<line x1="12" y1="2" x2="12" y2="9"></line>
					<line x1="8" y1="9" x2="16" y2="9"></line>
					<line x1="9" y1="13" x2="15" y2="13"></line>
					<line x1="10" y1="17" x2="14" y2="17"></line>
				</svg>
			</button>
		</div>

		<div class="flex-grow flex flex-col">
			<div class="p-4 md:p-6 lg:p-8 flex-grow flex flex-col w-full">
				<header class="shadow-sm rounded-xl p-4 mb-6 text-gray-800 bg-white border border-gray-200">
					<div class="flex justify-between items-start mb-4">
						<div>
							<h1 class="text-2xl font-bold">
								<span style="color: #2563eb;">Esquem</span><span style="color: #10b981;">App</span>
							</h1>
						</div>
						<div class="flex items-center gap-2">
							<div id="toggle-manual-mode-container" class="flex items-center px-1" title="Habilitar Movimiento">
								<span class="text-sm font-medium text-gray-700 mr-2">Movimiento</span>
								<label for="manual-mode-toggle" class="relative inline-flex items-center cursor-pointer">
									<input type="checkbox" id="manual-mode-toggle" class="sr-only peer">
									<div class="w-11 h-6 bg-gray-300 rounded-full peer peer-focus:ring-2 peer-focus:ring-blue-300 peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-green-500"></div>
								</label>
							</div>
							 <button id="undo-btn" title="Deshacer" class="p-2 bg-gray-100 hover:bg-gray-200 text-gray-700 rounded-full transition-colors disabled:opacity-50 disabled:cursor-not-allowed" disabled>
								<svg class="w-5 h-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M9 15L3 9m0 0l6-6M3 9h12a6 6 0 010 12h-3" /></svg>
							</button>
								<button id="redo-btn" title="Rehacer" class="p-2 bg-gray-100 hover:bg-gray-200 text-gray-700 rounded-full transition-colors disabled:opacity-50 disabled:cursor-not-allowed" disabled>
									<svg class="w-5 h-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M15 15l6-6m0 0l-6-6m6 6H9a6 6 0 000 12h3" /></svg>
								</button>
								<div class="relative inline-block text-left">
									<button id="compress-menu-btn" title="Comprimir Diseño" class="p-2 bg-gray-100 hover:bg-gray-200 text-gray-700 rounded-full transition-colors">
										<svg class="w-5 h-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
										  <path d="M8 3v3a2 2 0 0 1-2 2H3m18 0h-3a2 2 0 0 1-2-2V3m0 18v-3a2 2 0 0 1 2-2h3M3 16h3a2 2 0 0 1 2 2v3"/>
										</svg>
									</button>
								<div id="compress-menu" class="origin-top-right absolute right-0 mt-2 w-48 rounded-md shadow-lg bg-white ring-1 ring-black ring-opacity-5 hidden z-40">
									<div class="py-1" role="menu" aria-orientation="vertical">
										<a href="#" id="compress-all-btn" class="block px-4 py-2 text-sm text-gray-700 hover:bg-gray-100" role="menuitem">Comprimir Todo</a>
										<a href="#" id="compress-horizontal-btn" class="block px-4 py-2 text-sm text-gray-700 hover:bg-gray-100" role="menuitem">Comprimir Horizontal</a>
										<a href="#" id="compress-vertical-btn" class="block px-4 py-2 text-sm text-gray-700 hover:bg-gray-100" role="menuitem">Comprimir Vertical</a>
									</div>
								</div>
							</div>
							<button id="delete-btn" title="Eliminar Selección" class="p-2 bg-red-100 text-red-600 rounded-full hover:bg-red-200 transition-colors disabled:bg-gray-100 disabled:text-gray-400 disabled:cursor-not-allowed" disabled>
								<svg class="w-5 h-5" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002 2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm4 0a1 1 0 012 0v6a1 1 0 11-2 0V8z" clip-rule="evenodd" /></svg>
							</button>
							<button id="clear-drawings-btn" title="Limpiar Lienzo" class="p-2 bg-yellow-100 text-yellow-600 rounded-full hover:bg-yellow-200 transition-colors disabled:bg-gray-100 disabled:text-gray-400 disabled:cursor-not-allowed" disabled>
								<svg class="w-5 h-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
									<path stroke-linecap="round" stroke-linejoin="round" d="M19.5 14.25v-2.625a3.375 3.375 0 00-3.375-3.375h-1.5A1.125 1.125 0 0113.5 7.125v-1.5a3.375 3.375 0 00-3.375-3.375H8.25m5.231 13.481L15 17.25m-4.5-15H5.625c-.621 0-1.125.504-1.125 1.125v17.25c0 .621.504 1.125 1.125 1.125h12.75c.621 0 1.125-.504 1.125-1.125V11.25a9 9 0 00-9-9z" />
								</svg>
							</button>
						</div>
					</div>
					<div class="flex flex-wrap items-center justify-between gap-2">
						<div class="flex flex-wrap items-center gap-2">
							<div class="flex items-center bg-gray-100 rounded-full px-3 py-1 ml-2">
								<svg class="w-5 h-5 text-gray-400" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
									<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
								</svg>
								<input type="text" id="search-input" list="search-suggestions" placeholder="Buscar elemento..." class="bg-transparent text-gray-700 placeholder-gray-400 focus:outline-none ml-2 text-sm w-48">
								<datalist id="search-suggestions"></datalist>
							</div>
							<button id="subgraph-filter-btn" title="Filtrar subgrafo entre dos o más puntos de la red" class="px-3 py-1 text-sm rounded bg-emerald-100 text-emerald-700 hover:bg-emerald-200 transition-colors font-semibold flex items-center gap-2">
								<svg class="w-4 h-4" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
									<path stroke-linecap="round" stroke-linejoin="round" d="M4.5 9.75L9 5.25m6 0l4.5 4.5m-15 4.5L9 18.75m6 0l4.5-4.5M9 5.25h6M9 18.75h6" />
								</svg>
								<span>Subgrafo A-B</span>
							</button>
							<span id="subgraph-filter-status" class="hidden ml-1 px-2 py-1 text-xs font-semibold rounded-full bg-emerald-100 text-emerald-700">Filtro A-B activo</span>

							<div class="relative inline-block text-left ml-2">
								<div>
									<button type="button" id="saved-sketches-menu-button" class="p-2 bg-gray-100 hover:bg-gray-200 text-gray-700 rounded-full transition-colors" aria-expanded="false" aria-haspopup="true" title="Croquis Guardados">
										<svg class="w-5 h-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
											<path stroke-linecap="round" stroke-linejoin="round" d="M2.25 12.75V12A2.25 2.25 0 014.5 9.75h15A2.25 2.25 0 0121.75 12v.75m-8.69-6.44l-2.12-2.12a1.5 1.5 0 00-1.061-.44H4.5A2.25 2.25 0 002.25 6v12a2.25 2.25 0 002.25 2.25h15A2.25 2.25 0 0021.75 18V9a2.25 2.25 0 00-2.25-2.25h-5.379a1.5 1.5 0 01-1.06-.44z" />
										</svg>
									</button>
								</div>
								<div id="saved-sketches-menu" class="origin-top-left absolute left-0 mt-2 w-64 rounded-md shadow-lg bg-white ring-1 ring-black ring-opacity-5 focus:outline-none hidden z-10" role="menu">
									<div class="p-2">
										<h4 class="text-sm font-semibold text-gray-700 mb-2 px-2">Croquis Guardados</h4>
										<ul id="saved-sketches-list" class="text-gray-700 text-sm max-h-60 overflow-y-auto"></ul>
									</div>
								</div>
							</div>
							<button id="save-sketch-btn" title="Guardar Croquis en Navegador" class="p-2 bg-gray-100 hover:bg-gray-200 text-gray-700 rounded-full transition-colors">
								<svg class="w-5 h-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
								  <path stroke-linecap="round" stroke-linejoin="round" d="M9 13.5l3 3m0 0l3-3m-3 3v-6m1.06-4.19l-2.12-2.12a1.5 1.5 0 00-1.061-.44H4.5A2.25 2.25 0 002.25 6v12a2.25 2.25 0 002.25 2.25h15A2.25 2.25 0 0021.75 18V9a2.25 2.25 0 00-2.25-2.25h-5.379a1.5 1.5 0 01-1.06-.44z" />
								</svg>
							</button>
							<button id="copy-image-btn" title="Copiar Imagen" class="p-2 bg-gray-100 hover:bg-gray-200 text-gray-700 rounded-full transition-colors">
								<svg class="w-5 h-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
									<path stroke-linecap="round" stroke-linejoin="round" d="M6.827 6.175A2.31 2.31 0 015.186 7.23c-.38.054-.757.112-1.134.175C2.999 7.58 2.25 8.507 2.25 9.574V18a2.25 2.25 0 002.25 2.25h15A2.25 2.25 0 0021.75 18V9.574c0-1.067-.75-1.994-1.802-2.169a47.865 47.865 0 00-1.134-.175 2.31 2.31 0 01-1.64-1.055l-.822-1.316a2.192 2.192 0 00-1.736-1.039 48.776 48.776 0 00-5.232 0 2.192 2.192 0 00-1.736 1.039l-.821 1.316z" />
									<path stroke-linecap="round" stroke-linejoin="round" d="M16.5 12.75a4.5 4.5 0 11-9 0 4.5 4.5 0 019 0zM18.75 10.5h.008v.008h-.008V10.5z" />
								</svg>
							</button>
							<button id="resize-text-btn" title="Cambiar Tamaño de Textos" class="p-2 bg-gray-100 hover:bg-gray-200 text-gray-700 rounded-full transition-colors">
								<svg class="w-5 h-5" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
								  <path d="M4.5 15.75L9.25 5h1.5l4.75 10.75h-1.5l-1.125-2.75h-5.25L6 15.75h-1.5zM8.375 12h3.25L10 7.25 8.375 12zM15.5 15.75l2-4.5h.75l2 4.5h-1.125l-.5-1.25h-2.25l-.5 1.25h-1.125zM16.75 13.5h1.5l-.75-1.75-.75 1.75z"/>
								</svg>
							</button>
								<button id="bulk-change-ct-symbol-btn" title="Cambiar Símbolo de Todos los CTs" class="p-2 bg-gray-100 hover:bg-gray-200 text-gray-700 rounded-full transition-colors">
									<svg class="w-5 h-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
										<path stroke-linecap="round" stroke-linejoin="round" d="M6 6.878V6a2.25 2.25 0 012.25-2.25h7.5A2.25 2.25 0 0118 6v.878m-12 0c.235-.083.487-.128.75-.128h10.5c.263 0 .515.045.75.128m-12 0A2.25 2.25 0 004.5 9v.878m13.5-3A2.25 2.25 0 0119.5 9v.878m0 0a2.246 2.246 0 00-.75-.128H5.25c-.263 0-.515.045-.75.128m15 0A2.25 2.25 0 0121 12v6a2.25 2.25 0 01-2.25 2.25H5.25A2.25 2.25 0 013 18v-6c0-.98.626-1.813 1.5-2.122" />
									</svg>
								</button>
								<button id="reset-view-btn" title="Restablecer Vista" class="hidden px-3 py-1 text-sm rounded bg-gray-200 text-gray-800 hover:bg-gray-300 transition-colors font-semibold flex items-center gap-1">
									<svg class="w-4 h-4" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
										<path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/>
										<path d="M3 3v5h5"/>
									</svg>
									<span>Restablecer</span>
								</button>
						</div>
						 <div class="flex items-center flex-wrap justify-end gap-2">
							<label for="upload-sketch-file" title="Subir Croquis (.json)" class="cursor-pointer px-3 py-1 text-sm rounded bg-blue-100 text-blue-600 hover:bg-blue-200 transition-colors font-semibold flex items-center gap-1">
								<svg class="w-4 h-4" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor">
									<path stroke-linecap="round" stroke-linejoin="round" d="M3 16.5v2.25A2.25 2.25 0 005.25 21h13.5A2.25 2.25 0 0021 18.75V16.5m-13.5-9L12 3m0 0l4.5 4.5M12 3v13.5" />
								</svg>
								<span>JSON</span>
							</label>
							<input id="upload-sketch-file" type="file" class="hidden" accept=".json">
							<button id="download-sketch-btn" title="Descargar Croquis (.json)" class="px-3 py-1 text-sm rounded bg-blue-100 text-blue-600 hover:bg-blue-200 transition-colors font-semibold flex items-center gap-1">
								<svg class="w-4 h-4" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor">
								  <path stroke-linecap="round" stroke-linejoin="round" d="M12 4.5v15m0 0l6.75-6.75M12 19.5l-6.75-6.75" />
								</svg>
								<span>JSON</span>
							</button>
                            <label for="dxf-upload-input" title="Cargar archivo DXF" class="cursor-pointer px-3 py-1 text-sm rounded bg-purple-100 text-purple-700 hover:bg-purple-200 transition-colors font-semibold flex items-center gap-1">
                                <svg class="w-4 h-4" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor">
                                    <path stroke-linecap="round" stroke-linejoin="round" d="M4 3h16v18H4z" />
                                    <path stroke-linecap="round" stroke-linejoin="round" d="M4 7h16" />
                                </svg>
                                <span id="dxf-upload-label-span">DXF</span>
                            </label>
                            <input id="dxf-upload-input" type="file" class="hidden" accept=".dxf">
                            <button id="help-btn" title="Ayuda" class="p-2 bg-blue-100 text-blue-600 rounded-full hover:bg-blue-200 transition-colors">
                                <svg class="w-5 h-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor">
                                  <path stroke-linecap="round" stroke-linejoin="round" d="M9.879 7.519c1.171-1.025 3.071-1.025 4.242 0 1.172 1.025 1.172 2.687 0 3.712-.203.179-.43.326-.67.442-.745.361-1.45.999-1.45 1.827v.75M21 12a9 9 0 11-18 0 9 9 0 0118 0zm-9 5.25h.008v.008H12v-.008z" />
                                </svg>
                            </button>
                            <button id="home-btn" title="Limpiar y volver a la pantalla de inicio" class="px-3 py-1 text-sm rounded bg-gray-200 text-gray-800 hover:bg-gray-300 transition-colors font-semibold">Inicio</button>
						</div>
					</div>
				</header>

<main id="visualization-container" class="bg-white shadow-sm rounded-xl p-2 sm:p-4 overflow-auto flex-grow border border-gray-300 relative" style="min-height: 70vh;">
					<div id="initial-message" class="flex flex-col items-center justify-center h-full text-center text-gray-500" style="min-height: 65vh;">
						<svg class="w-16 h-16 mb-4 text-gray-300" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor">
							<path stroke-linecap="round" stroke-linejoin="round" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z"></path>
						</svg>
						<h2 class="text-xl font-semibold">Bienvenido a EsquemApp</h2>
						<p class="mt-2 max-w-md">Use las herramientas para dibujar o cargue un archivo de croquis (JSON o DXF) para comenzar.</p>
					</div>
					<div id="loading-indicator" class="hidden flex flex-col items-center justify-center h-full" style="min-height: 65vh;">
						<div class="loader"></div>
						<p class="mt-4 text-gray-600">Procesando datos y generando gráfico...</p>
					</div>
                      <canvas id="dxf-canvas" class="absolute top-0 left-0 w-full h-full hidden"></canvas>
				</main>
			</div>
		</div>
		
		<div id="info-panel" class="relative w-80 bg-white shadow-lg p-6 transform translate-x-full transition-transform duration-300 ease-in-out z-30">
			<button id="close-info-panel-btn" class="absolute top-4 right-4 text-gray-500 hover:text-gray-800 z-10">
				<svg class="w-6 h-6" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12" /></svg>
			</button>
			<div id="info-content">
				<p class="text-gray-500">Seleccione un elemento para ver sus detalles.</p>
			</div>
		</div>
	</div>


	<script>
		// --- El código de la aplicación principal EsquemApp va aquí (sin cambios) ---
		// --- Por brevedad, se omite. El código es idéntico al que ya tienes. ---
	</script>
    <script src="https://cdn.jsdelivr.net/npm/dxf-parser@1.1.2/dist/dxf-parser.js"></script>
    <script>
    (function() {
        const dxfInput = document.getElementById('dxf-upload-input');
        const homeBtn = document.getElementById('home-btn');
        const dxfCanvas = document.getElementById('dxf-canvas');
        const dxfCtx = dxfCanvas.getContext('2d');
        const infoPanel = document.getElementById('info-panel');
        const infoContent = document.getElementById('info-content');
        const closeInfoPanelBtn = document.getElementById('close-info-panel-btn');
		const resetViewBtn = document.getElementById('reset-view-btn');
		const toolBtns = document.querySelectorAll('.tool-btn');
		const undoBtn = document.getElementById('undo-btn');
		const redoBtn = document.getElementById('redo-btn');
		const clearDrawingsBtn = document.getElementById('clear-drawings-btn');
		const deleteBtn = document.getElementById('delete-btn');
		const resizeTextBtn = document.getElementById('resize-text-btn');
		const bulkChangeCtSymbolBtn = document.getElementById('bulk-change-ct-symbol-btn');
		const copyImageBtn = document.getElementById('copy-image-btn');
		const copyImageModal = document.getElementById('copy-image-modal');
		const closeModalBtn = document.getElementById('close-modal-btn');
		const imageToCopy = document.getElementById('image-to-copy');
		const exportFormatSelect = document.getElementById('export-format');
		const exportResolutionSelect = document.getElementById('export-resolution');
		const exportBgColorInput = document.getElementById('export-bg-color');
		const exportPreviewLoading = document.getElementById('export-preview-loading');
		const exportDimensionsLabel = document.getElementById('export-dimensions-label');
		const exportSizeLabel = document.getElementById('export-size-label');
		const clipboardNotice = document.getElementById('clipboard-notice');
		const downloadImageBtn = document.getElementById('download-image-btn');
		const copyToClipboardBtn = document.getElementById('copy-to-clipboard-btn');
		const searchInput = document.getElementById('search-input');
        const searchSuggestions = document.getElementById('search-suggestions');
		const manualModeToggle = document.getElementById('manual-mode-toggle');
		const manualModeToggleContainer = document.getElementById('toggle-manual-mode-container');
		const saveSketchBtn = document.getElementById('save-sketch-btn');
        const savedSketchesMenuBtn = document.getElementById('saved-sketches-menu-button');
        const savedSketchesMenu = document.getElementById('saved-sketches-menu');
        const savedSketchesList = document.getElementById('saved-sketches-list');
		const drawCtBtn = document.getElementById('draw-ct-btn');
		const ctPickerModal = document.getElementById('ct-symbol-picker-modal');
		const closeCtPickerBtn = document.getElementById('close-ct-picker-btn');
		const ctSymbolGrid = document.getElementById('ct-symbol-grid');
		const drawSeccionadorBtn = document.getElementById('draw-seccionador-btn');
		const drawMundoInternoBtn = document.getElementById('draw-mundo-interno-btn');
		const mundoInternoPickerModal = document.getElementById('mundo-interno-picker-modal');
		const closeMundoInternoPickerBtn = document.getElementById('close-mundo-interno-picker-btn');
		const mundoInternoSymbolGrid = document.getElementById('mundo-interno-symbol-grid');
		const seccionadorPickerModal = document.getElementById('seccionador-symbol-picker-modal');
		const closeSeccionadorPickerBtn = document.getElementById('close-seccionador-picker-btn');
		const seccionadorSymbolGrid = document.getElementById('seccionador-symbol-grid');
		const subgraphFilterBtn = document.getElementById('subgraph-filter-btn');
		const subgraphModal = document.getElementById('subgraph-modal');
		const closeSubgraphModalBtn = document.getElementById('close-subgraph-modal-btn');
		const cancelSubgraphBtn = document.getElementById('cancel-subgraph-btn');
		const applySubgraphBtn = document.getElementById('apply-subgraph-btn');
		const subgraphPointsList = document.getElementById('subgraph-points-list');
		const subgraphStatus = document.getElementById('subgraph-filter-status');
		const clearSubgraphFilterBtn = document.getElementById('clear-subgraph-filter-btn');
		const helpBtn = document.getElementById('help-btn');
		const helpModal = document.getElementById('help-modal');
		const closeHelpModalBtn = document.getElementById('close-help-modal-btn');

	        // --- CONSTANTS ---
	        const SYMBOL_SIZE = 2.0;
	        const GLOBAL_SYMBOL_SCALE = 0.25;
        const CT_COVER_FACTOR = 1.1;
        const LINE_COLOR = '#1f2937';
        const SYMBOL_STROKE_COLOR = '#1f2937';
	        const CT_FILL_COLOR = '#d4d4d8';
	        const SECCIONADOR_FILL_COLOR = '#4ade80';
			const DEFAULT_DRAW_COLOR = '#ef4444';
			const HANDLE_HIT_RADIUS = 5; // Aumentar el área de detección de clics para los puntos de redimensión
	        const SNAP_DISTANCE = 5.0; // Max distance in model units to show snap line
			const SYMBOL_ATTACHMENT_DISTANCE = 2.0; // Distancia máxima para unir nodos a líneas existentes

	        // --- STATE VARIABLES ---
	        let linesAndPolylines = [];
	        let symbols = [];
        let extents = { minX: 0, minY: 0, maxX: -Infinity, maxY: -Infinity };
        let view = { offsetX: 0, offsetY: 0, scale: 1 };
        let selectedEntity = null;
		let editingLabelEntity = null;
		let isPanning = false, lastPos = { x: 0, y: 0 };
		let marqueeStart = null, marqueeEnd = null;
		let currentTool = 'pan'; 
		let originalExtents = null;
		let userDrawings = [];
		let activeDrawing = null;
		let selectedDrawingId = null;
		let activeResizeHandle = null;
		let isDraggingDrawing = false;
        let blockGeometries = {};
        let selectedGroupId = null;
	        let isDraggingGroup = false;
	        let isManualModeEnabled = false;
	        let multiSelection = [];
	        let isDraggingMultiSelection = false;
	        let isShiftPressed = false;
        let activeCtIconType = 'plain'; // Default CT symbol is now just a square
	        let snapLine = null; // To store the perpendicular connection line info
			let activeMundoInternoIconType = 'half-f-circle';
			let activeSeccionadorIconType = 'standard';
			let exportOptions = { format: 'png', scale: 1, backgroundColor: '#f0f0f0' };
			let currentExportDataUrl = '';
			let currentExportBlob = null;
			let activeSubgraphFilter = null;
			let cachedSubgraphGraph = null;


			// --- Undo/Redo State ---
			let undoStack = [];
			let redoStack = [];


		// --- HELPER & CORE FUNCTIONS ---
        function resizeCanvas() {
            const dpr = window.devicePixelRatio || 1;
            const rect = dxfCanvas.getBoundingClientRect();
            dxfCanvas.width = rect.width * dpr;
            dxfCanvas.height = rect.height * dpr;
            dxfCtx.scale(dpr, dpr);
            draw();
        }

		function moveItemBy(item, dx, dy) {
			if (!item) return;
			if (item.start) { item.start.x += dx; item.start.y += dy; }
			if (item.end) { item.end.x += dx; item.end.y += dy; }
			if (item.vertices) {
				item.vertices.forEach(v => { if (v) { v.x += dx; v.y += dy; } });
			}
			if (item.position) { item.position.x += dx; item.position.y += dy; }
		}

		function getItemCenter(item) {
			if (!item) return null;
			const bbox = getEntityBBox(item, true);
			if (bbox) {
				return { x: bbox.x + bbox.width / 2, y: bbox.y + bbox.height / 2 };
			}
			if (item.start) return { ...item.start };
			if (item.position) return { ...item.position };
			return null;
		}

		function isBBoxInsideRect(bbox, rect) {
			if (!bbox) return false;
			return bbox.x >= rect.minX && (bbox.x + bbox.width) <= rect.maxX &&
			       bbox.y >= rect.minY && (bbox.y + bbox.height) <= rect.maxY;
		}

		function clipDiagramToExtents(clipRect) {
			userDrawings = userDrawings.filter(d => isBBoxInsideRect(getEntityBBox(d, true), clipRect));
			symbols = symbols.filter(s => isBBoxInsideRect(getEntityBBox(s, true), clipRect));
			linesAndPolylines = linesAndPolylines.filter(l => isBBoxInsideRect(getEntityBBox(l, true), clipRect));
		}

        function findClosestPointOnSegment(p, a, b) {
            const atob = { x: b.x - a.x, y: b.y - a.y };
            const atop = { x: p.x - a.x, y: p.y - a.y };
            const len = atob.x * atob.x + atob.y * atob.y;
            if (len === 0) { // Segment is a point
                const dist = Math.sqrt(atop.x * atop.x + atop.y * atop.y);
                return { point: { ...a }, distance: dist };
            }

            const t = (atop.x * atob.x + atop.y * atob.y) / len;

            let closestPoint;
            if (t < 0) {
                closestPoint = { ...a };
            } else if (t > 1) {
                closestPoint = { ...b };
            } else {
                closestPoint = { x: a.x + t * atob.x, y: a.y + t * atob.y };
            }

            const dx = p.x - closestPoint.x;
            const dy = p.y - closestPoint.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            return { point: closestPoint, distance: distance };
        }

        function updateSnapLine(draggedItem) { // Can be a point or a drawing object
            // Evitar que el símbolo de flecha se conecte automáticamente
            if (draggedItem.id && draggedItem.type === 'draw-mundo-interno' && draggedItem.symbolStyle === 'arrow') {
                snapLine = null;
                return;
            }

	        let draggedItemCenter;
	        let isSymbolToSnap = false;
	        let symbolToSnap = null; // Keep track of the actual symbol being dragged

            if (draggedItem.id && (draggedItem.type === 'draw-seccionador' || draggedItem.type === 'draw-ct')) {
                draggedItemCenter = draggedItem.start;
                isSymbolToSnap = true;
                symbolToSnap = draggedItem;
            } else if (draggedItem.id) { // another drawing object
                 if (draggedItem.type === 'draw-ground') {
                    draggedItemCenter = draggedItem.start;
                 } else {
                    const bbox = getEntityBBox(draggedItem, true);
                    if (bbox) {
                        draggedItemCenter = { x: bbox.x + bbox.width / 2, y: bbox.y + bbox.height / 2 };
                    } else {
                        draggedItemCenter = draggedItem.start; // fallback
                    }
                 }
            } else { // It's a point (e.g., center of multi-selection)
                draggedItemCenter = draggedItem;
            }
            if (!draggedItemCenter) return;


            let closestSnap = { point: null, distance: Infinity, segmentStart: null };
            const allLines = [...getVisibleLinesAndPolylines(), ...getVisibleUserDrawings().filter(d => d.type.includes('line'))];

            allLines.forEach(line => {
                if (line === draggedItem) return; // Don't snap to self if it's a line
                if (line.type === 'LINE' || line.type === 'draw-line' || line.type === 'draw-dashed-line') {
                    if (line.start && line.end) {
                        const { point, distance } = findClosestPointOnSegment(draggedItemCenter, line.start, line.end);
                        if (distance < closestSnap.distance) {
                            closestSnap = { point, distance, segmentStart: line.start };
                        }
                    }
                } else if ((line.type === 'LWPOLYLINE' || line.type === 'POLYLINE') && line.vertices) {
                    for (let i = 0; i < line.vertices.length - 1; i++) {
                        const p1 = line.vertices[i];
                        const p2 = line.vertices[i+1];
                        if (p1 && p2) {
                             const { point, distance } = findClosestPointOnSegment(draggedItemCenter, p1, p2);
                            if (distance < closestSnap.distance) {
                                closestSnap = { point, distance, segmentStart: p1 };
                            }
                        }
                    }
                     if (line.closed && line.vertices.length > 1) {
                        const p1 = line.vertices[line.vertices.length - 1];
                        const p2 = line.vertices[0];
                         if (p1 && p2) {
                            const { point, distance } = findClosestPointOnSegment(draggedItemCenter, p1, p2);
                            if (distance < closestSnap.distance) {
                                closestSnap = { point, distance, segmentStart: p1 };
                            }
                        }
                    }
                }
            });

            if (closestSnap.distance < SNAP_DISTANCE) {
                let snapEndPoint = draggedItemCenter; // Default endpoint is the center
                
                // If we are dragging a CT or a Seccionador
                if (isSymbolToSnap) {
                    let seccionadorToTest = null;
                    // Determine which symbol is the seccionador in the pair
                    if(symbolToSnap.type === 'draw-seccionador'){
                        seccionadorToTest = symbolToSnap;
                    } else if (symbolToSnap.type === 'draw-ct' && symbolToSnap.associatedSeccionadorId) {
                        seccionadorToTest = userDrawings.find(d => d.id === symbolToSnap.associatedSeccionadorId);
                    }
                    
                    // If we found the seccionador, calculate snap point from its rhombus vertices
                    if (seccionadorToTest) {
                        const drawing = seccionadorToTest;
                        const size = drawing.size;
                        const center = drawing.start;
                        const rotation = drawing.rotation || 0;
                        
                        // Vertices of the rhombus in local coordinates
                        const verticesToTest = [
                            {x: 0, y: -size},   
                            {x: size, y: 0},
                            {x: 0, y: size},
                            {x: -size, y: 0}
                        ];
    
                        const worldVertices = verticesToTest.map(v => {
                            const rotated = rotatePoint(v.x, v.y, 0, 0, rotation);
                            return { x: rotated.x + center.x, y: rotated.y + center.y };
                        });
    
                        let closestVertex = null;
                        let minVertexDist = Infinity;
                        const networkPoint = closestSnap.point;
    
                        worldVertices.forEach(wv => {
                            const dist = Math.sqrt(Math.pow(wv.x - networkPoint.x, 2) + Math.pow(wv.y - networkPoint.y, 2));
                            if (dist < minVertexDist) {
                                minVertexDist = dist;
                                closestVertex = wv;
                            }
                        });
    
                        if (closestVertex) {
                            snapEndPoint = closestVertex;
                        }
                    }
                }

                // For ground symbol, the snap line should always connect to the tip (start point)
                if (draggedItem.id && draggedItem.type === 'draw-ground') {
                    snapEndPoint = draggedItem.start;
                }

                snapLine = {
                    start: closestSnap.point,
                    end: snapEndPoint
                };
            } else {
                snapLine = null;
            }

	        }

		function getDisplayLabel(entity) {
			if (!entity || !entity.label) return '';
			if (entity.symbolType === 'ct') {
				const match = entity.label.match(/\d+/);
				if (match) return match[0];
			}
			return entity.label;
		}

		function populateSearchSuggestions() {
			searchSuggestions.innerHTML = '';
			const visibleTexts = new Set();

			getVisibleSymbols().forEach(s => {
				const displayLabel = getDisplayLabel(s);
				if (displayLabel) visibleTexts.add(displayLabel);
			});

			getVisibleUserDrawings().forEach(d => {
				if (d.label && (d.symbolType === 'ct' || d.symbolType === 'seccionador')) {
					const displayLabel = getDisplayLabel(d);
					if (displayLabel) visibleTexts.add(displayLabel);
				}
			});

			visibleTexts.forEach(text => {
				const option = document.createElement('option');
				option.value = text;
				searchSuggestions.appendChild(option);
			});
		}

		function panAndZoomToPoint(modelPoint) {
            const targetScale = Math.max(view.scale, 10); // Aumentado de 4 a 10 para un zoom más cercano
            view.scale = targetScale;

            const canvasContainer = document.getElementById('visualization-container');
            const centerX = canvasContainer.clientWidth / 2;
            const centerY = canvasContainer.clientHeight / 2;

            view.offsetX = centerX - (modelPoint.x - extents.minX) * view.scale;
            view.offsetY = centerY - (extents.maxY - modelPoint.y) * view.scale;

            draw();
        }



        function updateHistoryButtons() {
            undoBtn.disabled = undoStack.length <= 1;
            redoBtn.disabled = redoStack.length === 0;
        }

		function isEntityVisible(entity) {
			if (!activeSubgraphFilter) return true;
			return activeSubgraphFilter.visibleEntities.has(entity);
		}

		function getVisibleLinesAndPolylines() {
			return activeSubgraphFilter ? linesAndPolylines.filter(isEntityVisible) : linesAndPolylines;
		}

		function getVisibleSymbols() {
			return activeSubgraphFilter ? symbols.filter(isEntityVisible) : symbols;
		}

		function getVisibleUserDrawings() {
			return activeSubgraphFilter ? userDrawings.filter(isEntityVisible) : userDrawings;
		}

		function addToVisibleEntitiesIfFiltered(entity) {
			if (activeSubgraphFilter && activeSubgraphFilter.visibleEntities) {
				activeSubgraphFilter.visibleEntities.add(entity);
			}
		}

		function ensureGraphId(entity) {
			if (!entity) return null;
			if (!entity.__graphId) {
				entity.__graphId = crypto.randomUUID ? crypto.randomUUID() : `graph-${Math.random().toString(36).slice(2)}`;
			}
			return entity.__graphId;
		}

		function serializePoint(pt) {
			return `${pt.x.toFixed(3)},${pt.y.toFixed(3)}`;
		}

		function distanceSquared(p1, p2) {
			const dx = p1.x - p2.x;
			const dy = p1.y - p2.y;
			return dx * dx + dy * dy;
		}

		function findNearestNodeKey(point, graph, excludeKey = null) {
			let nearestKey = null;
			let minDist = Infinity;
			graph.forEach((node, key) => {
				if (excludeKey && key === excludeKey) return;
				const dist = distanceSquared(point, node.point);
				if (dist < minDist) {
					minDist = dist;
					nearestKey = key;
				}
			});
			return nearestKey ? { key: nearestKey, distance: Math.sqrt(minDist) } : null;
		}

		function buildGraphForSubgraph() {
			const graph = new Map();
			const symbolNodeKeyMap = new Map();

			const ensureNode = (point) => {
				const key = serializePoint(point);
				if (!graph.has(key)) {
					graph.set(key, { point: { ...point }, edges: [] });
				}
				return key;
			};

			const addEdge = (p1, p2, entity = null) => {
				const k1 = ensureNode(p1);
				const k2 = ensureNode(p2);
				graph.get(k1).edges.push({ to: k2, entity });
				graph.get(k2).edges.push({ to: k1, entity });
			};

			const networkLines = [
				...linesAndPolylines,
				...userDrawings.filter(d => d.type === 'draw-line' || d.type === 'draw-dashed-line')
			];

			networkLines.forEach(line => {
				if (line.type === 'LINE' && line.start && line.end) {
					addEdge(line.start, line.end, line);
				} else if ((line.type === 'LWPOLYLINE' || line.type === 'POLYLINE') && line.vertices && line.vertices.length > 1) {
					for (let i = 0; i < line.vertices.length - 1; i++) {
						if (line.vertices[i] && line.vertices[i + 1]) {
							addEdge(line.vertices[i], line.vertices[i + 1], line);
						}
					}
					if (line.closed && line.vertices[0] && line.vertices[line.vertices.length - 1]) {
						addEdge(line.vertices[line.vertices.length - 1], line.vertices[0], line);
					}
				}
			});

			const symbolLike = [
				...symbols.filter(s => s.symbolType === 'ct' || s.symbolType === 'seccionador'),
				...userDrawings.filter(d => d.symbolType === 'ct' || d.symbolType === 'seccionador')
			];

			symbolLike.forEach(sym => {
				const point = sym.position || sym.start;
				if (!point) return;
				const nodeKey = ensureNode(point);
				symbolNodeKeyMap.set(sym, nodeKey);
			});

			symbolNodeKeyMap.forEach((nodeKey, sym) => {
				const point = sym.position || sym.start;
				if (!point) return;
				const nearest = findNearestNodeKey(point, graph, nodeKey);
				if (nearest && nearest.distance <= SYMBOL_ATTACHMENT_DISTANCE) {
					addEdge(point, graph.get(nearest.key).point, sym);
				}
			});

			return { graph, symbolNodeKeyMap };
		}

		function collectSelectableNodes(graphData) {
			const options = [];
			let unnamedCounter = 1;

			const pushOption = (item, source) => {
				const nodeKey = graphData.symbolNodeKeyMap.get(item);
				if (!nodeKey) return;
				const label = getDisplayLabel(item) || `Nodo ${unnamedCounter++}`;
				options.push({
					id: ensureGraphId(item),
					label,
					nodeKey,
					source
				});
			};

			symbols.forEach((s) => {
				if (s.symbolType) {
					pushOption(s, 'dxf');
				}
			});

			userDrawings.forEach((d) => {
				if (d.symbolType || d.type === 'draw-ct' || d.type === 'draw-seccionador') {
					pushOption(d, 'manual');
				}
			});

			return options;
		}

		function traverseFromBoundary(startKey, boundarySet, graph) {
			const visited = new Set();
			const queue = [startKey];
			visited.add(startKey);

			while (queue.length > 0) {
				const currentKey = queue.shift();
				const node = graph.get(currentKey);
				if (!node) continue;

				node.edges.forEach(edge => {
					if (boundarySet.has(currentKey) && boundarySet.has(edge.to) && edge.to !== startKey) {
						visited.add(edge.to);
						return;
					}

					if (!visited.has(edge.to)) {
						visited.add(edge.to);
						if (!(boundarySet.has(edge.to) && edge.to !== startKey)) {
							queue.push(edge.to);
						}
					}
				});
			}
			return visited;
		}

		function computeIntersection(sets) {
			if (!sets || sets.length === 0) return new Set();
			let intersection = new Set(sets[0]);
			for (let i = 1; i < sets.length; i++) {
				const current = sets[i];
				intersection = new Set([...intersection].filter(x => current.has(x)));
				if (intersection.size === 0) break;
			}
			return intersection;
		}

		function includeContextualDrawings(intersectionNodes, graphData, visibleEntities) {
			const contextualDrawings = userDrawings.filter(d => !visibleEntities.has(d) && !['draw-line', 'draw-dashed-line', 'draw-ct', 'draw-seccionador'].includes(d.type));
			contextualDrawings.forEach(d => {
				const anchor = d.start || d.position;
				if (!anchor) return;
				const nearest = findNearestNodeKey(anchor, graphData.graph);
				if (nearest && intersectionNodes.has(nearest.key) && nearest.distance <= SYMBOL_ATTACHMENT_DISTANCE) {
					visibleEntities.add(d);
				}
			});
		}

		function applySubgraphFilterWithNodes(selectedNodeKeys, graphData) {
			if (!graphData) {
				graphData = buildGraphForSubgraph();
			}

				if (selectedNodeKeys.length < 2) {
					showConfirm('Selecciona al menos dos puntos para construir el subgrafo.', () => {});
					return;
				}

				if (graphData.graph.size === 0) {
					showConfirm('No hay datos de red para generar el subgrafo.', () => {});
					return;
				}

			const boundarySet = new Set(selectedNodeKeys);
			const reachabilitySets = selectedNodeKeys.map(nodeKey => traverseFromBoundary(nodeKey, boundarySet, graphData.graph));
			const intersectionNodes = computeIntersection(reachabilitySets);

			if (intersectionNodes.size === 0) {
				showConfirm('No se encontró un tramo común entre los puntos seleccionados.', () => {});
				return;
			}

			const visibleEntities = new Set();

			graphData.graph.forEach((node, key) => {
				node.edges.forEach(edge => {
					if (edge.entity && intersectionNodes.has(key) && intersectionNodes.has(edge.to)) {
						visibleEntities.add(edge.entity);
					}
				});
			});

			graphData.symbolNodeKeyMap.forEach((nodeKey, sym) => {
				if (intersectionNodes.has(nodeKey)) {
					visibleEntities.add(sym);
				}
			});

			includeContextualDrawings(intersectionNodes, graphData, visibleEntities);

			if (visibleEntities.size === 0) {
				showConfirm('El subgrafo está vacío con la selección actual.', () => {});
				return;
			}

			activeSubgraphFilter = {
				visibleEntities,
				selectedNodes: selectedNodeKeys
			};

			selectedEntity = null;
			selectedDrawingId = null;
			multiSelection = [];
			updateInfoPanel(null);
			updateInfoPanelForDrawing(null);
			updateSubgraphUiState(true);
			computeExtents();
			fitViewToExtents();
			populateSearchSuggestions();
			draw();
		}

		function clearSubgraphFilter() {
			if (!activeSubgraphFilter) return;
			activeSubgraphFilter = null;
			selectedEntity = null;
			selectedDrawingId = null;
			multiSelection = [];
			updateInfoPanel(null);
			updateInfoPanelForDrawing(null);
			updateSubgraphUiState(false);
			computeExtents();
			fitViewToExtents();
			populateSearchSuggestions();
			draw();
		}

		function updateSubgraphUiState(isActive) {
			if (!subgraphStatus) return;
			if (isActive) {
				subgraphStatus.classList.remove('hidden');
				if (clearSubgraphFilterBtn) {
					clearSubgraphFilterBtn.classList.remove('opacity-50', 'cursor-not-allowed');
					clearSubgraphFilterBtn.disabled = false;
				}
			} else {
				subgraphStatus.classList.add('hidden');
				if (clearSubgraphFilterBtn) {
					clearSubgraphFilterBtn.classList.add('opacity-50', 'cursor-not-allowed');
					clearSubgraphFilterBtn.disabled = true;
				}
			}
		}

		function renderSubgraphOptions(graphData) {
			subgraphPointsList.innerHTML = '';
			const options = collectSelectableNodes(graphData);

			if (options.length < 2) {
				const emptyState = document.createElement('div');
				emptyState.className = 'p-4 text-sm text-gray-600 text-center';
				emptyState.textContent = options.length === 0
					? 'No hay elementos seleccionables disponibles. Asegúrate de tener puntos de red cargados.'
					: 'Selecciona al menos dos puntos para construir el subgrafo.';
				subgraphPointsList.appendChild(emptyState);
				applySubgraphBtn.disabled = true;
				return;
			}

			applySubgraphBtn.disabled = false;
			options.sort((a, b) => a.label.localeCompare(b.label));

				options.forEach((opt, idx) => {
					const row = document.createElement('label');
					row.className = 'flex items-center justify-between px-4 py-3 bg-white hover:bg-gray-50';
					const left = document.createElement('div');
					left.className = 'flex items-center gap-3';

					const checkbox = document.createElement('input');
					checkbox.type = 'checkbox';
					checkbox.value = opt.nodeKey;
					checkbox.className = 'h-4 w-4 text-emerald-600 border-gray-300 rounded focus:ring-emerald-500';
					if (idx < 2) checkbox.checked = true;

					const label = document.createElement('div');
					label.className = 'flex flex-col';
					label.innerHTML = `<span class="text-sm font-semibold text-gray-800">${opt.label}</span><span class="text-xs text-gray-500">${opt.source === 'manual' ? 'Manual' : 'DXF'}</span>`;

				left.appendChild(checkbox);
				left.appendChild(label);

				row.appendChild(left);
				subgraphPointsList.appendChild(row);
			});
		}
		
			function showInputPrompt(message, callback, defaultValue = '') {
				const container = document.getElementById('message-box-container');
				container.innerHTML = ''; // Clear previous messages

			const promptBox = document.createElement('div');
			promptBox.className = 'message-box';

			const messageP = document.createElement('p');
			messageP.textContent = message;
			messageP.className = 'mb-4 text-lg';

			const inputBox = document.createElement('input');
			inputBox.type = 'text';
			inputBox.className = 'w-full p-2 border border-gray-300 rounded-md';
			inputBox.value = defaultValue;

			const confirmBtn = document.createElement('button');
			confirmBtn.textContent = 'Aceptar';
			confirmBtn.className = 'btn-confirm';

			const cancelBtn = document.createElement('button');
			cancelBtn.textContent = 'Cancelar';
			cancelBtn.className = 'btn-cancel';

			const closePrompt = () => {
				container.innerHTML = '';
			};

			confirmBtn.onclick = () => {
				callback(inputBox.value);
				closePrompt();
			};

			cancelBtn.onclick = () => {
				callback(null); // Or handle cancellation as needed
				closePrompt();
			};
			
			inputBox.addEventListener('keydown', (e) => {
				if (e.key === 'Enter') {
					confirmBtn.click();
				} else if (e.key === 'Escape') {
					cancelBtn.click();
				}
			});

			promptBox.appendChild(messageP);
			promptBox.appendChild(inputBox);
			promptBox.appendChild(confirmBtn);
			promptBox.appendChild(cancelBtn);

				container.appendChild(promptBox);
				inputBox.focus();
			}

			function showTextResizePrompt(defaultValue, onConfirm) {
				const container = document.getElementById('message-box-container');
				container.innerHTML = '';

				const parsedDefault = !isNaN(parseFloat(defaultValue)) ? parseFloat(defaultValue) : 100;
				const min = 50;
				const max = 200;

				const clampValue = (val) => Math.min(max, Math.max(min, val || parsedDefault));

				const box = document.createElement('div');
				box.className = 'message-box';

				const messageP = document.createElement('p');
				messageP.textContent = 'Introduzca el porcentaje de tamaño del texto (ej: 120 para 20% más grande, 80 para 20% más pequeño)';
				messageP.className = 'mb-4 text-lg leading-relaxed';

				const controlsWrapper = document.createElement('div');
				controlsWrapper.className = 'space-y-3';

				const slider = document.createElement('input');
				slider.type = 'range';
				slider.min = `${min}`;
				slider.max = `${max}`;
				slider.step = '5';
				slider.value = `${clampValue(parsedDefault)}`;
				slider.className = 'w-full accent-blue-600';

				const numberInput = document.createElement('input');
				numberInput.type = 'number';
				numberInput.min = `${min}`;
				numberInput.max = `${max}`;
				numberInput.step = '1';
				numberInput.value = `${clampValue(parsedDefault)}`;
				numberInput.className = 'w-full p-2 border border-gray-300 rounded-md';

				const presetsContainer = document.createElement('div');
				presetsContainer.className = 'flex flex-wrap gap-2';
					const presetValues = [50, 75, 90, 100, 110, 125, 150, 200];
					presetValues.forEach(val => {
						const btn = document.createElement('button');
						btn.type = 'button';
						btn.textContent = `${val}%`;
						btn.className = 'preset-btn text-sm rounded transition-colors';
						btn.addEventListener('click', () => setValue(val));
						presetsContainer.appendChild(btn);
					});

					const adjustContainer = document.createElement('div');
					adjustContainer.className = 'flex gap-2';
					const minusBtn = document.createElement('button');
					minusBtn.type = 'button';
					minusBtn.textContent = '-10%';
					minusBtn.className = 'adjust-btn flex-1 rounded transition-colors';
					minusBtn.addEventListener('click', () => setValue(clampValue(parseFloat(numberInput.value) - 10)));

					const plusBtn = document.createElement('button');
					plusBtn.type = 'button';
					plusBtn.textContent = '+10%';
					plusBtn.className = 'adjust-btn flex-1 rounded transition-colors';
					plusBtn.addEventListener('click', () => setValue(clampValue(parseFloat(numberInput.value) + 10)));

				adjustContainer.appendChild(minusBtn);
				adjustContainer.appendChild(plusBtn);

				const errorText = document.createElement('p');
				errorText.className = 'text-sm text-red-600 hidden';
				errorText.textContent = `El porcentaje debe estar entre ${min}% y ${max}%`;

				const actions = document.createElement('div');
				actions.className = 'mt-4 flex justify-center gap-3';

				const confirmBtn = document.createElement('button');
				confirmBtn.textContent = 'Aceptar';
				confirmBtn.className = 'btn-confirm';

				const cancelBtn = document.createElement('button');
				cancelBtn.textContent = 'Cancelar';
				cancelBtn.className = 'btn-cancel';

				const setValue = (val) => {
					const clamped = clampValue(parseFloat(val));
					slider.value = `${clamped}`;
					numberInput.value = `${clamped}`;
					errorText.classList.add('hidden');
				};

				slider.addEventListener('input', (e) => setValue(parseFloat(e.target.value)));
				numberInput.addEventListener('input', (e) => {
					const parsed = parseFloat(e.target.value);
					if (isNaN(parsed)) return;
					setValue(parsed);
				});

				const closePrompt = () => {
					container.innerHTML = '';
				};

				const handleConfirm = () => {
					const value = clampValue(parseFloat(numberInput.value));
					if (isNaN(value)) {
						errorText.classList.remove('hidden');
						return;
					}
					onConfirm(value);
					closePrompt();
				};

				confirmBtn.addEventListener('click', handleConfirm);
				cancelBtn.addEventListener('click', closePrompt);

				numberInput.addEventListener('keydown', (e) => {
					if (e.key === 'Enter') {
						handleConfirm();
					} else if (e.key === 'Escape') {
						closePrompt();
					}
				});

				controlsWrapper.appendChild(slider);
				controlsWrapper.appendChild(numberInput);
				controlsWrapper.appendChild(presetsContainer);
				controlsWrapper.appendChild(adjustContainer);
				controlsWrapper.appendChild(errorText);

				actions.appendChild(confirmBtn);
				actions.appendChild(cancelBtn);

				box.appendChild(messageP);
				box.appendChild(controlsWrapper);
				box.appendChild(actions);

				container.appendChild(box);
				numberInput.focus();
			}

		function showConfirm(message, onConfirm, onCancel = () => {}) {
			const container = document.getElementById('message-box-container');
			container.innerHTML = '';

			const confirmBox = document.createElement('div');
			confirmBox.className = 'message-box';
			
			const messageP = document.createElement('p');
			messageP.textContent = message;
			messageP.className = 'mb-4 text-lg';

			const confirmBtn = document.createElement('button');
			confirmBtn.textContent = 'Confirmar';
			confirmBtn.className = 'btn-danger';

			const cancelBtn = document.createElement('button');
			cancelBtn.textContent = 'Cancelar';
			cancelBtn.className = 'btn-cancel';
			
			const closeConfirm = () => container.innerHTML = '';

			confirmBtn.onclick = () => {
				onConfirm();
				closeConfirm();
			};
			cancelBtn.onclick = () => {
				onCancel();
				closeConfirm();
			};

			confirmBox.appendChild(messageP);
			confirmBox.appendChild(confirmBtn);
			confirmBox.appendChild(cancelBtn);
			container.appendChild(confirmBox);
		}

		function drawCtIcon(ctx, iconType, pos, size, yOffset, resolutionFactor = 1) {
			switch (iconType) {
				case 'plain':
					// Do nothing, just the grey square will be visible
					break;
				case 'solid-circle':
					ctx.beginPath();
					ctx.arc(pos.x, pos.y + yOffset, size * 0.8, 0, 2 * Math.PI);
					ctx.stroke();
					break;
				case 'dotted-circle':
					ctx.save();
					ctx.setLineDash([2 * resolutionFactor, 3 * resolutionFactor]);
					ctx.beginPath();
					ctx.arc(pos.x, pos.y + yOffset, size * 0.8, 0, 2 * Math.PI);
					ctx.stroke();
					ctx.restore();
					break;
				case 'pp-circle':
					ctx.save();
					ctx.setLineDash([2 * resolutionFactor, 3 * resolutionFactor]);
					ctx.beginPath();
					ctx.arc(pos.x, pos.y + yOffset, size * 0.8, 0, 2 * Math.PI);
					ctx.stroke();
					ctx.restore();
					const fontSize = size * 0.45;
					ctx.font = `bold ${fontSize}px Inter, sans-serif`;
					ctx.fillStyle = SYMBOL_STROKE_COLOR;
					ctx.textAlign = 'center';
					ctx.textBaseline = 'middle';
					ctx.fillText('PP', pos.x, pos.y + yOffset);
					break;
				case 'pp-solid-circle':
					ctx.beginPath();
					ctx.arc(pos.x, pos.y + yOffset, size * 0.8, 0, 2 * Math.PI);
					ctx.stroke();
					const fontSizeSolid = size * 0.45;
					ctx.font = `bold ${fontSizeSolid}px Inter, sans-serif`;
					ctx.fillStyle = SYMBOL_STROKE_COLOR;
					ctx.textAlign = 'center';
					ctx.textBaseline = 'middle';
					ctx.fillText('PP', pos.x, pos.y + yOffset);
					break;
				case 'parallel-lines-circle':
					ctx.beginPath();
					ctx.arc(pos.x, pos.y + yOffset, size * 0.8, 0, 2 * Math.PI);
					// Top line
					ctx.moveTo(pos.x - size * 0.5, pos.y + yOffset - size * 0.25);
					ctx.lineTo(pos.x + size * 0.5, pos.y + yOffset - size * 0.25);
					// Bottom line
					ctx.moveTo(pos.x - size * 0.5, pos.y + yOffset + size * 0.25);
					ctx.lineTo(pos.x + size * 0.5, pos.y + yOffset + size * 0.25);
					ctx.stroke();
					break;
				case 'pp-parallel-lines-circle':
					ctx.beginPath();
					ctx.arc(pos.x, pos.y + yOffset, size * 0.8, 0, 2 * Math.PI);
					// Top line
					ctx.moveTo(pos.x - size * 0.6, pos.y + yOffset - size * 0.3);
					ctx.lineTo(pos.x + size * 0.6, pos.y + yOffset - size * 0.3);
					// Bottom line
					ctx.moveTo(pos.x - size * 0.6, pos.y + yOffset + size * 0.3);
					ctx.lineTo(pos.x + size * 0.6, pos.y + yOffset + size * 0.3);
					ctx.stroke();
					const fontSizePPParallel = size * 0.45;
					ctx.font = `bold ${fontSizePPParallel}px Inter, sans-serif`;
					ctx.fillStyle = SYMBOL_STROKE_COLOR;
					ctx.textAlign = 'center';
					ctx.textBaseline = 'middle';
					ctx.fillText('PP', pos.x, pos.y + yOffset);
					break;
				case 'hexagon':
					ctx.beginPath();
					const outerRadiusHex = size * 0.9;
					for (let i = 0; i < 6; i++) {
						const angle = (Math.PI / 3) * i; // flat top/bottom
						const x = pos.x + outerRadiusHex * Math.cos(angle);
						const y = pos.y + yOffset + outerRadiusHex * Math.sin(angle);
						if (i === 0) ctx.moveTo(x, y);
						else ctx.lineTo(x, y);
					}
					ctx.closePath();
					ctx.stroke();

					ctx.save();
					ctx.setLineDash([3 * resolutionFactor, 3 * resolutionFactor]);
					ctx.beginPath();
					const innerRadiusHex = size * 0.7;
						for (let i = 0; i < 6; i++) {
						const angle = (Math.PI / 3) * i; // flat top/bottom
						const x = pos.x + innerRadiusHex * Math.cos(angle);
						const y = pos.y + yOffset + innerRadiusHex * Math.sin(angle);
						if (i === 0) ctx.moveTo(x, y);
						else ctx.lineTo(x, y);
					}
					ctx.closePath();
					ctx.stroke();
					ctx.restore();
					break;
				case 'switch':
					const switchY = pos.y + yOffset;
					const pivotX = pos.x + size * 0.2; // Pivot point on the right
					const contactX = pos.x - size * 0.2; // Contact point on the left
					const armEndX = pos.x - size * 0.1; 
					const armEndY = pos.y + yOffset - size * 0.6; // Angled up

					ctx.beginPath();
					// Left terminal
					ctx.moveTo(pos.x - size * 0.9, switchY);
					ctx.lineTo(contactX, switchY);

					// Right terminal
					ctx.moveTo(pos.x + size * 0.9, switchY);
					ctx.lineTo(pivotX, switchY);

					// Arm
					ctx.moveTo(pivotX, switchY);
					ctx.lineTo(armEndX, armEndY);

					ctx.stroke();
					break;

                                case 'uni-subterraneo':
					// Dibuja el triángulo inferior-derecho oscuro
					ctx.fillStyle = SYMBOL_STROKE_COLOR; // Usa el color oscuro del borde
					ctx.beginPath();
					ctx.moveTo(pos.x - size, pos.y + yOffset + size); // Esquina inferior-izquierda
					ctx.lineTo(pos.x + size, pos.y + yOffset - size); // Esquina superior-derecha
					ctx.lineTo(pos.x + size, pos.y + yOffset + size); // Esquina inferior-derecha
					ctx.closePath();
					ctx.fill();
					break;

				case 'rhombus':
					ctx.beginPath();
					ctx.moveTo(pos.x, pos.y + yOffset - size * 0.9);
					ctx.lineTo(pos.x + size * 0.9, pos.y + yOffset);
					ctx.lineTo(pos.x, pos.y + yOffset + size * 0.9);
					ctx.lineTo(pos.x - size * 0.9, pos.y + yOffset);
					ctx.closePath();
					ctx.stroke();
					break;
				case 'circle-rhombus':
					ctx.beginPath();
					const radiusCR = size * 0.8;
					ctx.arc(pos.x, pos.y + yOffset, radiusCR, 0, 2 * Math.PI);
					
					// Rhombus inside
					ctx.moveTo(pos.x, pos.y + yOffset - radiusCR); // Top
					ctx.lineTo(pos.x + radiusCR, pos.y + yOffset); // Right
					ctx.lineTo(pos.x, pos.y + yOffset + radiusCR); // Bottom
					ctx.lineTo(pos.x - radiusCR, pos.y + yOffset); // Left
					ctx.closePath();
					ctx.stroke();
					break;
				case 'triangle':
				default:
					const triangleWidth = size * 1.6;
					const triangleHeight = triangleWidth * Math.sqrt(3) / 2;
					const topY = pos.y + yOffset - triangleHeight / 2;
					const bottomY = pos.y + yOffset + triangleHeight / 2;
					ctx.beginPath();
					ctx.moveTo(pos.x, topY); // Top point
					ctx.lineTo(pos.x + triangleWidth / 2, bottomY); // Bottom right
					ctx.lineTo(pos.x - triangleWidth / 2, bottomY); // Bottom left
					ctx.closePath();
					ctx.stroke();
					break;
			}
		}

		function restoreState(state) {
			extents = JSON.parse(JSON.stringify(state.extents));
			view = JSON.parse(JSON.stringify(state.view)); // Restaurar la vista para que el zoom/pan se deshaga correctamente
			originalExtents = state.originalExtents ? JSON.parse(JSON.stringify(state.originalExtents)) : null;
			userDrawings = JSON.parse(JSON.stringify(state.userDrawings));
			symbols = JSON.parse(JSON.stringify(state.symbols));
			linesAndPolylines = JSON.parse(JSON.stringify(state.linesAndPolylines));
			isManualModeEnabled = state.isManualModeEnabled || false;

			// Update UI based on restored state
			manualModeToggle.checked = isManualModeEnabled;
			updateManualModeTitle();

			if (originalExtents) {
				resetViewBtn.classList.remove('hidden');
			} else {
				resetViewBtn.classList.add('hidden');
			}
			clearDrawingsBtn.disabled = userDrawings.length === 0;

			// Deselect everything on state change for simplicity
			selectedDrawingId = null;
			selectedEntity = null;
			multiSelection = [];
			updateInfoPanel(null);
			updateInfoPanelForDrawing(null);

			draw();
		}

		function undo() {
			if (undoStack.length <= 1) return; // Can't undo the very first state

			const currentState = undoStack.pop();
			redoStack.push(currentState);

			const stateToRestore = undoStack[undoStack.length - 1];
			restoreState(stateToRestore); // No need to deep copy here, restoreState does it.
			
			updateHistoryButtons();
		}

		function redo() {
			if (redoStack.length === 0) return;

			const stateToRestore = redoStack.pop();
			undoStack.push(stateToRestore);

			restoreState(stateToRestore); // No need to deep copy here, restoreState does it.

			updateHistoryButtons();
		}
		
		function saveHistoryState() {
                        /*
                         * When storing state for undo/redo we need to create deep copies of the
                         * current data structures.  Using JSON.parse(JSON.stringify(...)) works
                         * for simple, acyclic objects but can be extremely expensive for large
                         * DXF files or complex drawings.  Modern browsers support the
                         * `structuredClone` API which performs a deep clone efficiently and
                         * correctly handles circular references.  We fall back to the JSON
                         * method if `structuredClone` is unavailable.
                         */
                        function safeClone(obj) {
                            try {
                                // structuredClone may throw if the environment doesn’t support it
                                return (typeof structuredClone === 'function') ? structuredClone(obj) : JSON.parse(JSON.stringify(obj));
                            } catch (ex) {
                                // If cloning fails (e.g. circular references), attempt JSON cloning as a last resort
                                return JSON.parse(JSON.stringify(obj));
                            }
                        }
                        const state = {
                                extents: safeClone(extents),
                                view: safeClone(view),
                                originalExtents: originalExtents ? safeClone(originalExtents) : null,
                                userDrawings: safeClone(userDrawings),
                                symbols: safeClone(symbols),
                                linesAndPolylines: safeClone(linesAndPolylines),
                                isManualModeEnabled: isManualModeEnabled,
                        };
                        undoStack.push(state);
                        redoStack = []; // A new action clears the redo stack.
                        updateHistoryButtons();
                }

		function getDashPatternForLinetype(linetype) {
            if (!linetype) return null;

            const ltype = linetype.toUpperCase();
            
            const fixedDashPattern = [5, 5];

            // Apply the fixed pattern to all non-continuous line types from the DXF
            if (ltype.includes('DASHED') ||
                ltype.includes('HIDDEN') ||
                ltype.includes('CENTER') ||
                ltype.includes('PHANTOM') ||
                ltype.includes('DOT') ||
                ltype.includes('DIVIDE')) {
                return fixedDashPattern;
            }
            
            return null; // For continuous/solid lines
        }

        /**
         * Show a confirmation box with two possible actions.  This helper is
         * similar to `showConfirm` but allows the caller to specify two
         * buttons with distinct callbacks.  It is used when the user
         * attempts to delete a selection and must choose whether to
         * remove just the selected items or everything else.
         *
         * @param {string} message      The message to display to the user.
         * @param {string} option1Label Label for the first action button.
         * @param {string} option2Label Label for the second action button.
         * @param {Function} onOption1  Callback when the first button is clicked.
         * @param {Function} onOption2  Callback when the second button is clicked.
         * @param {Function} onCancel    Callback when the dialog is cancelled.
         */
        function showDualConfirm(message, option1Label, option2Label, onOption1, onOption2, onCancel = () => {}) {
            const container = document.getElementById('message-box-container');
            container.innerHTML = '';

            const confirmBox = document.createElement('div');
            confirmBox.className = 'message-box';

            const messageP = document.createElement('p');
            messageP.textContent = message;
            messageP.className = 'mb-4 text-lg';

            const btn1 = document.createElement('button');
            btn1.textContent = option1Label;
            btn1.className = 'btn-danger mr-2';

            const btn2 = document.createElement('button');
            btn2.textContent = option2Label;
            btn2.className = 'btn-warning mr-2';

            const cancelBtn = document.createElement('button');
            cancelBtn.textContent = 'Cancelar';
            cancelBtn.className = 'btn-cancel';

            const closeConfirm = () => container.innerHTML = '';

            btn1.onclick = () => {
                onOption1();
                closeConfirm();
            };
            btn2.onclick = () => {
                onOption2();
                closeConfirm();
            };
            cancelBtn.onclick = () => {
                onCancel();
                closeConfirm();
            };

            confirmBox.appendChild(messageP);
            confirmBox.appendChild(btn1);
            confirmBox.appendChild(btn2);
            confirmBox.appendChild(cancelBtn);
            container.appendChild(confirmBox);
        }

		function formatBytes(bytes) {
			if (!bytes || isNaN(bytes)) return '—';
			const units = ['B', 'KB', 'MB', 'GB'];
			let size = bytes;
			let unitIndex = 0;
			while (size >= 1024 && unitIndex < units.length - 1) {
				size /= 1024;
				unitIndex++;
			}
			return `${size.toFixed(size >= 10 || unitIndex === 0 ? 0 : 1)} ${units[unitIndex]}`;
		}

		function getSelectedExportOptions() {
			const scaleValue = parseFloat((exportResolutionSelect && exportResolutionSelect.value) || exportOptions.scale || 1);
			const sanitizedScale = isNaN(scaleValue) || scaleValue <= 0 ? 1 : scaleValue;
			return {
				format: (exportFormatSelect && exportFormatSelect.value) || exportOptions.format || 'png',
				scale: sanitizedScale,
				backgroundColor: (exportBgColorInput && exportBgColorInput.value) || exportOptions.backgroundColor || '#f0f0f0'
			};
		}

		function updateExportMeta(width, height, blobSize) {
			if (exportDimensionsLabel) {
				exportDimensionsLabel.textContent = `Dimensiones: ${Math.round(width)} x ${Math.round(height)} px · ${exportOptions.format.toUpperCase()} · ${exportOptions.scale}x`;
			}
			if (exportSizeLabel) {
				exportSizeLabel.textContent = `Tamaño estimado: ${formatBytes(blobSize)}`;
			}
		}

		function toggleExportLoading(isLoading) {
			if (exportPreviewLoading) {
				exportPreviewLoading.classList.toggle('hidden', !isLoading);
			}
			if (copyToClipboardBtn) copyToClipboardBtn.disabled = isLoading;
			if (downloadImageBtn) downloadImageBtn.disabled = isLoading;
		}

		async function createDiagramImage(options = {}) {
			const { format = 'png', scale = 1, backgroundColor = '#f0f0f0' } = options;
			const tempCanvas = document.createElement('canvas');
			const tempCtx = tempCanvas.getContext('2d');

			const sourceCanvas = dxfCanvas;
			const outputWidth = Math.max(1, Math.round(sourceCanvas.width * scale));
			const outputHeight = Math.max(1, Math.round(sourceCanvas.height * scale));

			tempCanvas.width = outputWidth;
			tempCanvas.height = outputHeight;

            // Primero, rellenar el lienzo temporal con el mismo color de fondo que el lienzo principal.
            // Esto asegura que el fondo sea correcto incluso si el origen tiene áreas transparentes.
            tempCtx.fillStyle = backgroundColor || '#f0f0f0';
            tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);

			// Dibujar el lienzo principal sobre el temporal. Esta es una copia de píxeles 1:1.
			tempCtx.drawImage(sourceCanvas, 0, 0, outputWidth, outputHeight);

			if (format === 'svg') {
				const pngDataUrl = tempCanvas.toDataURL('image/png');
				const svgContent = `<svg xmlns="http://www.w3.org/2000/svg" width="${outputWidth}" height="${outputHeight}" viewBox="0 0 ${outputWidth} ${outputHeight}"><rect width="100%" height="100%" fill="${backgroundColor}"/><image href="${pngDataUrl}" width="${outputWidth}" height="${outputHeight}" preserveAspectRatio="xMidYMid meet"/></svg>`;
				const svgBlob = new Blob([svgContent], { type: 'image/svg+xml' });
				const svgDataUrl = `data:image/svg+xml;base64,${btoa(unescape(encodeURIComponent(svgContent)))}`;
				return { dataUrl: svgDataUrl, blob: svgBlob, width: outputWidth, height: outputHeight, options: { format, scale, backgroundColor } };
			}

			const dataUrl = tempCanvas.toDataURL('image/png');
			const blob = await (await fetch(dataUrl)).blob();

			return { dataUrl, blob, width: outputWidth, height: outputHeight, options: { format, scale, backgroundColor } };
		}

		function showCopyImageModal(exportData) {
			if (!exportData) return;
			currentExportDataUrl = exportData.dataUrl;
			currentExportBlob = exportData.blob;
			exportOptions = { ...exportOptions, ...exportData.options, width: exportData.width, height: exportData.height };

			imageToCopy.src = exportData.dataUrl;
			updateExportMeta(exportData.width, exportData.height, exportData.blob ? exportData.blob.size : 0);

			copyImageModal.classList.remove('hidden');
			copyImageModal.classList.add('flex');
		}

		function setClipboardNotice(message, tone = 'warning') {
			if (!clipboardNotice) return;
			const toneClasses = {
				success: ['bg-green-50', 'text-green-700', 'border-green-200'],
				error: ['bg-red-50', 'text-red-700', 'border-red-200'],
				warning: ['bg-yellow-50', 'text-yellow-700', 'border-yellow-200']
			};
			clipboardNotice.textContent = message;
			clipboardNotice.classList.remove('hidden', 'bg-yellow-50', 'text-yellow-700', 'border-yellow-200', 'bg-green-50', 'text-green-700', 'border-green-200', 'bg-red-50', 'text-red-700', 'border-red-200');
			clipboardNotice.classList.add(...(toneClasses[tone] || toneClasses.warning));
		}

		function clearClipboardNotice() {
			if (!clipboardNotice) return;
			clipboardNotice.classList.add('hidden');
		}

		async function refreshExportPreview(openModal = false) {
			const shouldShow = openModal || !copyImageModal.classList.contains('hidden');
			if (!shouldShow) return;

			exportOptions = { ...exportOptions, ...getSelectedExportOptions() };

			if (openModal) {
				copyImageModal.classList.remove('hidden');
				copyImageModal.classList.add('flex');
			}

			toggleExportLoading(true);

			try {
				const exportData = await createDiagramImage(exportOptions);
				if (openModal || !copyImageModal.classList.contains('hidden')) {
					showCopyImageModal(exportData);
					clearClipboardNotice();
				}
			} catch (error) {
				console.error('Error generando la imagen de exportación', error);
				setClipboardNotice('No se pudo generar la vista previa. Intenta nuevamente.', 'error');
			} finally {
				toggleExportLoading(false);
			}
		}

		async function copyImageToClipboard() {
			if (!currentExportDataUrl) {
				setClipboardNotice('Genera primero la vista previa para copiarla.', 'warning');
				return;
			}

			if (!navigator.clipboard || typeof ClipboardItem === 'undefined') {
				setClipboardNotice('El navegador no permite copiar al portapapeles. Se iniciará una descarga como alternativa.', 'warning');
				downloadCurrentImage();
				return;
			}

			try {
				const mimeType = exportOptions.format === 'svg' ? 'image/svg+xml' : 'image/png';
				const blob = currentExportBlob || await (await fetch(currentExportDataUrl)).blob();
				await navigator.clipboard.write([new ClipboardItem({ [mimeType]: blob })]);
				setClipboardNotice('Imagen copiada al portapapeles.', 'success');
			} catch (error) {
				console.error('No fue posible copiar al portapapeles', error);
				setClipboardNotice('El navegador bloqueó el portapapeles. Se iniciará una descarga como alternativa.', 'error');
				downloadCurrentImage();
			}
		}

		function downloadCurrentImage() {
			if (!currentExportDataUrl) {
				setClipboardNotice('Genera la vista previa antes de descargar.', 'warning');
				return;
			}

			const extension = (exportOptions.format || 'png').toLowerCase() === 'svg' ? 'svg' : 'png';
			const filename = `esquemapp.${extension}`;
			const link = document.createElement('a');

			if (currentExportBlob && URL.createObjectURL) {
				const blobUrl = URL.createObjectURL(currentExportBlob);
				link.href = blobUrl;
				link.download = filename;
				document.body.appendChild(link);
				link.click();
				document.body.removeChild(link);
				URL.revokeObjectURL(blobUrl);
			} else {
				link.href = currentExportDataUrl;
				link.download = filename;
				document.body.appendChild(link);
				link.click();
				document.body.removeChild(link);
			}
		}

		function modelToScreen(modelX, modelY) {
            const screenX = ((modelX - extents.minX) * view.scale) + view.offsetX;
            const screenY = ((extents.maxY - modelY) * view.scale) + view.offsetY;
            return { x: screenX, y: screenY };
        }

		function screenToModel(sx, sy) {
			const mx = ((sx - view.offsetX) / view.scale) + extents.minX;
			const my = extents.maxY - ((sy - view.offsetY) / view.scale);
			return { x: mx, y: my };
    	}

		function fitViewToExtents() {
			const canvasContainer = document.getElementById('visualization-container');
			const containerWidth = canvasContainer.clientWidth;
			const containerHeight = canvasContainer.clientHeight;
			if ((extents.maxX - extents.minX) <= 1e-9 || (extents.maxY - extents.minY) <= 1e-9) {
				view.scale = 1;
				view.offsetX = containerWidth / 2;
				view.offsetY = containerHeight / 2;
				return;
			}
			view.scale = Math.min(containerWidth / (extents.maxX - extents.minX), containerHeight / (extents.maxY - extents.minY)) * 0.95; // 5% padding
			view.offsetX = (containerWidth - (extents.maxX - extents.minX) * view.scale) / 2;
			view.offsetY = (containerHeight - (extents.maxY - extents.minY) * view.scale) / 2;
    	}

		function setActiveTool(activeBtn) {
			// Deactivate all tool buttons except for the manual mode toggle
			toolBtns.forEach(btn => {
				if (btn.id !== 'toggle-manual-mode-btn') {
					btn.classList.remove('active');
				}
			});

			if (activeBtn) {
				activeBtn.classList.add('active');
				const tool = activeBtn.id.replace('-btn', '');
				currentTool = tool; 
				dxfCanvas.style.cursor = ['crop', 'marquee-select'].includes(currentTool) || currentTool.startsWith('draw-') ? 'crosshair' : 'grab';
			} else {
				currentTool = 'pan';
				dxfCanvas.style.cursor = 'grab';
			}
    	}

        function rotatePoint(px, py, cx, cy, angleDeg) {
            const rad = angleDeg * Math.PI / 180;
            const cos = Math.cos(rad);
            const sin = Math.sin(rad);
            const dx = px - cx;
            const dy = py - cy;
            return {
                x: cx + dx * cos - dy * sin,
                y: cy + dx * sin + dy * cos
            };
        }
       
        function parseBlockDescriptions(dxfString) {
            const map = {};
            const lines = dxfString.split(/\r?\n/);
            for (let i = 0; i < lines.length; i++) {
                if (lines[i].trim() === '0' && (lines[i + 1] || '').trim().toUpperCase() === 'BLOCK') {
                    let name = null, description = null;
                    i += 2;
                    for (let j = i; j < lines.length; j += 2) {
                        const code = lines[j] ? lines[j].trim() : '';
                        const value = lines[j + 1] ? lines[j + 1].trim() : '';
                        if (code === '0') break;
                        if (code === '2') name = value;
                        else if (code === '4') description = value;
                    }
                    if (name) map[name] = description || '';
                }
            }
            return map;
        }

        function extractNameFromXData(entity) {
            if (!entity.extendedData || !entity.extendedData.customStrings) return null;
            const nameString = entity.extendedData.customStrings.find(s => s.startsWith('at|1018|'));
            return nameString ? nameString.substring('at|1018|'.length) : null;
        }
        
        function extractConnectionFromXData(entity) {
            if (!entity.extendedData || !entity.extendedData.customStrings) return null;
            const connString = entity.extendedData.customStrings.find(s => s.startsWith('at|1019|'));
            return connString ? connString.substring('at|1019|'.length) : null;
        }

        function extractAllXData(entity) {
            const data = {};
            if (!entity.extendedData || !entity.extendedData.customStrings) return data;

            entity.extendedData.customStrings.forEach(s => {
                if (s.startsWith('at|')) {
                    const parts = s.split('|');
                    if (parts.length >= 3) {
                        const key = parts[1];
                        const value = parts.slice(2).join('|');
                        data[key] = value;
                    }
                }
            });
            return data;
        }
        
        function processDxfBlocks(dxf) {
            blockGeometries = {};
            if (!dxf || !dxf.blocks) return;
            for (const blockName in dxf.blocks) {
                const block = dxf.blocks[blockName];
                if (!block.entities) continue;
                blockGeometries[blockName] = block.entities.map(entity => {
                    switch (entity.type) {
                        case 'LINE': return { type: 'LINE', start: entity.vertices[0], end: entity.vertices[1] };
                        case 'LWPOLYLINE': case 'POLYLINE': return { type: 'POLYLINE', vertices: entity.vertices, closed: !!entity.shape || !!entity.closed };
                        case 'CIRCLE': return { type: 'CIRCLE', center: entity.center, radius: entity.radius };
                        case 'ARC': return { type: 'ARC', center: entity.center, radius: entity.radius, startAngle: entity.startAngle, endAngle: entity.endAngle };
                        case 'TEXT': return { type: 'TEXT', position: entity.startPoint, text: entity.text, height: entity.textHeight || entity.height };
                        default: return null;
                    }
                }).filter(Boolean);
            }
        }
        
        function drawSymbolLabel(ent) {
            ent.labelBBox = null; 
            if (!ent.label) return;

            // Si es un seccionador, verificar si es una salida de un CT existente
            if (ent.symbolType === 'seccionador') {
                const parts = ent.label.split('-');
                if (parts.length > 1) {
                    const ctLabelCandidate = parts[0];
                    const isOutlet = symbols.some(s => s.symbolType === 'ct' && s.label === ctLabelCandidate);
                    if (isOutlet) {
                        return; // Es una salida, no dibujar el nombre
                    }
                }
            }

            if (!ent.labelOffset) {
                ent.labelOffset = { x: 0, y: 0 };
            }

			const displayLabel = getDisplayLabel(ent);
            const isCt = ent.symbolType === 'ct';
            
            const anchorX = ent.position.x;
            const anchorY = ent.position.y;
            
            const symbolWidthInModel = (SYMBOL_SIZE * GLOBAL_SYMBOL_SCALE * (ent.xScale || 1));

            const MODEL_FONT_SIZE_CT = 1.25 * 0.421875;
            const MODEL_FONT_SIZE_SECCIONADOR = 1.1 * 0.5625; 
            const MODEL_X_OFFSET_CT = 0.8;
            const MODEL_X_OFFSET_SECCIONADOR = 0.8; 

            const modelFontSizeUnscaled = isCt ? MODEL_FONT_SIZE_CT : MODEL_FONT_SIZE_SECCIONADOR;
            const modelFontSize = modelFontSizeUnscaled * (ent.labelScale || 1);
            const modelXOffset = isCt ? MODEL_X_OFFSET_CT : MODEL_X_OFFSET_SECCIONADOR;
            
            const screenFontSize = modelFontSize * view.scale;

            if (screenFontSize < 3) return;
            
            const finalLabelAnchorModelX = anchorX + symbolWidthInModel + modelXOffset + ent.labelOffset.x;
            const finalLabelAnchorModelY = anchorY + ent.labelOffset.y;
            const labelPos = modelToScreen(finalLabelAnchorModelX, finalLabelAnchorModelY);

            dxfCtx.save();
            dxfCtx.font = `bold ${screenFontSize}px Inter, sans-serif`;

            const textMetrics = dxfCtx.measureText(displayLabel);
            ent.labelBBox = {
                x: labelPos.x,
                y: labelPos.y - screenFontSize / 2,
                width: textMetrics.width,
                height: screenFontSize
            };
            
            dxfCtx.textAlign = 'left';
            dxfCtx.textBaseline = 'middle';
            
            dxfCtx.fillStyle = isCt ? '#800000' : '#1f2937';
            dxfCtx.fillText(displayLabel, labelPos.x, labelPos.y);

            dxfCtx.restore();
        }
        function drawSeccionadorOverlay(ent) {
			if (!ent.isOpen || ent.connection === 'SECBC') return;
            if (ent.label && /-TR[12]$/i.test(ent.label)) return; // No dibujar overlay para los TR

			const geometries = blockGeometries[ent.blockName];
			if (!geometries) return;

			let largestGeom = null;
			let maxArea = -1;

			// Find the largest closed polyline or circle to use as the overlay shape
			geometries.forEach(geom => {
				let area = 0;
				if (geom.type === 'CIRCLE') {
					area = Math.PI * geom.radius * geom.radius;
				} else if (geom.type === 'POLYLINE' && geom.closed && geom.vertices && geom.vertices.length > 2) {
					for (let i = 0; i < geom.vertices.length; i++) {
						const v1 = geom.vertices[i];
						const v2 = geom.vertices[(i + 1) % geom.vertices.length];
						area += v1.x * v2.y - v2.x * v1.y;
					}
					area = Math.abs(area / 2);
				}
				if (area > maxArea) {
					maxArea = area;
					largestGeom = geom;
				}
			});

			// If a suitable shape was found, draw it as a white-filled, black-outlined overlay
			if (largestGeom) {
				dxfCtx.fillStyle = '#ffffff';
				dxfCtx.strokeStyle = SYMBOL_STROKE_COLOR;
				dxfCtx.lineWidth = 1.5;
				dxfCtx.beginPath();
				
				if (largestGeom.type === 'CIRCLE') {
					const c = transformPoint(largestGeom.center, ent);
					const r = largestGeom.radius * Math.min(Math.abs(ent.xScale || 1), Math.abs(ent.yScale || 1)) * view.scale;
					dxfCtx.arc(c.x, c.y, r, 0, 2 * Math.PI);
				} else if (largestGeom.type === 'POLYLINE') {
					const pts = largestGeom.vertices.map(v => transformPoint(v, ent));
					dxfCtx.moveTo(pts[0].x, pts[0].y);
					pts.slice(1).forEach(p => dxfCtx.lineTo(p.x, p.y));
					dxfCtx.closePath();
				}
				dxfCtx.fill();
				dxfCtx.stroke();
			}
		}

        function drawSymbol(ent) {
            dxfCtx.save();
            dxfCtx.strokeStyle = SYMBOL_STROKE_COLOR;
            dxfCtx.lineWidth = 1.5;

            // This block draws the symbol in its "closed" or default state.
            // The overlay for the "open" state is drawn on top afterwards.
            if (ent.symbolType === 'seccionador' && ent.label && /-TR[12]$/i.test(ent.label)) {
                const pos = modelToScreen(ent.position.x, ent.position.y);
                const size = (SYMBOL_SIZE * GLOBAL_SYMBOL_SCALE * Math.max(ent.xScale || 1, ent.yScale || 1)) * view.scale;
                const radius = size * 0.075; // Círculo pequeño (reducido a la mitad)

                dxfCtx.fillStyle = SYMBOL_STROKE_COLOR; // Relleno sólido ("a fondo de escala")
                dxfCtx.beginPath();
                dxfCtx.arc(pos.x, pos.y, radius, 0, 2 * Math.PI);
                dxfCtx.fill();
            } else if (ent.symbolType === 'seccionador' && ent.connection === 'SECA') {
                const geometries = blockGeometries[ent.blockName];
                if (geometries) {
					if (!ent.isOpen) {
						const allLines = geometries.filter(g => g.type === 'LINE');
						const allPolylines = geometries.filter(g => g.type === 'POLYLINE');
						const allShapeVertices = [];
						allLines.forEach(l => allShapeVertices.push(l.start, l.end));
						allPolylines.forEach(p => allShapeVertices.push(...p.vertices));
						if (allShapeVertices.length > 0) {
							let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
							allShapeVertices.forEach(v => {
								minX = Math.min(minX, v.x); minY = Math.min(minY, v.y);
								maxX = Math.max(maxX, v.x); maxY = Math.max(maxY, v.y);
							});
							const shapeCenter = { x: (minX + maxX) / 2, y: (minY + maxY) / 2 };
							const rhombusVerts = [
								{ x: shapeCenter.x, y: maxY }, { x: maxX, y: shapeCenter.y },
								{ x: shapeCenter.x, y: minY }, { x: minX, y: shapeCenter.y }
							];
							const innerLines = allLines.filter(l => {
								const lineMidpointX = (l.start.x + l.end.x) / 2;
								const lineMidpointY = (l.start.y + l.end.y) / 2;
								const distFromCenter = Math.sqrt(Math.pow(lineMidpointX - shapeCenter.x, 2) + Math.pow(lineMidpointY - shapeCenter.y, 2));
								const maxDist = Math.sqrt(Math.pow(maxX - shapeCenter.x, 2) + Math.pow(maxY - shapeCenter.y, 2));
								return distFromCenter < maxDist * 0.6; 
							});
							if (innerLines.length > 0) {
								let kCenterX = 0, kCenterY = 0;
								innerLines.forEach(l => { kCenterX += l.start.x + l.end.x; kCenterY += l.start.y + l.end.y; });
								kCenterX /= (innerLines.length * 2); kCenterY /= (innerLines.length * 2);
								const dx = kCenterX - shapeCenter.x, dy = kCenterY - shapeCenter.y;
								let fillTriangleVerts = null;
								if (Math.abs(dx) > Math.abs(dy)) {
									fillTriangleVerts = dx > 0 ? [rhombusVerts[0], rhombusVerts[3], rhombusVerts[2]] : [rhombusVerts[0], rhombusVerts[1], rhombusVerts[2]];
								} else {
									fillTriangleVerts = dy > 0 ? [rhombusVerts[3], rhombusVerts[2], rhombusVerts[1]] : [rhombusVerts[3], rhombusVerts[0], rhombusVerts[1]];
								}
								if (fillTriangleVerts) {
									const transformedVerts = fillTriangleVerts.map(v => transformPoint(v, ent));
									dxfCtx.fillStyle = '#1f2937';
									dxfCtx.beginPath();
									dxfCtx.moveTo(transformedVerts[0].x, transformedVerts[0].y);
									dxfCtx.lineTo(transformedVerts[1].x, transformedVerts[1].y);
									dxfCtx.lineTo(transformedVerts[2].x, transformedVerts[2].y);
									dxfCtx.closePath();
									dxfCtx.fill();
								}
							}
						}
					}

                    geometries.forEach(geom => {
                        if (geom.type === 'TEXT') return;
                        dxfCtx.beginPath();
                        if (geom.type === 'POLYLINE') {
                            if (!geom.vertices || geom.vertices.length === 0) return;
                            const pts = geom.vertices.map(v => transformPoint(v, ent));
                            dxfCtx.moveTo(pts[0].x, pts[0].y);
                            pts.slice(1).forEach(p => dxfCtx.lineTo(p.x, p.y));
                            if (geom.closed) dxfCtx.closePath();
                        } else if (geom.type === 'LINE') {
                            const s = transformPoint(geom.start, ent);
                            const e = transformPoint(geom.end, ent);
                            dxfCtx.moveTo(s.x, s.y);
                            dxfCtx.lineTo(e.x, e.y);
                        }
                        dxfCtx.strokeStyle = SYMBOL_STROKE_COLOR;
                        dxfCtx.stroke();
                    });
                }
            } else if (ent.symbolType === 'seccionador' && ent.connection === 'SECBC') {
                const pos = modelToScreen(ent.position.x, ent.position.y);
                const size = (SYMBOL_SIZE * GLOBAL_SYMBOL_SCALE * Math.max(ent.xScale || 1, ent.yScale || 1)) * view.scale;
                const outerRadius = size * 0.8;

				if (ent.isOpen) {
                    // Cuando está abierto: círculo blanco con borde negro
                    dxfCtx.fillStyle = '#ffffff';
                    dxfCtx.strokeStyle = SYMBOL_STROKE_COLOR;
                    dxfCtx.beginPath();
                    dxfCtx.arc(pos.x, pos.y, outerRadius, 0, 2 * Math.PI);
                    dxfCtx.fill();
                    dxfCtx.stroke();
                } else {
                    // Cuando está cerrado: símbolo original
                    const innerRadius = size * 0.225;
                    dxfCtx.fillStyle = '#1f2937';
                    dxfCtx.beginPath();
                    dxfCtx.arc(pos.x, pos.y, outerRadius, 0, 2 * Math.PI);
                    dxfCtx.fill();
                    dxfCtx.stroke();
                    dxfCtx.fillStyle = SECCIONADOR_FILL_COLOR;
                    dxfCtx.beginPath();
                    dxfCtx.arc(pos.x, pos.y, innerRadius, 0, 2 * Math.PI);
                    dxfCtx.fill();
                    dxfCtx.strokeStyle = SYMBOL_STROKE_COLOR;
                    dxfCtx.stroke();
                }
            } else if (ent.symbolType === 'seccionador' && ent.connection === 'SECU') {
                const geometries = blockGeometries[ent.blockName];
                if (geometries) {
                    const rhombusGeom = geometries.find(g => g.type === 'POLYLINE' && g.vertices && g.vertices.length > 0);
                    if (rhombusGeom) {
                        dxfCtx.fillStyle = '#1f2937';
                        dxfCtx.strokeStyle = SYMBOL_STROKE_COLOR;
                        dxfCtx.beginPath();
                        const pts = rhombusGeom.vertices.map(v => transformPoint(v, ent));
                        dxfCtx.moveTo(pts[0].x, pts[0].y);
                        for (let i = 1; i < pts.length; i++) dxfCtx.lineTo(pts[i].x, pts[i].y);
                        dxfCtx.closePath();
                        dxfCtx.fill();
                        dxfCtx.stroke();
                    }
                }
                const pos = modelToScreen(ent.position.x, ent.position.y);
                const size = (SYMBOL_SIZE * GLOBAL_SYMBOL_SCALE * Math.max(ent.xScale || 1, ent.yScale || 1)) * view.scale;
                const innerRadius = size * 0.225;
                dxfCtx.fillStyle = SECCIONADOR_FILL_COLOR;
                dxfCtx.beginPath();
                dxfCtx.arc(pos.x, pos.y, innerRadius, 0, 2 * Math.PI);
                dxfCtx.fill();
                dxfCtx.strokeStyle = SYMBOL_STROKE_COLOR;
                dxfCtx.stroke();
            } else if (ent.symbolType === 'seccionador' && ent.connection === 'SECZ') {
                const pos = modelToScreen(ent.position.x, ent.position.y);
                const size = (SYMBOL_SIZE * GLOBAL_SYMBOL_SCALE * Math.max(ent.xScale || 1, ent.yScale || 1)) * view.scale;
                
                // Dimensiones del triángulo
                const triangleHeight = size * 1.5;
                const triangleWidth = size * 1.8;
                
                // Triángulo relleno - PUNTA HACIA ARRIBA
                dxfCtx.beginPath();
                dxfCtx.moveTo(pos.x, pos.y - triangleHeight / 2); // Punto superior
                dxfCtx.lineTo(pos.x - triangleWidth / 2, pos.y + triangleHeight / 2); // Inferior izquierdo
                dxfCtx.lineTo(pos.x + triangleWidth / 2, pos.y + triangleHeight / 2); // Inferior derecho
                dxfCtx.closePath();
                dxfCtx.fillStyle = '#1f2937';
                dxfCtx.fill();

                // Línea horizontal - EN LA PUNTA
                dxfCtx.beginPath();
                dxfCtx.moveTo(pos.x - triangleWidth / 2, pos.y - triangleHeight / 2);
                dxfCtx.lineTo(pos.x + triangleWidth / 2, pos.y - triangleHeight / 2);
                dxfCtx.stroke();

                // Punto verde
                const dotRadius = size * 0.25;
                dxfCtx.beginPath();
                dxfCtx.arc(pos.x, pos.y, dotRadius, 0, 2 * Math.PI);
                dxfCtx.fillStyle = '#4ade80'; // verde
                dxfCtx.fill();
            } else if (ent.symbolType === 'ct') {
				const pos = modelToScreen(ent.position.x, ent.position.y);
				const size = (SYMBOL_SIZE * GLOBAL_SYMBOL_SCALE * Math.max(ent.xScale || 1, ent.yScale || 1)) * view.scale;
				const yOffset = 0; // -size * 0.2; // Ajustado para centrar el símbolo
				
				const fillSize = size * CT_COVER_FACTOR;
				dxfCtx.fillStyle = CT_FILL_COLOR;
				dxfCtx.beginPath();
				dxfCtx.rect(pos.x - fillSize, pos.y + yOffset - fillSize, fillSize * 2, fillSize * 2);
				dxfCtx.fill();

				dxfCtx.beginPath();
				dxfCtx.rect(pos.x - size, pos.y + yOffset - size, size * 2, size * 2);
				dxfCtx.stroke();

				drawCtIcon(dxfCtx, ent.ctIconType || 'plain', pos, size, yOffset);

			} else {
                 const geometries = blockGeometries[ent.blockName];
                 if (geometries) {
                    dxfCtx.fillStyle = ent.symbolType === 'ct' ? CT_FILL_COLOR : SECCIONADOR_FILL_COLOR;
                    geometries.forEach(geom => {
                        dxfCtx.beginPath();
                        switch (geom.type) {
                            case 'LINE': {
                                const s = transformPoint(geom.start, ent); const e = transformPoint(geom.end, ent);
                                dxfCtx.moveTo(s.x, s.y); dxfCtx.lineTo(e.x, e.y); break;
                            } case 'POLYLINE': {
                                if (!geom.vertices || geom.vertices.length === 0) break;
                                const pts = geom.vertices.map(v => transformPoint(v, ent));
                                dxfCtx.moveTo(pts[0].x, pts[0].y);
                                pts.slice(1).forEach(p => dxfCtx.lineTo(p.x, p.y));
                                if (geom.closed) dxfCtx.closePath(); break;
                            } case 'CIRCLE': {
                                const c = transformPoint(geom.center, ent);
                                const r = geom.radius * Math.min(Math.abs(ent.xScale || 1), Math.abs(ent.yScale || 1)) * view.scale;
                                dxfCtx.arc(c.x, c.y, r, 0, 2 * Math.PI); break;
                            } case 'ARC': {
                                const c = transformPoint(geom.center, ent);
                                const r = geom.radius * Math.min(Math.abs(ent.xScale || 1), Math.abs(ent.yScale || 1)) * view.scale;
                                const startRad = -geom.startAngle * Math.PI / 180, endRad = -geom.endAngle * Math.PI / 180;
                                dxfCtx.arc(c.x, c.y, r, startRad, endRad, true); break;
                            } case 'TEXT': {
                                const pos = transformPoint(geom.position, ent);
                                dxfCtx.save();
                                dxfCtx.translate(pos.x, pos.y);
                                dxfCtx.rotate(-(ent.rotation || 0) * Math.PI / 180);
                                dxfCtx.fillStyle = '#1f2937';
                                dxfCtx.font = `${geom.height * view.scale}px Inter, sans-serif`;
                                dxfCtx.textAlign = 'left'; dxfCtx.textBaseline = 'bottom';
                                dxfCtx.fillText(geom.text, 0, 0);
                                dxfCtx.restore(); break;
                            }
                        }
                        if (geom.type !== 'TEXT') {
                            if (geom.closed || geom.type === 'CIRCLE') dxfCtx.fill();
                            dxfCtx.stroke();
                        }
                    });
                 }
            }

            // --- OVERLAY LOGIC FOR "OPEN" STATE ---
            if (ent.symbolType === 'seccionador') {
                drawSeccionadorOverlay(ent);
            }
            
            dxfCtx.restore();
            drawSymbolLabel(ent);
        }

        function transformPoint(p, ent) {
            let newP = { x: p.x * (ent.xScale || 1), y: p.y * (ent.yScale || 1) };
            if (ent.rotation) newP = rotatePoint(newP.x, newP.y, 0, 0, ent.rotation);
            newP.x += ent.position.x;
            newP.y += ent.position.y;
            return modelToScreen(newP.x, newP.y);
        }
        
        function computeExtents() {
            const allEntities = [...getVisibleLinesAndPolylines(), ...getVisibleSymbols(), ...getVisibleUserDrawings()];
            
            if (allEntities.length === 0) {
                // Blank canvas, set a default view so drawing starts at a reasonable zoom.
                const canvasContainer = document.getElementById('visualization-container');
                const containerWidth = canvasContainer.clientWidth || 800;
                const containerHeight = canvasContainer.clientHeight || 600;
                const aspectRatio = (containerWidth > 0 && containerHeight > 0) ? containerWidth / containerHeight : 4 / 3;
                const viewHeight = 20; // Default "world" height in model units. A smaller number means higher zoom.
                const viewWidth = viewHeight * aspectRatio;
                extents = { 
                    minX: -viewWidth / 2, 
                    minY: -viewHeight / 2, 
                    maxX: viewWidth / 2, 
                    maxY: viewHeight / 2 
                };
                return;
            }

            const init = { minX: Infinity, minY: Infinity, maxX: -Infinity, maxY: -Infinity };
            extents = allEntities.reduce((acc, ent) => {
                const bbox = getEntityBBox(ent, true); // Get model coordinates bbox
                if (bbox) {
                    acc.minX = Math.min(acc.minX, bbox.x);
                    acc.minY = Math.min(acc.minY, bbox.y);
                    acc.maxX = Math.max(acc.maxX, bbox.x + bbox.width);
                    acc.maxY = Math.max(acc.maxY, bbox.y + bbox.height);
                }
                return acc;
            }, init);

            if (extents.minX === Infinity) { // Fallback if no valid bboxes were found
                extents = { minX: 0, minY: 0, maxX: 100, maxY: 100 }; 
            }
        }

	        function draw() {
				const rect = dxfCanvas.getBoundingClientRect();
				dxfCtx.save(); // Save the clean, untransformed state
				dxfCtx.fillStyle = '#f0f0f0';
				dxfCtx.fillRect(0, 0, rect.width, rect.height);

					// --- Draw DXF content (potentially clipped) ---
					dxfCtx.save(); // Save state before clipping for DXF content
			if (originalExtents) {
				const clipStart = modelToScreen(extents.minX, extents.maxY);
				const clipEnd = modelToScreen(extents.maxX, extents.minY);
				dxfCtx.beginPath();
				dxfCtx.rect(clipStart.x, clipStart.y, clipEnd.x - clipStart.x, clipEnd.y - clipStart.y);
				dxfCtx.clip();
			}

			dxfCtx.lineWidth = 1.5;
			getVisibleLinesAndPolylines().forEach(ent => {
				dxfCtx.strokeStyle = LINE_COLOR;
				
				const isSubterraneo = ent.extendedAttributes && ent.extendedAttributes['587'] === 'AL AS';
				const dashPattern = getDashPatternForLinetype(ent.linetype);

                if (isSubterraneo) {
                    dxfCtx.setLineDash([5, 5]); // Patrón de línea punteada para tramo subterráneo
                } else if (dashPattern) {
                    dxfCtx.setLineDash(dashPattern);
                }

				if (ent.type === 'LINE') {
                    // FIX: Check for malformed LINE entities that may lack start/end points after parsing.
					if (ent.start && ent.end) {
					    const p1 = modelToScreen(ent.start.x, ent.start.y);
					    const p2 = modelToScreen(ent.end.x, ent.end.y);
					    dxfCtx.beginPath(); dxfCtx.moveTo(p1.x, p1.y); dxfCtx.lineTo(p2.x, p2.y); dxfCtx.stroke();
                    }
				} else if ((ent.type === 'LWPOLYLINE' || ent.type === 'POLYLINE') && ent.vertices && ent.vertices.length > 0) {
                    // FIX: Check that the first vertex exists before trying to draw from it.
                    if (ent.vertices[0]) {
					    dxfCtx.beginPath();
					    const start = modelToScreen(ent.vertices[0].x, ent.vertices[0].y);
					    dxfCtx.moveTo(start.x, start.y);
					    for (let i=1; i<ent.vertices.length; i++) {
                            // FIX: Check that subsequent vertices exist before drawing to them.
                            if (ent.vertices[i]) {
						        dxfCtx.lineTo(modelToScreen(ent.vertices[i].x, ent.vertices[i].y).x, modelToScreen(ent.vertices[i].x, ent.vertices[i].y).y);
                            }
					    }
					    if (ent.closed) dxfCtx.closePath();
					    dxfCtx.stroke();
                    }
				}

                if (isSubterraneo || dashPattern) {
                    dxfCtx.setLineDash([]);
                }
			});

			const visibleSymbols = getVisibleSymbols();
			const ctSymbols = visibleSymbols.filter(s => s.symbolType === 'ct');
			const otherSymbols = visibleSymbols.filter(s => s.symbolType !== 'ct');
			otherSymbols.forEach(drawSymbol);
			ctSymbols.forEach(drawSymbol);
			
			dxfCtx.restore(); // Restore from the clipped state
			// --- End of DXF content drawing ---


			// --- Draw User Annotations (never clipped) ---
			[...getVisibleUserDrawings(), activeDrawing].filter(Boolean).forEach(d => {
				dxfCtx.save();
				dxfCtx.strokeStyle = d.color || DEFAULT_DRAW_COLOR;
				dxfCtx.fillStyle = `${d.color || DEFAULT_DRAW_COLOR}1A`; // Add alpha for fill
				dxfCtx.lineWidth = d.strokeWidth || 1.5;

				if (d.type === 'draw-dashed-line') {
					dxfCtx.setLineDash([5, 5]);
				}
				
				const start = modelToScreen(d.start.x, d.start.y);
				let end;
				if(d.end) end = modelToScreen(d.end.x, d.end.y);

				switch(d.type) {
					case 'draw-rect':
						dxfCtx.beginPath();
						dxfCtx.rect(start.x, start.y, end.x - start.x, end.y - start.y);
						if (d.isFilled !== false) { // Default to filled
							dxfCtx.fill();
						}
						dxfCtx.stroke();
						break;
					case 'draw-ellipse':
						dxfCtx.beginPath();
						const rx = Math.abs(end.x - start.x) / 2;
						const ry = Math.abs(end.y - start.y) / 2;
						const cx = Math.min(start.x, end.x) + rx;
						const cy = Math.min(start.y, end.y) + ry;
						dxfCtx.ellipse(cx, cy, rx, ry, 0, 0, 2 * Math.PI);
						if (d.isFilled !== false) { // Default to filled
							dxfCtx.fill();
						}
						dxfCtx.stroke();
						break;
					case 'draw-line':
					case 'draw-dashed-line':
						dxfCtx.beginPath();
						dxfCtx.moveTo(start.x, start.y);
						dxfCtx.lineTo(end.x, end.y);
						dxfCtx.stroke();
						break;
					case 'draw-text':
						const screenFontSize = (d.modelHeight || 0.75) * view.scale;
						if (screenFontSize < 1) break; // Don't draw if too small
						dxfCtx.fillStyle = d.color || DEFAULT_DRAW_COLOR;
						dxfCtx.font = `${screenFontSize}px Inter, sans-serif`;
						dxfCtx.textAlign = 'left';
						dxfCtx.textBaseline = 'top';
						dxfCtx.fillText(d.text, start.x, start.y);
						break;
					case 'draw-ground':
						renderGroundSymbol(d);
						break;
					case 'draw-ct':
						const ctPos = modelToScreen(d.start.x, d.start.y);
						const ctSize = d.size * view.scale;
						const ctYOffset = 0; // -ctSize * 0.2; // Ajustado para centrar el símbolo
						const ctFillSize = ctSize * CT_COVER_FACTOR;
						
						dxfCtx.fillStyle = CT_FILL_COLOR;
						dxfCtx.beginPath();
						dxfCtx.rect(ctPos.x - ctFillSize, ctPos.y + ctYOffset - ctFillSize, ctFillSize * 2, ctFillSize * 2);
						dxfCtx.fill();

						dxfCtx.beginPath();
						dxfCtx.rect(ctPos.x - ctSize, ctPos.y + ctYOffset - ctSize, ctSize * 2, ctSize * 2);
						dxfCtx.stroke();
						
						drawCtIcon(dxfCtx, d.ctIconType || 'plain', ctPos, ctSize, ctYOffset);
						break;
					case 'draw-mundo-interno':
						const miPos = modelToScreen(d.start.x, d.start.y);
						const miSize = d.size * view.scale;
						dxfCtx.save();
						dxfCtx.translate(miPos.x, miPos.y);
						dxfCtx.rotate((d.rotation || 0) * Math.PI / 180);
						dxfCtx.strokeStyle = d.color || SYMBOL_STROKE_COLOR;
						dxfCtx.lineWidth = d.strokeWidth || 1.5;

						if (d.symbolStyle === 'solid-black-circle') {
							dxfCtx.fillStyle = d.color || SYMBOL_STROKE_COLOR;
							dxfCtx.beginPath();
							dxfCtx.arc(0, 0, miSize, 0, 2 * Math.PI);
							dxfCtx.fill();
						} else if (d.symbolStyle === 'half-f-circle') {
							// Bottom half black
							dxfCtx.fillStyle = d.color || SYMBOL_STROKE_COLOR;
							dxfCtx.beginPath();
							dxfCtx.arc(0, 0, miSize, 0, Math.PI, false);
							dxfCtx.fill();
							// Full circle outline
							dxfCtx.beginPath();
							dxfCtx.arc(0, 0, miSize, 0, 2 * Math.PI);
							dxfCtx.stroke();
							// Letter F in top half, rotated
							const fontSize = miSize * 1.2;
							dxfCtx.font = `bold ${fontSize}px Inter, sans-serif`;
							dxfCtx.fillStyle = d.color || SYMBOL_STROKE_COLOR;
							dxfCtx.textAlign = 'center';
							dxfCtx.textBaseline = 'middle';

							dxfCtx.save();
							dxfCtx.translate(0, -miSize * 0.5); // Move context to top half center
							dxfCtx.rotate(-Math.PI / 2);       // Rotate -90 degrees
							dxfCtx.fillText('F', 0, 0);         // Draw at new origin
							dxfCtx.restore();
						} else if (d.symbolStyle === 'arrow') {
							const lengthFactor = 1.4;
							const bottomY = miSize * lengthFactor;
							const topY = -miSize * lengthFactor;
							const headHeight = miSize * 0.5;
							const headWidth = miSize * 0.5;

							dxfCtx.beginPath();
							dxfCtx.moveTo(0, bottomY);
							dxfCtx.lineTo(0, topY);
							dxfCtx.moveTo(-headWidth, topY + headHeight);
							dxfCtx.lineTo(0, topY);
							dxfCtx.lineTo(headWidth, topY + headHeight);
							dxfCtx.stroke();
						}
						dxfCtx.restore();
						break;
					case 'draw-seccionador':
						const secPos = modelToScreen(d.start.x, d.start.y);
						const secSize = d.size * view.scale;
						dxfCtx.save();
						dxfCtx.translate(secPos.x, secPos.y);
						dxfCtx.rotate((d.rotation || 0) * Math.PI / 180);

						if (d.symbolStyle === 'punto-verde') {
                            if (d.isOpen) {
                                // Draw white-filled rhombus for "open" state
								dxfCtx.fillStyle = '#ffffff';
								dxfCtx.beginPath();
								dxfCtx.moveTo(0, -secSize); // Top
								dxfCtx.lineTo(secSize, 0); // Right
								dxfCtx.lineTo(0, secSize); // Bottom
								dxfCtx.lineTo(-secSize, 0); // Left
								dxfCtx.closePath();
								dxfCtx.fill();
								dxfCtx.stroke();
                            } else {
                                // Draw solid rhombus with the selected color
                                dxfCtx.fillStyle = dxfCtx.strokeStyle;
                                dxfCtx.beginPath();
                                dxfCtx.moveTo(0, -secSize); // Top
                                dxfCtx.lineTo(secSize, 0); // Right
                                dxfCtx.lineTo(0, secSize); // Bottom
                                dxfCtx.lineTo(-secSize, 0); // Left
                                dxfCtx.closePath();
                                dxfCtx.fill();
    
                                // Draw green dot in the center
                                dxfCtx.fillStyle = '#4ade80'; // a nice green
                                dxfCtx.beginPath();
                                dxfCtx.arc(0, 0, secSize * 0.225, 0, 2 * Math.PI);
                                dxfCtx.fill();
                            }
						} else if (d.symbolStyle === 'circulo-punto-verde') {
							if (d.isOpen) {
								// Open state: white circle with selected color outline
								dxfCtx.fillStyle = '#ffffff';
								// strokeStyle is already set to d.color
								dxfCtx.beginPath();
								dxfCtx.arc(0, 0, secSize, 0, 2 * Math.PI);
								dxfCtx.fill();
								dxfCtx.stroke();
							} else {
								// Closed state: selected color circle with green dot
								dxfCtx.fillStyle = dxfCtx.strokeStyle;
								dxfCtx.beginPath();
								dxfCtx.arc(0, 0, secSize, 0, 2 * Math.PI);
								dxfCtx.fill();

								dxfCtx.fillStyle = '#4ade80';
								dxfCtx.beginPath();
								dxfCtx.arc(0, 0, secSize * 0.225, 0, 2 * Math.PI);
								dxfCtx.fill();
							}
						} else if (d.symbolStyle === 'capacitor') {
							// Draw two parallel lines for the capacitor symbol
							const lineLength = secSize * 0.8;
							const gap = secSize * 0.3;
							dxfCtx.beginPath();
							// Line 1
							dxfCtx.moveTo(-gap, -lineLength);
							dxfCtx.lineTo(-gap, lineLength);
							// Line 2
							dxfCtx.moveTo(gap, -lineLength);
							dxfCtx.lineTo(gap, lineLength);
							dxfCtx.stroke();
						} else if (d.symbolStyle === 'rueda') {
							// Dibuja el símbolo de la rueda
							const radius = secSize;
							dxfCtx.beginPath();
							dxfCtx.arc(0, 0, radius, 0, 2 * Math.PI); // Círculo exterior
							
							// Dibuja las 4 líneas diametrales (8 radios)
							for (let i = 0; i < 4; i++) {
								const angle = i * Math.PI / 4;
								dxfCtx.moveTo(-radius * Math.cos(angle), -radius * Math.sin(angle));
								dxfCtx.lineTo(radius * Math.cos(angle), radius * Math.sin(angle));
							}
							
							dxfCtx.stroke();
						} else if (d.symbolStyle === 'secz') {
                            const halfWidth = secSize;
                            const halfHeight = secSize;
                            const dotRadius = secSize * 0.3;

                            // Top triangle (pointing down)
                            dxfCtx.beginPath();
                            dxfCtx.moveTo(-halfWidth, -halfHeight); // Top-left
                            dxfCtx.lineTo(halfWidth, -halfHeight);  // Top-right
                            dxfCtx.lineTo(0, 0);           // Tip at center
                            dxfCtx.closePath();
                            dxfCtx.fillStyle = dxfCtx.strokeStyle;
                            dxfCtx.fill();

                            // Bottom triangle (pointing up)
                            dxfCtx.beginPath();
                            dxfCtx.moveTo(-halfWidth, halfHeight); // Bottom-left
                            dxfCtx.lineTo(halfWidth, halfHeight);  // Bottom-right
                            dxfCtx.lineTo(0, 0);           // Tip at center
                            dxfCtx.closePath();
                            dxfCtx.fillStyle = dxfCtx.strokeStyle;
                            dxfCtx.fill();

                            // Green circle in the middle, on top
                            dxfCtx.beginPath();
                            dxfCtx.arc(0, 0, dotRadius, 0, 2 * Math.PI);
                            dxfCtx.fillStyle = '#4ade80'; // green
                            dxfCtx.fill();
                        } else { // 'standard' or default
							if (d.isOpen) {
								// Draw white-filled rhombus for "open" state
								dxfCtx.fillStyle = '#ffffff';
								// strokeStyle is already d.color
								
								dxfCtx.beginPath();
								dxfCtx.moveTo(0, -secSize); // Top
								dxfCtx.lineTo(secSize, 0); // Right
								dxfCtx.lineTo(0, secSize); // Bottom
								dxfCtx.lineTo(-secSize, 0); // Left
								dxfCtx.closePath();
								
								dxfCtx.fill();
								dxfCtx.stroke();
							} else {
								// Draw standard "closed" state
								// Draw left filled half
								dxfCtx.fillStyle = dxfCtx.strokeStyle;
								dxfCtx.beginPath();
								dxfCtx.moveTo(0, -secSize); // Top
								dxfCtx.lineTo(-secSize, 0); // Left
								dxfCtx.lineTo(0, secSize);  // Bottom
								dxfCtx.closePath();
								dxfCtx.fill();

								// Draw the full rhombus outline
								// dxfCtx.strokeStyle is already set
								dxfCtx.beginPath();
								dxfCtx.moveTo(0, -secSize); // Top
								dxfCtx.lineTo(secSize, 0); // Right
								dxfCtx.lineTo(0, secSize); // Bottom
								dxfCtx.lineTo(-secSize, 0); // Left
								dxfCtx.closePath();
								dxfCtx.stroke();
								
								// Draw the letter 'K' with lines to match the DXF symbol
								dxfCtx.lineWidth = 1; // Use a thin line for the K itself
								dxfCtx.strokeStyle = '#1f2937'; // K is always dark for visibility

								const kHeight = secSize * 0.6;
								const kWidth = kHeight * 0.5;
								const kCenterX = secSize * 0.35; 

								const verticalX = kCenterX - kWidth / 2;
								const diagonalX = kCenterX + kWidth / 2;

								dxfCtx.beginPath();
								// Vertical line
								dxfCtx.moveTo(verticalX, -kHeight / 2);
								dxfCtx.lineTo(verticalX, kHeight / 2);
								// Upper diagonal from middle of vertical line
								dxfCtx.moveTo(verticalX, 0);
								dxfCtx.lineTo(diagonalX, -kHeight / 2);
								// Lower diagonal from middle of vertical line
								dxfCtx.moveTo(verticalX, 0);
								dxfCtx.lineTo(diagonalX, kHeight / 2);
								dxfCtx.stroke();
							}
						}

						dxfCtx.restore();
						break;
				}

				d.labelBBox = null; // Reset bbox
				if (d.label && (d.symbolType === 'ct' || d.symbolType === 'seccionador')) {
					// Si es un seccionador, verificar si es una salida de un CT existente
					if (d.symbolType === 'seccionador') {
						const parts = d.label.split('-');
						if (parts.length > 1) {
							const ctLabelCandidate = parts[0];
							const isOutlet = symbols.some(s => s.symbolType === 'ct' && s.label === ctLabelCandidate) ||
										 userDrawings.some(ud => ud.symbolType === 'ct' && ud.label === ctLabelCandidate);
							if (isOutlet) {
								return; // Es una salida, no dibujar el nombre. Corresponde a 'continue' en forEach.
							}
						}
					}

					const displayLabel = getDisplayLabel(d);
					const symbolWidthInModel = d.size;
					const isCt = d.symbolType === 'ct';

					const MODEL_FONT_SIZE_CT = 1.25 * 0.421875;
					const MODEL_FONT_SIZE_SECCIONADOR = 1.1 * 0.5625; 
					const MODEL_X_OFFSET_CT = 0.8;
					const MODEL_X_OFFSET_SECCIONADOR = 0.8;
					const modelFontSize = isCt ? MODEL_FONT_SIZE_CT : MODEL_FONT_SIZE_SECCIONADOR;
					const modelXOffset = isCt ? MODEL_X_OFFSET_CT : MODEL_X_OFFSET_SECCIONADOR;
					const screenFontSize = modelFontSize * view.scale;

					if (screenFontSize >= 3) {
						if (!d.labelOffset) d.labelOffset = { x: 0, y: 0 };

						const finalLabelAnchorModelX = d.start.x + symbolWidthInModel + modelXOffset + d.labelOffset.x;
						const finalLabelAnchorModelY = d.start.y + d.labelOffset.y;
						const labelPos = modelToScreen(finalLabelAnchorModelX, finalLabelAnchorModelY);

						dxfCtx.font = `bold ${screenFontSize}px Inter, sans-serif`;

						const textMetrics = dxfCtx.measureText(displayLabel);
						d.labelBBox = {
							x: labelPos.x,
							y: labelPos.y - screenFontSize / 2,
							width: textMetrics.width,
							height: screenFontSize
						};

						dxfCtx.textAlign = 'left';
						dxfCtx.textBaseline = 'middle';
						dxfCtx.fillStyle = isCt ? '#800000' : '#1f2937';
						dxfCtx.fillText(displayLabel, labelPos.x, labelPos.y);
					}
				}
				
				dxfCtx.restore();
			});
			
			// --- Draw selection highlights and handles on top ---
			const allSelectedItems = [];
			if (multiSelection.length > 0) {
				allSelectedItems.push(...multiSelection);
			} else if (selectedDrawingId) {
				const selected = userDrawings.find(d => d.id === selectedDrawingId);
				if (selected) allSelectedItems.push(selected);
			} else if (selectedEntity) { // If a single DXF entity is selected
				allSelectedItems.push(selectedEntity);
			}


			const isMultiSelectMode = multiSelection.length > 0;

			allSelectedItems.forEach(item => {
				const bbox = getEntityBBox(item, false); // Get screen bbox
				if (bbox) {
					dxfCtx.save();
					if (isMultiSelectMode) {
						// Aura roja para movimiento (selección múltiple con Shift)
						dxfCtx.strokeStyle = '#ef4444'; // Rojo
						dxfCtx.lineWidth = 2;
						dxfCtx.setLineDash([4, 2]); // Línea punteada para mayor claridad
					} else {
						// Aura celeste para información (selección única)
						dxfCtx.strokeStyle = '#0ea5e9'; // Azul celeste
						dxfCtx.lineWidth = 1.5;
						dxfCtx.setLineDash([4, 2]);
					}
					dxfCtx.strokeRect(bbox.x - 2, bbox.y - 2, bbox.width + 4, bbox.height + 4);
					dxfCtx.restore();
				}
			});
			
			// Only draw resize handles for a single selected drawing
			if(selectedDrawingId && multiSelection.length === 0) {
				const selected = userDrawings.find(d => d.id === selectedDrawingId);
				if(selected) drawSelectionHandles(selected);
			}

	            // --- Draw Snap Line ---
	            if (snapLine) {
	                dxfCtx.save();
	                dxfCtx.strokeStyle = '#ef4444'; // Blue-500
	                dxfCtx.lineWidth = 1.5;
                // dxfCtx.setLineDash([3, 3]); // Removed to make the line solid
                const start = modelToScreen(snapLine.start.x, snapLine.start.y);
                const end = modelToScreen(snapLine.end.x, snapLine.end.y);
	                dxfCtx.beginPath();
	                dxfCtx.moveTo(start.x, start.y);
	                dxfCtx.lineTo(end.x, end.y);
	                dxfCtx.stroke();
	                dxfCtx.restore();
	            }

				// --- Draw UI elements like marquee on top of everything ---
				if (marqueeStart && marqueeEnd && (currentTool === 'crop' || currentTool === 'marquee-select')) {
					dxfCtx.save();
					
				if (currentTool === 'marquee-select' && marqueeEnd.x < marqueeStart.x) { // Right-to-left is INTERSECT
					dxfCtx.strokeStyle = '#10b981'; // Green
					dxfCtx.fillStyle = 'rgba(16, 185, 129, 0.1)';
					dxfCtx.setLineDash([5, 3]);
				} else { // Left-to-right is CONTAINS (or crop tool)
					dxfCtx.strokeStyle = '#2563eb'; // Blue
					dxfCtx.fillStyle = 'rgba(37, 99, 235, 0.1)';
					dxfCtx.setLineDash([]); // Solid line for "contains" selection
				}
				
				dxfCtx.lineWidth = 1.5;
				
				const marqueeRect = {
					x: Math.min(marqueeStart.x, marqueeEnd.x), y: Math.min(marqueeStart.y, marqueeEnd.y),
					width: Math.abs(marqueeStart.x - marqueeEnd.x), height: Math.abs(marqueeStart.y - marqueeEnd.y)
				};
				dxfCtx.strokeRect(marqueeRect.x, marqueeRect.y, marqueeRect.width, marqueeRect.height);
				dxfCtx.fillRect(marqueeRect.x, marqueeRect.y, marqueeRect.width, marqueeRect.height);
				dxfCtx.restore();
        	}
			
			dxfCtx.restore(); // Restore the clean, initial state
        }
		
		function renderGroundSymbol(d) {
			const size = (d.size || 0.5) * view.scale;
			const pos = modelToScreen(d.start.x, d.start.y);
			dxfCtx.strokeStyle = d.color || DEFAULT_DRAW_COLOR;
			dxfCtx.lineWidth = d.strokeWidth || 1.5;
			
			dxfCtx.save();
			// Translate context to the symbol's top-center position
			dxfCtx.translate(pos.x, pos.y);
			// Rotate the context
			dxfCtx.rotate((d.rotation || 0) * Math.PI / 180);

			dxfCtx.beginPath();
			dxfCtx.moveTo(0, 0); // Now drawing starts from the translated origin
			dxfCtx.lineTo(0, size * 2.8);
			
			dxfCtx.moveTo(-size, size * 2.8);
			dxfCtx.lineTo(size, size * 2.8);
			
			dxfCtx.moveTo(-size * 0.6, size * 3.2);
			dxfCtx.lineTo(size * 0.6, size * 3.2);

			dxfCtx.moveTo(-size * 0.3, size * 3.6);
			dxfCtx.lineTo(size * 0.3, size * 3.6);

			dxfCtx.stroke();
			dxfCtx.restore(); 
		}

		function getEntityBBox(entity, inModelCoords = false) {
			if (!entity) return null;
			
            if (entity.id === 'multi' && entity.items) {
                let min_x = Infinity, min_y = Infinity, max_x = -Infinity, max_y = -Infinity;
                entity.items.forEach(item => {
                    const itemBBox = getEntityBBox(item, true); // Always get model coords for combining
                    if (itemBBox) {
                        min_x = Math.min(min_x, itemBBox.x);
                        min_y = Math.min(min_y, itemBBox.y);
                        max_x = Math.max(max_x, itemBBox.x + itemBBox.width);
                        max_y = Math.max(max_y, itemBBox.y + itemBBox.height);
                    }
                });
                
                if (min_x === Infinity) return null;

                if (inModelCoords) return { x: min_x, y: min_y, width: max_x - min_x, height: max_y - min_y };
                
                const screen_min = modelToScreen(min_x, max_y);
			    const screen_max = modelToScreen(max_x, min_y);
			    return { x: screen_min.x, y: screen_min.y, width: screen_max.x - screen_min.x, height: screen_max.y - screen_min.y };
            }
			
			// --- Handle User Drawings ---
			if (entity.id) {
				const drawing = entity;
				
				if (drawing.type === 'draw-ground') {
					const size = drawing.size || 0.5;
					const relativeCorners = [
						{ x: -size, y: 0 },
						{ x: size,  y: 0 },
						{ x: -size, y: -(size * 3.6) },
						{ x: size,  y: -(size * 3.6) },
					];

					const rotatedCorners = relativeCorners.map(c => rotatePoint(c.x, c.y, 0, 0, drawing.rotation || 0));
					
					const modelCorners = rotatedCorners.map(c => ({
						x: c.x + drawing.start.x,
						y: c.y + drawing.start.y,
					}));
					
					const min_x = Math.min(...modelCorners.map(c => c.x));
					const min_y = Math.min(...modelCorners.map(c => c.y));
					const max_x = Math.max(...modelCorners.map(c => c.x));
					const max_y = Math.max(...modelCorners.map(c => c.y));

					if (inModelCoords) {
						return { x: min_x, y: min_y, width: max_x - min_x, height: max_y - min_y };
					}
                    
					const screen_min = modelToScreen(min_x, max_y);
					const screen_max = modelToScreen(max_x, min_y);
					
					return { 
						x: screen_min.x, 
						y: screen_min.y, 
						width: screen_max.x - screen_min.x, 
						height: screen_max.y - screen_min.y 
					};
				}

				if (drawing.type === 'draw-ct' || drawing.type === 'draw-seccionador') {
					const size = drawing.size || (SYMBOL_SIZE * GLOBAL_SYMBOL_SCALE * 2);
					const modelBBox = {
						x: drawing.start.x - size,
						y: drawing.start.y - size,
						width: size * 2,
						height: size * 2,
					};
					if (inModelCoords) return modelBBox;

					const screen_min_bbox = modelToScreen(modelBBox.x, modelBBox.y + modelBBox.height);
					const screen_max_bbox = modelToScreen(modelBBox.x + modelBBox.width, modelBBox.y);

					return {
						x: screen_min_bbox.x,
						y: screen_min_bbox.y,
						width: screen_max_bbox.x - screen_min_bbox.x,
						height: screen_max_bbox.y - screen_min_bbox.y
					};
				}

				if (drawing.type === 'draw-mundo-interno') {
					const size = drawing.size; // This is model radius
					const modelBBox = {
						x: drawing.start.x - size,
						y: drawing.start.y - size,
						width: size * 2,
						height: size * 2,
					};
					if (inModelCoords) return modelBBox;

					const screen_min_bbox = modelToScreen(modelBBox.x, modelBBox.y + modelBBox.height);
					const screen_max_bbox = modelToScreen(modelBBox.x + modelBBox.width, modelBBox.y);

					return {
						x: screen_min_bbox.x,
						y: screen_min_bbox.y,
						width: screen_max_bbox.x - screen_min_bbox.x,
						height: screen_max_bbox.y - screen_min_bbox.y
					};
				}

				// When computing bounding boxes for user drawings, treat model and screen
				// coordinates explicitly.  Using a generic converter that ignores extra
				// parameters (as was done previously) results in incorrect values when
				// `inModelCoords` is true because numbers would be returned instead of
				// {x,y} objects.  Here we build start/end coordinate objects directly.
				let start, end;
				if (inModelCoords) {
					start = { x: drawing.start.x, y: drawing.start.y };
					if (drawing.end) end = { x: drawing.end.x, y: drawing.end.y };
				} else {
					start = modelToScreen(drawing.start.x, drawing.start.y);
					if (drawing.end) end = modelToScreen(drawing.end.x, drawing.end.y);
				}

				if (drawing.type === 'draw-text') {
					if (inModelCoords) {
						const estimatedWidth = (drawing.text.length * (drawing.modelHeight || 0.75)) * 0.6;
						return { x: drawing.start.x, y: drawing.start.y - drawing.modelHeight, width: estimatedWidth, height: drawing.modelHeight };
					}
					const screenFontSizeBBox = (drawing.modelHeight || 0.75) * view.scale;
					dxfCtx.font = `${screenFontSizeBBox}px Inter, sans-serif`;
					const metrics = dxfCtx.measureText(drawing.text);
					return { x: start.x, y: start.y, width: metrics.width, height: screenFontSizeBBox };
				}

				if (!drawing.end) return null;

				const x = Math.min(start.x, end.x);
				const y = Math.min(start.y, end.y);
				const width = Math.abs(start.x - end.x);
				const height = Math.abs(start.y - end.y);
				return { x, y, width, height };
			}
			
			// --- Handle DXF Entities ---
			const ent = entity;
			let min_x = Infinity, min_y = Infinity, max_x = -Infinity, max_y = -Infinity;
			if (ent.type === 'SYMBOL') {
				let sizeX = SYMBOL_SIZE * GLOBAL_SYMBOL_SCALE * (ent.xScale || 1);
				let sizeY = SYMBOL_SIZE * GLOBAL_SYMBOL_SCALE * (ent.yScale || 1);
				if (ent.symbolType === 'ct') {
					sizeX *= CT_COVER_FACTOR;
					sizeY *= CT_COVER_FACTOR;
				}
				const corners = [
					{ x: ent.position.x - sizeX, y: ent.position.y - sizeY },
					{ x: ent.position.x + sizeX, y: ent.position.y - sizeY },
					{ x: ent.position.x + sizeX, y: ent.position.y + sizeY },
					{ x: ent.position.x - sizeX, y: ent.position.y + sizeY },
				].map(p => rotatePoint(p.x, p.y, ent.position.x, ent.position.y, ent.rotation || 0));
				
				corners.forEach(p => {
					min_x = Math.min(min_x, p.x);
					min_y = Math.min(min_y, p.y);
					max_x = Math.max(max_x, p.x);
					max_y = Math.max(max_y, p.y);
				});
			} else if (ent.vertices) {
				ent.vertices.forEach(v => {
					if (v) {
						min_x = Math.min(min_x, v.x);
						min_y = Math.min(min_y, v.y);
						max_x = Math.max(max_x, v.x);
						max_y = Math.max(max_y, v.y);
					}
				});
			} else {
				return null;
			}

			if (inModelCoords) return { x: min_x, y: min_y, width: max_x - min_x, height: max_y - min_y };
			
			const screen_min = modelToScreen(min_x, max_y);
			const screen_max = modelToScreen(max_x, min_y);
			return { x: screen_min.x, y: screen_min.y, width: screen_max.x - screen_min.x, height: screen_max.y - screen_min.y };
		}
		
		function getResizeHandles(bbox) {
			if (!bbox) return [];
			const { x, y, width, height } = bbox;
			const handleSize = 8;
			const h_2 = handleSize / 2;

			const positions = {
				tl: { x: x, y: y },
				tm: { x: x + width / 2, y: y },
				tr: { x: x + width, y: y },
				ml: { x: x, y: y + height / 2 },
				mr: { x: x + width, y: y + height / 2 },
				bl: { x: x, y: y + height },
				bm: { x: x + width / 2, y: y + height },
				br: { x: x + width, y: y + height },
			};
			
			return Object.keys(positions).map(key => ({
				name: key,
				rect: {
					x: positions[key].x - h_2,
					y: positions[key].y - h_2,
					width: handleSize,
					height: handleSize,
				}
			}));
		}

		function drawSelectionHandles(drawing) {
			const bbox = getEntityBBox(drawing, false); // Screen coords
			if (!bbox) return;

			const handles = getResizeHandles(bbox);
			handles.forEach(handle => {
				dxfCtx.save();
				dxfCtx.fillStyle = '#10b981';
				dxfCtx.strokeStyle = 'white';
				dxfCtx.lineWidth = 1;
				dxfCtx.fillRect(handle.rect.x, handle.rect.y, handle.rect.width, handle.rect.height);
				dxfCtx.strokeRect(handle.rect.x, handle.rect.y, handle.rect.width, handle.rect.height);
				dxfCtx.restore();
			});
		}

        function getEntityAtScreenPos(screenX, screenY) {
            const visibleSymbols = getVisibleSymbols();
            for (let i = visibleSymbols.length - 1; i >= 0; i--) {
                const ent = visibleSymbols[i];
				const bbox = getEntityBBox(ent, false);
                if (bbox && screenX >= bbox.x && screenX <= bbox.x + bbox.width && screenY >= bbox.y && screenY <= bbox.y + bbox.height) {
                    return ent;
                }
                if (ent.labelBBox) {
                    const lbox = ent.labelBBox;
                    if (screenX >= lbox.x && screenX <= lbox.x + lbox.width && screenY >= lbox.y && screenY <= lbox.y + lbox.height) {
						return ent;
					}
                }
            }

			// Check lines
			const inflate = 5; 
			for (const line of getVisibleLinesAndPolylines()) {
				const isPointOnLine = (p1, p2, pt, tolerance) => {
					const dist = Math.abs((p2.y - p1.y) * pt.x - (p2.x - p1.x) * pt.y + p2.x * p1.y - p2.y * p1.x) / Math.sqrt(Math.pow(p2.y - p1.y, 2) + Math.pow(p2.x - p1.x, 2));
					return dist < tolerance &&
						pt.x >= Math.min(p1.x, p2.x) - tolerance && pt.x <= Math.max(p1.x, p2.x) + tolerance &&
						pt.y >= Math.min(p1.y, p2.y) - tolerance && pt.y <= Math.max(p1.y, p2.y) + tolerance;
				};

				if (line.type === 'LINE') {
					if (line.start && line.end && isPointOnLine(modelToScreen(line.start.x, line.start.y), modelToScreen(line.end.x, line.end.y), {x: screenX, y: screenY}, inflate)) return line;
				} else if (line.vertices) {
					for (let i = 0; i < line.vertices.length; i++) {
						if (!line.closed && i === line.vertices.length - 1) continue;
						const nextI = (i + 1) % line.vertices.length;
						if (line.vertices[i] && line.vertices[nextI] && isPointOnLine(modelToScreen(line.vertices[i].x, line.vertices[i].y), modelToScreen(line.vertices[nextI].x, line.vertices[nextI].y), {x: screenX, y: screenY}, inflate)) return line;
					}
				}
			}

            return null;
        }

		function getDrawingAtScreenPos(screenX, screenY) {
			const visibleUserDrawings = getVisibleUserDrawings();
			for (let i = visibleUserDrawings.length - 1; i >= 0; i--) {
				const d = visibleUserDrawings[i];
				const bbox = getEntityBBox(d, false); // Screen coords
				if (!bbox) continue;
				const inflate = 5; // Make selection easier
				
				if(d.type.includes('line')) {
					const p1 = modelToScreen(d.start.x, d.start.y);
					const p2 = modelToScreen(d.end.x, d.end.y);
					const dist = Math.abs((p2.y-p1.y)*screenX - (p2.x-p1.x)*screenY + p2.x*p1.y - p2.y*p1.x) / Math.sqrt(Math.pow(p2.y-p1.y, 2) + Math.pow(p2.x-p1.x, 2));

					if(dist < inflate &&
					   screenX >= Math.min(p1.x, p2.x) - inflate && screenX <= Math.max(p1.x, p2.x) + inflate &&
					   screenY >= Math.min(p1.y, p2.y) - inflate && screenY <= Math.max(p1.y, p2.y) + inflate
					) return d;

				} else if (screenX >= bbox.x - inflate && screenX <= bbox.x + bbox.width + inflate &&
					screenY >= bbox.y - inflate && screenY <= bbox.y + bbox.height + inflate) {
					return d;
				}
			}
			return null;
		}
		
		function getHandleAtScreenPos(screenX, screenY) {
			if (!selectedDrawingId) return null;
			const selected = userDrawings.find(d => d.id === selectedDrawingId);
			if (!selected) return null;
			
			const bbox = getEntityBBox(selected, false); // Screen coords
			if (!bbox) return null;
			
			const handles = getResizeHandles(bbox);
			for (const handle of handles) {
				const hitRect = {
					x: handle.rect.x - HANDLE_HIT_RADIUS,
					y: handle.rect.y - HANDLE_HIT_RADIUS,
					width: handle.rect.width + 2 * HANDLE_HIT_RADIUS,
					height: handle.rect.height + 2 * HANDLE_HIT_RADIUS,
				};
				if (screenX >= hitRect.x && screenX <= hitRect.x + hitRect.width &&
					screenY >= hitRect.y && screenY <= hitRect.y + hitRect.height) {
					return handle.name;
				}
			}
			return null;
		}

		function updateInfoPanelForDrawing(drawing) {
			selectedEntity = null; // Deselect any selected DXF entity
			multiSelection = [];
			deleteBtn.disabled = !drawing;
			if (!drawing) {
				infoPanel.classList.add('translate-x-full');
				return;
			}
			
			let contentHtml = `<h3 class="text-lg font-bold mb-4 border-b pb-2">Editar Dibujo</h3>
						   <div class="space-y-4 text-sm">`;

            if (drawing && (drawing.type === 'draw-ct' || drawing.type === 'draw-seccionador')) {
                const labelTitle = drawing.type === 'draw-ct' ? 'Nombre CT' : 'Nombre Seccionador';
                contentHtml += `<div>
								<label for="drawing-label-edit" class="font-semibold text-gray-600 block mb-1">${labelTitle}</label>
								<input type="text" id="drawing-label-edit" value="${drawing.label || ''}" class="w-full p-2 border border-gray-300 rounded-md">
							</div>`;
                if(drawing.type === 'draw-ct') {
                    contentHtml += `<div class="mt-4">
                        <button id="change-manual-ct-symbol-btn" class="w-full px-3 py-2 text-sm rounded bg-blue-100 text-blue-700 hover:bg-blue-200 transition-colors font-semibold">Cambiar Símbolo de CT</button>
                    </div>`;
                }
                contentHtml += `<hr class="my-4">`;
            }

			// Color Picker
			contentHtml += `<div>
								<label for="drawing-color" class="font-semibold text-gray-600 block mb-1">Color</label>
								<input type="color" id="drawing-color" value="${drawing.color || DEFAULT_DRAW_COLOR}" class="w-full h-8 p-0 border-none rounded cursor-pointer">
							</div>`;

			if (drawing.type === 'draw-rect' || drawing.type === 'draw-ellipse') {
                contentHtml += `
					<div class="mt-2">
						<label for="drawing-fill-toggle" class="flex items-center justify-between cursor-pointer">
							<span class="font-semibold text-gray-600">Relleno de color</span>
							<div class="relative inline-flex items-center cursor-pointer">
								<input type="checkbox" id="drawing-fill-toggle" class="sr-only peer" ${drawing.isFilled !== false ? 'checked' : ''}>
								<div class="w-11 h-6 bg-gray-200 rounded-full peer peer-focus:ring-2 peer-focus:ring-blue-300 peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-0.5 after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-green-500"></div>
							</div>
						</label>
					</div>
                `;
            }

			// Size/Width controls
			if (drawing.type.includes('line') || drawing.type === 'draw-ground') {
				contentHtml += `<div>
									<label for="drawing-stroke-width" class="font-semibold text-gray-600 block mb-1">Grosor</label>
									<input type="range" id="drawing-stroke-width" min="1" max="20" step="0.5" value="${drawing.strokeWidth || 1.5}" class="w-full">
								</div>`;
			}
			if (drawing.type === 'draw-text') {
				contentHtml += `<div>
									<label for="drawing-model-height" class="font-semibold text-gray-600 block mb-1">Tamaño de Texto</label>
									<input type="range" id="drawing-model-height" min="0.02" max="2.0" step="0.01" value="${drawing.modelHeight || 0.5}" class="w-full">
								</div>`;
			}
			if (drawing.type === 'draw-mundo-interno') {
				contentHtml += `<div>
									<label for="drawing-size" class="font-semibold text-gray-600 block mb-1">Tamaño Símbolo</label>
									<input type="range" id="drawing-size" min="0.01" max="0.8" step="0.01" value="${drawing.size || 0.5}" class="w-full">
								</div>`;
			} else if (drawing.type === 'draw-ground' || drawing.type === 'draw-ct' || drawing.type === 'draw-seccionador') {
				contentHtml += `<div>
									<label for="drawing-size" class="font-semibold text-gray-600 block mb-1">Tamaño Símbolo</label>
									<input type="range" id="drawing-size" min="0.01" max="3" step="0.01" value="${drawing.size || 0.5}" class="w-full">
								</div>`;
			}
            
			if (drawing.type === 'draw-seccionador') {
				contentHtml += `
					<div class="mt-4 pt-4 border-t border-gray-200">
						<label for="drawing-seccionador-toggle" class="flex items-center justify-between cursor-pointer">
							<span class="font-semibold text-gray-600">Estado: <span id="drawing-seccionador-status-text" class="font-normal text-gray-800">${drawing.isOpen ? 'Abierto' : 'Cerrado'}</span></span>
							<div class="relative inline-flex items-center cursor-pointer">
								<input type="checkbox" id="drawing-seccionador-toggle" class="sr-only peer" ${drawing.isOpen ? 'checked' : ''}>
								<div class="w-11 h-6 bg-gray-200 rounded-full peer peer-focus:ring-2 peer-focus:ring-blue-300 peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-0.5 after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-green-500"></div>
							</div>
						</label>
					</div>
				`;
				contentHtml += `
                    <div class="mt-4">
                        <button id="change-seccionador-symbol-btn" class="w-full px-3 py-2 text-sm rounded bg-blue-100 text-blue-700 hover:bg-blue-200 transition-colors font-semibold">Cambiar Símbolo</button>
                    </div>
                `;
			}

			if (drawing.type === 'draw-mundo-interno') {
				contentHtml += `
                    <div class="mt-4">
                        <button id="change-mundo-interno-symbol-btn" class="w-full px-3 py-2 text-sm rounded bg-blue-100 text-blue-700 hover:bg-blue-200 transition-colors font-semibold">Cambiar Símbolo</button>
                    </div>
                `;
			}

			// Rotation control for all drawings
			if (drawing.type !== 'draw-text') { // No se permite rotar el texto para mantener la legibilidad
				contentHtml += `<div>
									<label for="drawing-rotation" class="font-semibold text-gray-600 block mb-1">Rotación (°)</label>
									<input type="range" id="drawing-rotation" min="0" max="360" step="1" value="${drawing.rotation || 0}" class="w-full">
								</div>`;
			}
			
            if (drawing.type === 'draw-line' || drawing.type === 'draw-dashed-line') {
                contentHtml += `
                    <div class="mt-4 pt-4 border-t border-gray-200">
                        <button id="toggle-drawing-line-style-btn" class="w-full px-3 py-2 text-sm rounded bg-gray-100 text-gray-700 hover:bg-gray-200 transition-colors font-semibold">
                            ${drawing.type === 'draw-line' ? 'Cambiar a Línea Punteada' : 'Cambiar a Línea Sólida'}
                        </button>
                    </div>
                `;
            }

			contentHtml += `</div>`;
			infoContent.innerHTML = contentHtml;
			infoPanel.classList.remove('translate-x-full');


			// Add event listeners
			const labelEditInput = document.getElementById('drawing-label-edit');
            if(labelEditInput) {
                labelEditInput.addEventListener('change', (e) => {
                    if (drawing) {
                        saveHistoryState();
                        drawing.label = e.target.value.trim();
                        populateSearchSuggestions();
                        draw();
                    }
                });
            }

            const changeManualCtSymbolBtn = document.getElementById('change-manual-ct-symbol-btn');
            if (changeManualCtSymbolBtn) {
                changeManualCtSymbolBtn.addEventListener('click', () => {
                    if (drawing) {
                        ctPickerModal.dataset.editingDrawingId = drawing.id;
                        ctPickerModal.classList.remove('hidden');
                        ctPickerModal.classList.add('flex');
                    }
                });
            }

			const colorInput = document.getElementById('drawing-color');
			if (colorInput) {
				colorInput.addEventListener('input', (e) => {
					drawing.color = e.target.value;
					draw();
				});
				colorInput.addEventListener('change', () => saveHistoryState());
			}

			const fillToggle = document.getElementById('drawing-fill-toggle');
            if (fillToggle) {
                fillToggle.addEventListener('change', (e) => {
                    saveHistoryState();
                    drawing.isFilled = e.target.checked;
                    draw();
                });
            }

			const strokeWidthInput = document.getElementById('drawing-stroke-width');
			if (strokeWidthInput) {
				strokeWidthInput.addEventListener('input', (e) => {
					drawing.strokeWidth = parseFloat(e.target.value);
					draw();
				});
				strokeWidthInput.addEventListener('change', () => saveHistoryState());
			}
			
			const modelHeightInput = document.getElementById('drawing-model-height');
			if (modelHeightInput) {
				modelHeightInput.addEventListener('input', (e) => {
					drawing.modelHeight = parseFloat(e.target.value);
					draw();
				});
				modelHeightInput.addEventListener('change', () => saveHistoryState());
			}

			const sizeInput = document.getElementById('drawing-size');
			if (sizeInput) {
				sizeInput.addEventListener('input', (e) => {
					drawing.size = parseFloat(e.target.value);
					if (drawing.associatedSeccionadorId) {
						const seccionador = userDrawings.find(d => d.id === drawing.associatedSeccionadorId);
						if (seccionador) {
							// Update position based on new size and current rotation
							const offset = drawing.size + seccionador.size;
							const rad = (drawing.rotation || 0) * Math.PI / 180;
							seccionador.start.x = drawing.start.x + offset * Math.cos(rad);
							seccionador.start.y = drawing.start.y + offset * Math.sin(rad);
						}
					}
					draw();
				});
				sizeInput.addEventListener('change', () => saveHistoryState());
			}

			const rotationInput = document.getElementById('drawing-rotation');
			if (rotationInput) {
				rotationInput.addEventListener('input', (e) => {
					drawing.rotation = parseFloat(e.target.value);
					if (drawing.associatedSeccionadorId) {
						const seccionador = userDrawings.find(d => d.id === drawing.associatedSeccionadorId);
						if (seccionador) {
							const offset = drawing.size + seccionador.size;
							const rad = drawing.rotation * Math.PI / 180;
							seccionador.start.x = drawing.start.x + offset * Math.cos(rad);
							seccionador.start.y = drawing.start.y + offset * Math.sin(rad);
							seccionador.rotation = drawing.rotation; // Match rotation
						}
					}
					draw();
				});
				rotationInput.addEventListener('change', () => saveHistoryState());
			}

            const toggleDrawingLineStyleBtn = document.getElementById('toggle-drawing-line-style-btn');
            if (toggleDrawingLineStyleBtn) {
                toggleDrawingLineStyleBtn.addEventListener('click', () => {
                    saveHistoryState();
                    if (drawing.type === 'draw-line') {
                        drawing.type = 'draw-dashed-line';
                    } else {
                        drawing.type = 'draw-line';
                    }
                    updateInfoPanelForDrawing(drawing); // Refresh panel to update button text
                    draw();
                });
            }

			const changeSymbolBtn = document.getElementById('change-seccionador-symbol-btn');
			if (changeSymbolBtn) {
				changeSymbolBtn.addEventListener('click', () => {
					const styles = ['standard', 'punto-verde', 'circulo-punto-verde', 'capacitor', 'rueda'];
					const currentStyle = drawing.symbolStyle || 'standard';
					const currentIndex = styles.indexOf(currentStyle);
					const nextIndex = (currentIndex + 1) % styles.length;
					
					saveHistoryState();
					drawing.symbolStyle = styles[nextIndex];
					draw();
				});
			}
			const changeMundoInternoSymbolBtn = document.getElementById('change-mundo-interno-symbol-btn');
			if (changeMundoInternoSymbolBtn) {
				changeMundoInternoSymbolBtn.addEventListener('click', () => {
					const styles = ['solid-black-circle', 'half-f-circle'];
					const currentStyle = drawing.symbolStyle || 'solid-black-circle';
					const currentIndex = styles.indexOf(currentStyle);
					const nextIndex = (currentIndex + 1) % styles.length;
					
					saveHistoryState();
					drawing.symbolStyle = styles[nextIndex];
					draw();
				});
			}

			const seccionadorToggle = document.getElementById('drawing-seccionador-toggle');
			if (seccionadorToggle) {
				const statusText = document.getElementById('drawing-seccionador-status-text');
				seccionadorToggle.addEventListener('change', (e) => {
					saveHistoryState();
					drawing.isOpen = e.target.checked;
					if (statusText) {
						statusText.textContent = drawing.isOpen ? 'Abierto' : 'Cerrado';
					}
					draw();
				});
			}
		}

		function updateInfoPanel(entity) {
			selectedDrawingId = null;
			multiSelection = [];
			deleteBtn.disabled = !entity;
            if (entity) {
                let contentHtml = `<h3 class="text-lg font-bold mb-4 border-b pb-2">Detalles del Elemento</h3><div class="space-y-2 text-sm">`;
                
				// Handle line-like entities
				if (entity.type === 'LINE' || entity.type === 'LWPOLYLINE' || entity.type === 'POLYLINE') {
					let length = 0;
					if (entity.type === 'LINE' && entity.start && entity.end) {
						const dx = entity.end.x - entity.start.x;
						const dy = entity.end.y - entity.start.y;
						length = Math.sqrt(dx * dx + dy * dy);
					} else if (entity.vertices && entity.vertices.length > 1) {
						for (let i = 0; i < entity.vertices.length - 1; i++) {
							const p1 = entity.vertices[i];
							const p2 = entity.vertices[i+1];
							if (p1 && p2) {
								const dx = p2.x - p1.x;
								const dy = p2.y - p1.y;
								length += Math.sqrt(dx * dx + dy * dy);
							}
						}
						if (entity.closed && entity.vertices.length > 2) {
							const p1 = entity.vertices[entity.vertices.length - 1];
							const p2 = entity.vertices[0];
							if(p1 && p2){
								const dx = p2.x - p1.x;
								const dy = p2.y - p1.y;
								length += Math.sqrt(dx * dx + dy * dy);
							}
						}
					}
					
					contentHtml += `<div><strong class="text-gray-600">Capa:</strong> <span class="text-gray-800 font-mono">${entity.layer}</span></div>`;
					contentHtml += `<div><strong class="text-gray-600">Tipo de Línea:</strong> <span class="text-gray-800 font-mono">${entity.linetype || 'Continuo'}</span></div>`;
					contentHtml += `<div><strong class="text-gray-600">Longitud:</strong> <span class="text-gray-800 font-mono">${length.toFixed(2)} m</span></div>`;

                    const isDashed = getDashPatternForLinetype(entity.linetype) !== null;
                    contentHtml += `
                        <div class="mt-4 pt-4 border-t border-gray-200">
                            <button id="toggle-dxf-line-style-btn" class="w-full px-3 py-2 text-sm rounded bg-gray-100 text-gray-700 hover:bg-gray-200 transition-colors font-semibold">
                                ${isDashed ? 'Cambiar a Línea Sólida' : 'Cambiar a Línea Punteada'}
                            </button>
                        </div>
                    `;
				} 
				// Handle other entities (symbols)
				else {
					if (entity.symbolType === 'ct' || entity.symbolType === 'seccionador') {
						 contentHtml += `
							<div>
								<label for="entity-label-edit" class="font-semibold text-gray-600 block mb-1">Nombre</label>
								<input type="text" id="entity-label-edit" value="${entity.label || ''}" class="w-full p-2 border border-gray-300 rounded-md">
							</div>`;
					} else if(entity.label) {
						contentHtml += `<div><strong class="text-gray-600">Nombre:</strong> <span class="text-gray-800 font-mono">${entity.label}</span></div>`;
					}

					if(entity.symbolType) {
						let typeDisplay = entity.symbolType;
						if (typeDisplay === 'ct') typeDisplay = 'Centro';
						contentHtml += `<div><strong class="text-gray-600">Tipo:</strong> <span class="text-gray-800">${typeDisplay}</span></div>`;
					}
					if(entity.blockName) contentHtml += `<div><strong class="text-gray-600">Bloque:</strong> <span class="text-gray-800 font-mono">${entity.blockName}</span></div>`;
					if(entity.position) contentHtml += `<div><strong class="text-gray-600">Posición:</strong> <span class="text-gray-800 font-mono">X: ${entity.position.x.toFixed(2)}, Y: ${entity.position.y.toFixed(2)}</span></div>`;
					if(entity.connection) contentHtml += `<div><strong class="text-gray-600">Conexión:</strong> <span class="text-gray-800 font-mono">${entity.connection}</span></div>`;

					if (entity.extendedAttributes) {
						contentHtml += `<h4 class="text-md font-semibold mt-4 border-t pt-2">Atributos Extendidos:</h4><div class="space-y-1 mt-2 text-xs">`;
						for (const key in entity.extendedAttributes) {
							if (key !== '1018' && key !== '1019') {
								 contentHtml += `<div><strong class="text-gray-500 font-mono">${key}:</strong> <span class="text-gray-800 font-mono break-all">${entity.extendedAttributes[key]}</span></div>`;
							}
						}
						contentHtml += `</div>`;
					}

					if (entity.symbolType === 'ct' || entity.symbolType === 'seccionador') {
						contentHtml += `
							<div class="mt-4 pt-4 border-t border-gray-200">
								<label for="entity-label-scale" class="font-semibold text-gray-600 block mb-1">Tamaño de Etiqueta</label>
								<input type="range" id="entity-label-scale" min="10" max="400" step="5" value="${(entity.labelScale || 1) * 100}" class="w-full">
							</div>
						`;
					}
					
					if (entity.symbolType === 'ct') {
						contentHtml += `
							<div class="mt-4 pt-4 border-t border-gray-200">
								<button id="change-ct-icon-btn" class="w-full px-3 py-2 text-sm rounded bg-blue-100 text-blue-700 hover:bg-blue-200 transition-colors font-semibold">Cambiar Icono de CT</button>
							</div>
						`;
					}
					
					if (entity.symbolType === 'seccionador') {
						contentHtml += `
							<div class="mt-4 pt-4 border-t border-gray-200">
								<label for="seccionador-toggle" class="flex items-center justify-between cursor-pointer">
									<span class="font-semibold text-gray-600">Estado: <span id="seccionador-status-text" class="font-normal text-gray-800">${entity.isOpen ? 'Abierto' : 'Cerrado'}</span></span>
									<div class="relative inline-flex items-center cursor-pointer">
										<input type="checkbox" id="seccionador-toggle" class="sr-only peer" ${entity.isOpen ? 'checked' : ''}>
										<div class="w-11 h-6 bg-gray-200 rounded-full peer peer-focus:ring-2 peer-focus:ring-blue-300 peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-0.5 after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-green-500"></div>
									</div>
								</label>
							</div>
						`;
					}
				}

                contentHtml += `</div>`;
                infoContent.innerHTML = contentHtml;
                infoPanel.classList.remove('translate-x-full');

                const entityLabelEdit = document.getElementById('entity-label-edit');
                if (entityLabelEdit) {
                    entityLabelEdit.addEventListener('change', (e) => {
                        if (selectedEntity) {
                            saveHistoryState();
                            selectedEntity.label = e.target.value.trim();
                            populateSearchSuggestions();
                            draw();
                        }
                    });
                }
				
                const toggleDxfLineStyleBtn = document.getElementById('toggle-dxf-line-style-btn');
                if (toggleDxfLineStyleBtn) {
                    toggleDxfLineStyleBtn.addEventListener('click', () => {
                        if (selectedEntity) {
                            saveHistoryState();
                            const isCurrentlyDashed = getDashPatternForLinetype(selectedEntity.linetype) !== null;
                            
                            if (isCurrentlyDashed) {
                                selectedEntity.linetype = 'CONTINUOUS';
                            } else {
                                selectedEntity.linetype = 'DASHED'; // A generic dashed type my function will recognize
                            }
                            updateInfoPanel(selectedEntity); // Refresh panel
                            draw();
                        }
                    });
                }

				const labelScaleInput = document.getElementById('entity-label-scale');
				if (labelScaleInput) {
					labelScaleInput.addEventListener('input', (e) => {
						if (selectedEntity) {
							selectedEntity.labelScale = parseFloat(e.target.value) / 100;
							draw();
						}
					});
					labelScaleInput.addEventListener('change', () => {
						if (selectedEntity) saveHistoryState();
					});
				}

				if (entity.symbolType === 'ct') {
					const changeCtIconBtn = document.getElementById('change-ct-icon-btn');
					if (changeCtIconBtn) {
						changeCtIconBtn.addEventListener('click', () => {
							if (selectedEntity && selectedEntity.symbolType === 'ct') {
								saveHistoryState();
								const iconTypes = ['plain', 'triangle', 'solid-circle', 'dotted-circle', 'rhombus', 'pp-circle', 'pp-solid-circle', 'parallel-lines-circle', 'pp-parallel-lines-circle', 'circle-rhombus', 'hexagon', 'switch'];
								const currentIndex = iconTypes.indexOf(selectedEntity.ctIconType || 'plain');
								const nextIndex = (currentIndex + 1) % iconTypes.length;
								selectedEntity.ctIconType = iconTypes[nextIndex];
								draw();
							}
						});
					}
				}

				if (entity.symbolType === 'seccionador') {
					const toggle = document.getElementById('seccionador-toggle');
					const statusText = document.getElementById('seccionador-status-text');
					if (toggle && statusText) {
						toggle.addEventListener('change', (e) => {
							if (selectedEntity) {
								saveHistoryState();
								selectedEntity.isOpen = e.target.checked;
								statusText.textContent = selectedEntity.isOpen ? 'Abierto' : 'Cerrado';
								draw();
							}
						});
					}
				}

            } else {
                infoPanel.classList.add('translate-x-full');
            }
        }

		function updateManualModeTitle() {
			manualModeToggleContainer.title = isManualModeEnabled ? "Bloquear Movimiento" : "Habilitar Movimiento";
		}

                /**
                 * Compress the layout by moving symbols and scaling inter‑connecting lines.
                 *
                 * @param {string} mode            'all' | 'horizontal' | 'vertical'
                 * @param {boolean} skipHistory    when true, do not push a deep copy of the state to the undo stack.  
                 *                                 Compressing diagrams with large DXF files can generate huge
                 *                                 arrays; cloning them via JSON.stringify is expensive and may
                 *                                 freeze the application.  Passing `true` here prevents
                 *                                 `saveHistoryState()` from being called.
                 */
                function compressLayout(mode = 'all', skipHistory = false) {
            // Only include symbols that have a valid position (DXF) or a start point (user drawing).
            // Some manually created drawings may accidentally have a `symbolType` but no coordinate
            // information; those would cause `pos` to be undefined when computing centroids and
            // subsequently break the compression routine.  Filter them out up front.
            // If there are any user drawn elements on the canvas, skip compression entirely.
            // Mixing freehand drawings with compression has been shown to cause
            // performance issues.  We notify the user and abort.
            if (userDrawings.length > 0) {
                showConfirm(
                    'No se puede comprimir mientras haya dibujos a mano en el lienzo.\nElimina o guarda los dibujos antes de intentar comprimir.',
                    () => {}
                );
                return;
            }

            /*
             * Only consider imported DXF symbols and lines.  Since we require that
             * there be at least two symbols to compress, ignoring user drawings
             * prevents unnecessary processing while still allowing the diagram to
             * compress correctly once the manual elements are removed.
             */
            const allSymbols = [...getVisibleSymbols()];
            const allLines = [...getVisibleLinesAndPolylines()];

            if (allSymbols.length < 2) return;

            // Only save the current state for undo if not skipped.  
            // Saving a history snapshot clones the entire data model via JSON.stringify,
            // which can be extremely slow when a large DXF has been loaded.
            if (!skipHistory) {
                saveHistoryState();
            }

			// --- 0. Store current view center ---
			const canvasContainer = document.getElementById('visualization-container');
			const viewCenterX = canvasContainer.clientWidth / 2;
			const viewCenterY = canvasContainer.clientHeight / 2;
			const oldCenterModel = screenToModel(viewCenterX, viewCenterY);

			// --- 1. Group symbols into components (CTs with their outlets) ---
			const components = [];
			const assignedSymbols = new Set();

			// Find all CTs and build components around them
			const allCts = allSymbols.filter(s => s.symbolType === 'ct');
			allCts.forEach(ct => {
				if (assignedSymbols.has(ct)) return;

				const component = {
					symbols: [ct],
					centroid: { x: 0, y: 0 }
				};
				assignedSymbols.add(ct);

				// Find associated seccionadores (outlets)
				let outlets = [];
				// For manually drawn CTs with associated seccionador
				if (ct.associatedSeccionadorId) {
					const outlet = allSymbols.find(s => s.id === ct.associatedSeccionadorId);
					if (outlet) outlets.push(outlet);
				}
				// For DXF CTs, check outlets array (populated by proximity on load)
				if (ct.outlets && ct.outlets.length > 0) {
					ct.outlets.forEach(outletInfo => {
						const outlet = allSymbols.find(s => s.label === outletInfo.name);
						if (outlet && !assignedSymbols.has(outlet)) outlets.push(outlet);
					});
				}
				
				outlets.forEach(outlet => {
					 if (!assignedSymbols.has(outlet)) {
						component.symbols.push(outlet);
						assignedSymbols.add(outlet);
					 }
				});
				
				components.push(component);
			});

			// Any remaining symbols become their own component
			allSymbols.forEach(s => {
				if (!assignedSymbols.has(s)) {
					components.push({
						symbols: [s],
						centroid: { x: 0, y: 0 }
					});
					assignedSymbols.add(s);
				}
			});

			if (components.length < 2) return; // Not enough separate components to compress

			// --- 2. Calculate centroids ---
			let globalCentroid = { x: 0, y: 0 };
            components.forEach(c => {
                let sumX = 0, sumY = 0;
                let validCount = 0;
                c.symbols.forEach(s => {
                    // Obtain the model position; some malformed drawings might not have either property
                    const pos = s.position || s.start;
                    if (pos && typeof pos.x === 'number' && typeof pos.y === 'number') {
                        sumX += pos.x;
                        sumY += pos.y;
                        validCount++;
                    }
                });
                // If no valid positions were found, leave centroid unchanged to avoid NaN values
                if (validCount > 0) {
                    c.centroid.x = sumX / validCount;
                    c.centroid.y = sumY / validCount;
                } else {
                    c.centroid.x = 0;
                    c.centroid.y = 0;
                }
                globalCentroid.x += c.centroid.x;
                globalCentroid.y += c.centroid.y;
            });
			globalCentroid.x /= components.length;
			globalCentroid.y /= components.length;

			// --- 3. Calculate new positions and translation deltas ---
			const scaleFactor = 0.5;

			const newCenterX = (mode === 'all' || mode === 'horizontal')
				? globalCentroid.x + (oldCenterModel.x - globalCentroid.x) * scaleFactor
				: oldCenterModel.x;
			const newCenterY = (mode === 'all' || mode === 'vertical')
				? globalCentroid.y + (oldCenterModel.y - globalCentroid.y) * scaleFactor
				: oldCenterModel.y;
			const newCenterModel = { x: newCenterX, y: newCenterY };

			components.forEach(c => {
				const newCentroidX = (mode === 'all' || mode === 'horizontal')
					? globalCentroid.x + (c.centroid.x - globalCentroid.x) * scaleFactor
					: c.centroid.x;
				const newCentroidY = (mode === 'all' || mode === 'vertical')
					? globalCentroid.y + (c.centroid.y - globalCentroid.y) * scaleFactor
					: c.centroid.y;
				c.delta = {
					x: newCentroidX - c.centroid.x,
					y: newCentroidY - c.centroid.y
				};
			});

			// Create a map of old symbol positions to their component delta for line translation
			const symbolPosToDeltaMap = new Map();
            components.forEach(c => {
                c.symbols.forEach(s => {
                    const pos = s.position || s.start;
                    if (!pos || typeof pos.x !== 'number' || typeof pos.y !== 'number') return;
                    const key = `${pos.x.toFixed(4)},${pos.y.toFixed(4)}`;
                    symbolPosToDeltaMap.set(key, c.delta);
                });
            });

			// --- 4. Apply transformations ---
			// Translate symbols
			components.forEach(c => {
				c.symbols.forEach(s => {
					if (s.position) { // DXF symbol
						s.position.x += c.delta.x;
						s.position.y += c.delta.y;
					} else if (s.start) { // User drawing
						s.start.x += c.delta.x;
						s.start.y += c.delta.y;
						 if (s.end) { // For shapes like rects, although symbols shouldn't have .end
							s.end.x += c.delta.x;
							s.end.y += c.delta.y;
						}
					}
				});
			});

			// Translate lines
			allLines.forEach(line => {
				const translateVertex = (v) => {
					const key = `${v.x.toFixed(4)},${v.y.toFixed(4)}`;
					const delta = symbolPosToDeltaMap.get(key);
					if (delta) { // This vertex is attached to a symbol, move it with the symbol's component
						v.x += delta.x;
						v.y += delta.y;
					} else { // Intermediate vertex, scale towards global centroid
						if (mode === 'all' || mode === 'horizontal') {
							v.x = globalCentroid.x + (v.x - globalCentroid.x) * scaleFactor;
						}
						if (mode === 'all' || mode === 'vertical') {
							v.y = globalCentroid.y + (v.y - globalCentroid.y) * scaleFactor;
						}
					}
				};

				if (line.vertices) { // DXF line/polyline
					line.vertices.forEach(translateVertex);
					if(line.type === 'LINE' && line.vertices.length >= 2){
						line.start = line.vertices[0];
						line.end = line.vertices[1];
					}
				} else if (line.start && line.end) { // User drawn line
					translateVertex(line.start);
					translateVertex(line.end);
				}
			});

            // Translate other user drawings (rectangles, ellipses, text, etc.) that are not
            // part of the `allLines` array and do not carry a `symbolType`.  These drawings
            // should scale towards the global centroid in the same way as intermediate
            // vertices.  Without this step, only the DXF lines would compress, leaving
            // manually drawn elements static.
            /*
             * Do not scale or translate user‑drawn elements.  Leaving them untouched
             * prevents performance issues and keeps manual annotations where the user
             * placed them.  Only the imported DXF content participates in
             * compression.
             */

			// --- 5. Recalculate view and redraw ---
			computeExtents();
			
			// Adjust view to keep the old center point at the center of the screen
			view.offsetX = viewCenterX - ((newCenterModel.x - extents.minX) * view.scale);
			view.offsetY = viewCenterY - ((extents.maxY - newCenterModel.y) * view.scale);

			draw();
		}

		// --- EVENT LISTENERS ---
		window.addEventListener('keydown', e => {
			if (e.key === 'Shift') isShiftPressed = true;

			// No activar los atajos si el usuario está escribiendo en un campo de texto
			const activeEl = document.activeElement;
			if (activeEl && (activeEl.tagName === 'INPUT' || activeEl.tagName === 'TEXTAREA')) {
				return;
			}

			if (e.ctrlKey && (e.key === 'z' || e.key === 'Z')) {
                e.preventDefault();
                undo();
            } else if (e.ctrlKey && (e.key === 'y' || e.key === 'Y')) {
                e.preventDefault();
                redo();
            } else if (e.key === 'Delete' || e.key === 'Backspace') {
				e.preventDefault();
				// Trigger the same logic as the delete button
				if (!deleteBtn.disabled) {
					deleteBtn.click();
				}
			}
		});
		window.addEventListener('keyup', e => {
			if (e.key === 'Shift') isShiftPressed = false;
		});

		searchInput.addEventListener('change', (e) => {
			const query = e.target.value;
			if (!query) return;
			
			const lowerCaseQuery = query.toLowerCase();

			let found = false;
			let targetPoint = null;

			// Search in symbols first
			for (const sym of getVisibleSymbols()) {
				const displayLabel = getDisplayLabel(sym).toLowerCase();
				if (displayLabel && displayLabel === lowerCaseQuery) {
					selectedEntity = sym;
					selectedDrawingId = null;
					selectedGroupId = null;
					multiSelection = [];
					updateInfoPanel(sym);
					targetPoint = sym.position;
					found = true;
					break;
				}
			}

			if (!found) {
				for (const drawing of getVisibleUserDrawings()) {
					if (drawing.label && (drawing.symbolType === 'ct' || drawing.symbolType === 'seccionador')) {
						const displayLabel = getDisplayLabel(drawing).toLowerCase();
						if (displayLabel && displayLabel === lowerCaseQuery) {
							selectedDrawingId = drawing.id;
							selectedEntity = null;
							selectedGroupId = null;
							multiSelection = [];
							updateInfoPanelForDrawing(drawing);
							targetPoint = drawing.start;
							found = true;
							break;
						}
					}
				}
			}
			
			if (found) {
				panAndZoomToPoint(targetPoint);
			} else {
				// Clear selection if nothing is found
				selectedEntity = null;
				selectedDrawingId = null;
				multiSelection = [];
				updateInfoPanel(null);
				updateInfoPanelForDrawing(null);
				draw();
			}
			
			e.target.value = ''; // Clear input after search
		});
		undoBtn.addEventListener('click', undo);
		redoBtn.addEventListener('click', redo);

		const compressMenuBtn = document.getElementById('compress-menu-btn');
		const compressMenu = document.getElementById('compress-menu');

		compressMenuBtn.addEventListener('click', (e) => {
			e.stopPropagation();
			compressMenu.classList.toggle('hidden');
		});

		document.addEventListener('click', (e) => {
			if (!compressMenu.classList.contains('hidden') && !compressMenu.contains(e.target) && !compressMenuBtn.contains(e.target)) {
				compressMenu.classList.add('hidden');
			}
		});

		document.getElementById('compress-all-btn').addEventListener('click', (e) => {
			e.preventDefault();
                        // Skip history when compressing; cloning large DXF files can freeze the app
                        compressLayout('all', true);
			compressMenu.classList.add('hidden');
		});
		document.getElementById('compress-horizontal-btn').addEventListener('click', (e) => {
			e.preventDefault();
                        compressLayout('horizontal', true);
			compressMenu.classList.add('hidden');
		});
		document.getElementById('compress-vertical-btn').addEventListener('click', (e) => {
			e.preventDefault();
                        compressLayout('vertical', true);
			compressMenu.classList.add('hidden');
		});

			resizeTextBtn.addEventListener('click', () => {
				showTextResizePrompt(100, (percentage) => {
					saveHistoryState();

					const scaleFactor = percentage / 100;

					userDrawings.forEach(d => {
						if (d.type === 'draw-text') {
							d.modelHeight = (d.modelHeight || 0.5) * scaleFactor;
						}
					});

					symbols.forEach(s => {
						if (s.symbolType === 'ct' || s.symbolType === 'seccionador') {
							s.labelScale = (s.labelScale || 1) * scaleFactor;
						}
					});

					draw();
				});
			});

		bulkChangeCtSymbolBtn.addEventListener('click', () => {
            ctPickerModal.dataset.bulkChange = 'true'; // Set a flag
            ctPickerModal.classList.remove('hidden');
            ctPickerModal.classList.add('flex');
        });

		copyImageBtn.addEventListener('click', () => {
			if (exportFormatSelect) {
				exportFormatSelect.value = exportOptions.format || 'png';
			}
			if (exportResolutionSelect) {
				exportResolutionSelect.value = (exportOptions.scale || 1).toString();
			}
			if (exportBgColorInput) {
				exportBgColorInput.value = exportOptions.backgroundColor || '#f0f0f0';
			}
			refreshExportPreview(true);
		});

		if (downloadImageBtn) {
			downloadImageBtn.addEventListener('click', downloadCurrentImage);
		}

		if (copyToClipboardBtn) {
			copyToClipboardBtn.addEventListener('click', copyImageToClipboard);
		}

		[exportFormatSelect, exportResolutionSelect].forEach(el => {
			if (!el) return;
			el.addEventListener('change', () => refreshExportPreview(false));
		});

		if (exportBgColorInput) {
			exportBgColorInput.addEventListener('input', () => refreshExportPreview(false));
		}

		closeModalBtn.addEventListener('click', () => {
			copyImageModal.classList.add('hidden');
			copyImageModal.classList.remove('flex');
			toggleExportLoading(false);
			clearClipboardNotice();
		});

		clearDrawingsBtn.addEventListener('click', () => {
			if (!dxfCanvas.classList.contains('hidden') && userDrawings.length > 0) {
				saveHistoryState();
				userDrawings = [];
				populateSearchSuggestions();
				clearDrawingsBtn.disabled = true;
				draw();
			}
		});
		
        deleteBtn.addEventListener('click', () => {
            // If there is a selection (multiple or single), present a choice to the user.
            const hasMultiSelection = multiSelection && multiSelection.length > 0;
            const hasSingleDrawing = !!selectedDrawingId;
            const hasSingleEntity = !!selectedEntity;

            if (hasMultiSelection || hasSingleDrawing || hasSingleEntity) {
                // Construct a helper to perform the original deletion logic on the selected items
                const deleteSelected = () => {
                    let somethingWasDeleted = false;

                    if (multiSelection.length > 0) {
                        saveHistoryState();
                        const idsToDelete = new Set();
                        const entitiesToDelete = new Set();

                        multiSelection.forEach(item => {
                            if (item.id) { // User drawing
                                idsToDelete.add(item.id);
                                if (item.associatedSeccionadorId) idsToDelete.add(item.associatedSeccionadorId);
                                if (item.associatedCtId) idsToDelete.add(item.associatedCtId);
                            } else { // DXF entity
                                entitiesToDelete.add(item);
                            }
                        });

                        userDrawings = userDrawings.filter(d => !idsToDelete.has(d.id));
                        symbols = symbols.filter(s => !entitiesToDelete.has(s));
                        linesAndPolylines = linesAndPolylines.filter(l => !entitiesToDelete.has(l));
                        somethingWasDeleted = true;

                    } else if (selectedDrawingId) {
                        saveHistoryState();
                        const toDelete = userDrawings.find(d => d.id === selectedDrawingId);
                        let idsToDelete = new Set([selectedDrawingId]);
                        if (toDelete) {
                            if (toDelete.associatedSeccionadorId) {
                                idsToDelete.add(toDelete.associatedSeccionadorId);
                            }
                            if (toDelete.associatedCtId) {
                                idsToDelete.add(toDelete.associatedCtId);
                            }
                        }
                        userDrawings = userDrawings.filter(d => !idsToDelete.has(d.id));
                        somethingWasDeleted = true;

                    } else if (selectedEntity) {
                        saveHistoryState();
                        const initialSymbolCount = symbols.length;
                        const initialLineCount = linesAndPolylines.length;

                        symbols = symbols.filter(s => s !== selectedEntity);
                        linesAndPolylines = linesAndPolylines.filter(l => l !== selectedEntity);

                        if (symbols.length < initialSymbolCount || linesAndPolylines.length < initialLineCount) {
                            somethingWasDeleted = true;
                        }
                    }

                    if (somethingWasDeleted) {
                        populateSearchSuggestions();
                        selectedDrawingId = null;
                        selectedGroupId = null;
                        selectedEntity = null;
                        multiSelection = [];
                        deleteBtn.disabled = true;
                        updateInfoPanel(null);
                        updateInfoPanelForDrawing(null);
                        // Solo reajustar la vista si el lienzo queda vacío
                        if (symbols.length === 0 && linesAndPolylines.length === 0 && userDrawings.length === 0) {
                            computeExtents();
                            fitViewToExtents();
                        }
                        draw();
                    }
                };

                // Helper to delete everything except the selected items
                const deleteEverythingElse = () => {
                    saveHistoryState();
                    // Determine which drawings and entities should be kept based on the current selection
                    const keepDrawingIds = new Set();
                    const keepEntities = new Set();

                    // Multi-selection of items
                    if (multiSelection.length > 0) {
                        multiSelection.forEach(item => {
                            if (item.id) {
                                keepDrawingIds.add(item.id);
                                if (item.associatedSeccionadorId) keepDrawingIds.add(item.associatedSeccionadorId);
                                if (item.associatedCtId) keepDrawingIds.add(item.associatedCtId);
                            } else {
                                keepEntities.add(item);
                            }
                        });
                    }
                    // Single selected drawing
                    if (selectedDrawingId) {
                        keepDrawingIds.add(selectedDrawingId);
                        const drawing = userDrawings.find(d => d.id === selectedDrawingId);
                        if (drawing) {
                            if (drawing.associatedSeccionadorId) keepDrawingIds.add(drawing.associatedSeccionadorId);
                            if (drawing.associatedCtId) keepDrawingIds.add(drawing.associatedCtId);
                        }
                    }
                    // Single selected entity
                    if (selectedEntity) {
                        keepEntities.add(selectedEntity);
                    }

                    // Inverse deletion: only keep the selected drawings/entities
                    userDrawings = userDrawings.filter(d => keepDrawingIds.has(d.id));
                    symbols = symbols.filter(s => keepEntities.has(s));
                    linesAndPolylines = linesAndPolylines.filter(l => keepEntities.has(l));

                    // Clear selections since other items are gone
                    populateSearchSuggestions();
                    selectedDrawingId = null;
                    selectedGroupId = null;
                    selectedEntity = null;
                    multiSelection = [];
                    deleteBtn.disabled = true;
                    updateInfoPanel(null);
                    updateInfoPanelForDrawing(null);
                    // Adjust view if empty
                    if (symbols.length === 0 && linesAndPolylines.length === 0 && userDrawings.length === 0) {
                        computeExtents();
                        fitViewToExtents();
                    }
                    draw();
                };

                // Prompt user with dual action choice
                showDualConfirm(
                    '¿Qué desea eliminar?',
                    'Eliminar selección',
                    'Eliminar todo lo demás',
                    deleteSelected,
                    deleteEverythingElse,
                    () => {}
                );
                return;
            }

            // No selection: no action
        });


		toolBtns.forEach(btn => btn.addEventListener('click', () => {
			selectedDrawingId = null;
			updateInfoPanelForDrawing(null);
			setActiveTool(btn)
		}));

		dxfCanvas.addEventListener('dblclick', e => {
			const rect = dxfCanvas.getBoundingClientRect();
			const mouseX = e.clientX - rect.left;
			const mouseY = e.clientY - rect.top;

            // Prioritize editing user-drawn text on double-click
            const clickedTextDrawing = getDrawingAtScreenPos(mouseX, mouseY);
            if (clickedTextDrawing && clickedTextDrawing.type === 'draw-text') {
                showInputPrompt("Editar texto:", (newText) => {
                    if (newText !== null) { // Allow empty text, but handle cancel
                        saveHistoryState();
                        clickedTextDrawing.text = newText;
                        draw();
                    }
                }, clickedTextDrawing.text); // Pass current text as default value
                e.preventDefault();
                return;
            }

			if (editingLabelEntity) {
				// This now also cleans up the listener if the drag is cancelled with another dblclick
				saveHistoryState();
				editingLabelEntity = null;
				dxfCanvas.style.cursor = 'grab';
				window.removeEventListener('mousemove', mouseMoveHandler);
				draw();
				return;
			}

			let clickedEntity = null;
			for (let i = symbols.length - 1; i >= 0; i--) {
				const ent = symbols[i];
				if (ent.labelBBox) {
					const bbox = ent.labelBBox;
					if (mouseX >= bbox.x && mouseX <= bbox.x + bbox.width &&
						mouseY >= bbox.y && mouseY <= bbox.y + bbox.height) {
						clickedEntity = ent;
						break; 
					}
				}
			}
			
			if (!clickedEntity) {
				for (let i = userDrawings.length - 1; i >= 0; i--) {
					const d = userDrawings[i];
					if (d.labelBBox) {
						const bbox = d.labelBBox;
						if (mouseX >= bbox.x && mouseX <= bbox.x + bbox.width &&
							mouseY >= bbox.y && mouseY <= bbox.y + bbox.height) {
							clickedEntity = d;
							break;
						}
					}
				}
			}
			
			if (clickedEntity) {
				editingLabelEntity = clickedEntity;
				dxfCanvas.style.cursor = 'move';
				window.addEventListener('mousemove', mouseMoveHandler); // Attach the move listener
				e.preventDefault();
			}
		});

		// --- Lógica de Arrastre/Pan/Selección Refactorizada para Mayor Robustez ---
		const mouseMoveHandler = (e) => {
			const rect = dxfCanvas.getBoundingClientRect();
			const currentPos = { x: e.clientX - rect.left, y: e.clientY - rect.top };
			const currentModelPos = screenToModel(currentPos.x, currentPos.y);

			if (editingLabelEntity) {
				const ent = editingLabelEntity;
				
				if (ent.id) { // User Drawing (CT or Seccionador)
					const symbolWidthInModel = ent.size;
                    const isCt = ent.symbolType === 'ct';
					const MODEL_X_OFFSET_CT = 0.8;
                    const MODEL_X_OFFSET_SECCIONADOR = 0.8;
                    const modelXOffset = isCt ? MODEL_X_OFFSET_CT : MODEL_X_OFFSET_SECCIONADOR;
					
					const defaultLabelAnchorModel = {
						x: ent.start.x + symbolWidthInModel + modelXOffset,
						y: ent.start.y
					};
					ent.labelOffset.x = currentModelPos.x - defaultLabelAnchorModel.x;
					ent.labelOffset.y = currentModelPos.y - defaultLabelAnchorModel.y;
				} else { // DXF Symbol
					const isCt = ent.symbolType === 'ct';
					const symbolWidthInModel = (SYMBOL_SIZE * GLOBAL_SYMBOL_SCALE * (ent.xScale || 1));
					const MODEL_X_OFFSET_CT = 0.8;
					const MODEL_X_OFFSET_SECCIONADOR = 0.8;
					const modelXOffset = isCt ? MODEL_X_OFFSET_CT : MODEL_X_OFFSET_SECCIONADOR;
					
					const defaultLabelAnchorModel = { 
						x: ent.position.x + symbolWidthInModel + modelXOffset, 
						y: ent.position.y 
					};

					ent.labelOffset.x = currentModelPos.x - defaultLabelAnchorModel.x;
					ent.labelOffset.y = currentModelPos.y - defaultLabelAnchorModel.y;
				}
				
				draw();
				return;
			}

			if (activeResizeHandle) {
				const selected = userDrawings.find(d => d.id === selectedDrawingId);
				if (selected) {
					const handle = activeResizeHandle;
					if (handle.includes('l')) selected.start.x = currentModelPos.x;
					if (handle.includes('r') && selected.end) selected.end.x = currentModelPos.x;
					if (handle.includes('t')) selected.start.y = currentModelPos.y;
					if (handle.includes('b') && selected.end) selected.end.y = currentModelPos.y;
					
					if ((selected.type === 'draw-rect' || selected.type === 'draw-ellipse') && selected.end) {
						const minX = Math.min(selected.start.x, selected.end.x);
						const maxX = Math.max(selected.start.x, selected.end.x);
						const minY = Math.min(selected.start.y, selected.end.y);
						const maxY = Math.max(selected.start.y, selected.end.y);
						selected.start = {x: minX, y: minY};
						selected.end = {x: maxX, y: maxY};
					}
				}
				draw();
				return;
			}
			
			if (activeDrawing) {
				if (activeDrawing.type.includes('line')) {
					const start = activeDrawing.start;
					const dx = currentModelPos.x - start.x, dy = currentModelPos.y - start.y;
					if (dx !== 0 || dy !== 0) {
						const angle = Math.atan2(dy, dx) * 180 / Math.PI, snappedAngle = Math.round(angle / 45) * 45;
						const snappedRad = snappedAngle * Math.PI / 180, dist = Math.sqrt(dx * dx + dy * dy);
						activeDrawing.end = { x: start.x + dist * Math.cos(snappedRad), y: start.y + dist * Math.sin(snappedRad) };
					}
				} else {
					activeDrawing.end = currentModelPos;
				}

                if (activeDrawing.type === 'draw-rect' || activeDrawing.type === 'draw-ellipse') {
                    const modelWidth = Math.abs(activeDrawing.end.x - activeDrawing.start.x);
                    const modelHeight = Math.abs(activeDrawing.end.y - activeDrawing.start.y);
                    let area = 0;
                    if (activeDrawing.type === 'draw-rect') {
                        area = modelWidth * modelHeight;
                    } else { // draw-ellipse
                        const rx = modelWidth / 2;
                        const ry = modelHeight / 2;
                        area = Math.PI * rx * ry;
                    }
                    const tooltip = document.getElementById('tooltip');
                    tooltip.innerHTML = `Área: ${area.toFixed(2)} m²`;
                    tooltip.style.left = `${e.clientX + 15}px`;
                    tooltip.style.top = `${e.clientY + 15}px`;
                    tooltip.style.opacity = 1;
                }

				draw();
				return;
			}
			
			if (marqueeStart) { // mousedown has occurred
				marqueeEnd = currentPos;

				if (!isPanning && !isDraggingDrawing && !isDraggingGroup && !isDraggingMultiSelection) {
					const dx = marqueeEnd.x - marqueeStart.x, dy = marqueeEnd.y - marqueeStart.y;
					if ((dx * dx + dy * dy) > 25) { // 5px threshold
						
						let actionToStart = 'pan';
						if (isManualModeEnabled && currentTool === 'pan') {
							const drawingUnderCursor = getDrawingAtScreenPos(marqueeStart.x, marqueeStart.y);
							const entityUnderCursor = getEntityAtScreenPos(marqueeStart.x, marqueeStart.y);
							const itemUnderCursor = drawingUnderCursor || entityUnderCursor;

							if (itemUnderCursor) {
								const isAlreadySelected = (multiSelection.length > 0 && multiSelection.includes(itemUnderCursor)) ||
														(selectedDrawingId && drawingUnderCursor && drawingUnderCursor.id === selectedDrawingId) ||
														(selectedEntity && entityUnderCursor && entityUnderCursor === selectedEntity);

								if (isAlreadySelected) {
									if (multiSelection.length > 0) {
										actionToStart = 'dragMultiSelection';
									} else if (selectedDrawingId) {
										actionToStart = 'dragDrawing';
									} else { // selectedEntity must be true
										actionToStart = 'dragGroup';
									}
								} else {
									// Item is not selected. In manual mode, a drag on any item selects and moves it.
									if (drawingUnderCursor) {
										actionToStart = 'dragDrawing';
									} else { // entityUnderCursor
										actionToStart = 'dragGroup';
									}
								}
							}
						}
						
						if (actionToStart === 'dragMultiSelection') {
							isDraggingMultiSelection = true;
						} else if (actionToStart === 'dragDrawing') {
							const draggedDrawing = getDrawingAtScreenPos(marqueeStart.x, marqueeStart.y);
							if (draggedDrawing) {
								isDraggingDrawing = true;
								// Al arrastrar un solo elemento, se convierte en la única selección.
								selectedDrawingId = draggedDrawing.id;
								selectedEntity = null;
								multiSelection = [];
	
								if (draggedDrawing.snapConnectionId) {
									saveHistoryState();
									const lineIdToDelete = draggedDrawing.snapConnectionId;
									userDrawings = userDrawings.filter(d => d.id !== lineIdToDelete);
									
									delete draggedDrawing.snapConnectionId;
									if (draggedDrawing.associatedSeccionadorId) {
										const seccionador = userDrawings.find(d => d.id === draggedDrawing.associatedSeccionadorId);
										if (seccionador) delete seccionador.snapConnectionId;
									}
									if (draggedDrawing.associatedCtId) {
										const ct = userDrawings.find(d => d.id === draggedDrawing.associatedCtId);
										if (ct) delete ct.snapConnectionId;
									}
								}
							}
						} else if (actionToStart === 'dragGroup') {
							const entity = getEntityAtScreenPos(marqueeStart.x, marqueeStart.y);
							if (entity) {
								isDraggingGroup = true;
								selectedGroupId = entity.groupId;
							}
						} else {
							isPanning = true;
						}
						
						dxfCanvas.style.cursor = isPanning ? 'grabbing' : 'move';
					}
				}
				
				if (currentTool === 'crop' || currentTool === 'marquee-select') { draw(); return; }

				if (isDraggingDrawing || isDraggingGroup || isDraggingMultiSelection || isPanning) {
					const screenDx = e.clientX - lastPos.x, screenDy = e.clientY - lastPos.y;
					const modelDx = screenDx / view.scale, modelDy = -screenDy / view.scale;
                    let draggedItemForSnap = null;

					if (isDraggingMultiSelection) {
						multiSelection.forEach(item => {
							if (item.id) {
								item.start.x += modelDx; item.start.y += modelDy;
								if (item.end) { item.end.x += modelDx; item.end.y += modelDy; }
							} else if (item.position) {
								item.position.x += modelDx; item.position.y += modelDy;
							} else if (item.vertices) {
								item.vertices.forEach(v => { 
                                    if (v) { v.x += modelDx; v.y += modelDy; }
                                });
								// Check if start/end exist before updating, to prevent NaN errors
								if(item.start) { item.start.x += modelDx; item.start.y += modelDy; }
								if(item.end) { item.end.x += modelDx; item.end.y += modelDy; }
							}
						});
                        const bbox = getEntityBBox({ id: 'multi', items: multiSelection }, true);
                        if (bbox) {
                            draggedItemForSnap = { x: bbox.x + bbox.width / 2, y: bbox.y + bbox.height / 2 };
                        }

					}
					else if (isDraggingDrawing) {
						const selected = userDrawings.find(d => d.id === selectedDrawingId);
						if (selected) { 
                            selected.start.x += modelDx; selected.start.y += modelDy; 
                            if (selected.end) { selected.end.x += modelDx; selected.end.y += modelDy; }

							if (selected.associatedSeccionadorId) {
								const seccionador = userDrawings.find(d => d.id === selected.associatedSeccionadorId);
								if (seccionador) {
									seccionador.start.x += modelDx;
									seccionador.start.y += modelDy;
								}
							}
							if (selected.associatedCtId) {
								const ct = userDrawings.find(d => d.id === selected.associatedCtId);
								if (ct) {
									ct.start.x += modelDx;
									ct.start.y += modelDy;
								}
							}
                            draggedItemForSnap = selected;
                        }
					} else if (isDraggingGroup) {
						symbols.forEach(s => { if (s.groupId === selectedGroupId) { s.position.x += modelDx; s.position.y += modelDy; } });
						linesAndPolylines.forEach(l => { 
							if (l.groupId === selectedGroupId) { 
								if(l.vertices) l.vertices.forEach(v => { if(v) { v.x += modelDx; v.y += modelDy; } }); 
								// Check if start/end exist before updating, to prevent NaN errors
								if(l.start) { l.start.x += modelDx; l.start.y += modelDy; } 
								if(l.end) { l.end.x += modelDx; l.end.y += modelDy; } 
							} 
						});
                        const firstSymbolInGroup = symbols.find(s => s.groupId === selectedGroupId);
                        if(firstSymbolInGroup) draggedItemForSnap = firstSymbolInGroup.position;

					} else if (isPanning) {
						view.offsetX += screenDx; view.offsetY += screenDy;
                        snapLine = null;
					}
                    
                    if (draggedItemForSnap && (!draggedItemForSnap.type || draggedItemForSnap.type !== 'draw-text')) {
                        updateSnapLine(draggedItemForSnap);
                    } else if (!isPanning) {
                        snapLine = null;
                    }

					lastPos = { x: e.clientX, y: e.clientY };
					draw();
				}
			}
		};

		const mouseUpHandler = (e) => {
			if (e.button !== 0) return;

            const tempSnapLine = snapLine ? { ...snapLine } : null;
            // We reset snapLine here, before any potential early returns. The final snap logic will use tempSnapLine.
            snapLine = null;
			
			const wasADragOperation = activeResizeHandle || isDraggingDrawing || isDraggingGroup || isDraggingMultiSelection;
			if(wasADragOperation) {
                if (tempSnapLine && isDraggingDrawing && selectedDrawingId) {
                    const draggedDrawing = userDrawings.find(d => d.id === selectedDrawingId);
                    let ct, seccionador;

                    if (draggedDrawing && draggedDrawing.type === 'draw-ct') {
                        ct = draggedDrawing;
                        seccionador = userDrawings.find(d => d.id === ct.associatedSeccionadorId);
                    } else if (draggedDrawing && draggedDrawing.type === 'draw-seccionador') {
                        seccionador = draggedDrawing;
                        ct = userDrawings.find(d => d.id === seccionador.associatedCtId);
                    }

                    if (ct && seccionador) {
                        const ctCenter = ct.start;
                        const networkConnectionPoint = tempSnapLine.start;
                        
                        const dx = networkConnectionPoint.x - ctCenter.x;
                        const dy = networkConnectionPoint.y - ctCenter.y;
                        const newAngleRad = Math.atan2(dy, dx);
                        const newAngleDeg = newAngleRad * 180 / Math.PI;

                        ct.rotation = newAngleDeg;
                        const offset = ct.size + seccionador.size;
                        seccionador.start = { x: ct.start.x + offset * Math.cos(newAngleRad), y: ct.start.y + offset * Math.sin(newAngleRad) };
                        seccionador.rotation = newAngleDeg;

                        const size = seccionador.size;
                        const center = seccionador.start;
                        const rotation = seccionador.rotation || 0;
                        
                        const verticesToTest = [ {x: 0, y: -size}, {x: size, y: 0}, {x: 0, y: size}, {x: -size, y: 0} ];
                        const worldVertices = verticesToTest.map(v => {
                            const rotated = rotatePoint(v.x, v.y, 0, 0, rotation);
                            return { x: rotated.x + center.x, y: rotated.y + center.y };
                        });

                        let closestVertex = null, minVertexDist = Infinity;
                        worldVertices.forEach(wv => {
                            const dist = Math.sqrt(Math.pow(wv.x - networkConnectionPoint.x, 2) + Math.pow(wv.y - networkConnectionPoint.y, 2));
                            if (dist < minVertexDist) { minVertexDist = dist; closestVertex = wv; }
                        });

                        if (closestVertex) {
                            const permanentSnapLine = { id: crypto.randomUUID(), type: 'draw-line', start: { ...networkConnectionPoint }, end: { ...closestVertex }, color: '#ef4444', strokeWidth: 1.5, rotation: 0 };
                            addToVisibleEntitiesIfFiltered(permanentSnapLine);
                            userDrawings.push(permanentSnapLine);
                            ct.snapConnectionId = permanentSnapLine.id;
                            seccionador.snapConnectionId = permanentSnapLine.id;
                        }
                    } else if (draggedDrawing) {
                         const permanentSnapLine = { id: crypto.randomUUID(), type: 'draw-line', start: { ...tempSnapLine.start }, end: { ...tempSnapLine.end }, color: '#3b82f6', strokeWidth: 1.5, rotation: 0 };
                        addToVisibleEntitiesIfFiltered(permanentSnapLine);
                        userDrawings.push(permanentSnapLine);
                        draggedDrawing.snapConnectionId = permanentSnapLine.id;
                    }
                }
				saveHistoryState();
			}
			else if (activeDrawing) {
				document.getElementById('tooltip').style.opacity = 0;
				const start = activeDrawing.start;
				const end = activeDrawing.end;
				const isClick = Math.abs(start.x - end.x) < 0.1 && Math.abs(start.y - end.y) < 0.1;
				if (!isClick) {
					if (activeDrawing.type === 'draw-rect' || activeDrawing.type === 'draw-ellipse') {
						const minX = Math.min(start.x, end.x), maxX = Math.max(start.x, end.x);
						const minY = Math.min(start.y, end.y), maxY = Math.max(start.y, end.y);
						activeDrawing.start = {x: minX, y: minY}; activeDrawing.end = {x: maxX, y: maxY};
					}
					saveHistoryState();
					addToVisibleEntitiesIfFiltered(activeDrawing);
					userDrawings.push(activeDrawing); clearDrawingsBtn.disabled = false;
				}
				activeDrawing = null; setActiveTool(null);
			}
			else if (marqueeStart && marqueeEnd) {
				const dx = marqueeEnd.x - marqueeStart.x, dy = marqueeEnd.y - marqueeStart.y;
				const wasDragged = (dx * dx + dy * dy) > 25;

				if (!wasDragged && currentTool === 'pan') {
					const drawing = getDrawingAtScreenPos(marqueeStart.x, marqueeStart.y);
					const entity = getEntityAtScreenPos(marqueeStart.x, marqueeStart.y);
					const clickedItem = drawing || entity;
					
					if (isShiftPressed) {
						if (clickedItem) {
							const idx = multiSelection.findIndex(sel => sel === clickedItem);
							if (idx > -1) { multiSelection.splice(idx, 1); } else { multiSelection.push(clickedItem); }
						}
					} else {
						multiSelection = [];
						if (drawing) {
							selectedDrawingId = drawing.id; selectedEntity = null; selectedGroupId = null;
							updateInfoPanelForDrawing(drawing);
						} else if (entity) {
							selectedEntity = entity; selectedDrawingId = null; selectedGroupId = null;
							updateInfoPanel(entity);
						} else {
							selectedEntity = null; selectedDrawingId = null; selectedGroupId = null;
							updateInfoPanel(null); updateInfoPanelForDrawing(null);
						}
					}
					deleteBtn.disabled = multiSelection.length === 0 && !selectedDrawingId && !selectedEntity;
				} 
				else if (wasDragged && currentTool === 'marquee-select') {
					const isIntersectingSelection = marqueeEnd.x < marqueeStart.x;
					const rectModel = {
						minX: Math.min(screenToModel(marqueeStart.x, marqueeStart.y).x, screenToModel(marqueeEnd.x, marqueeEnd.y).x),
						maxX: Math.max(screenToModel(marqueeStart.x, marqueeStart.y).x, screenToModel(marqueeEnd.x, marqueeEnd.y).x),
						minY: Math.min(screenToModel(marqueeStart.x, marqueeStart.y).y, screenToModel(marqueeEnd.x, marqueeEnd.y).y),
						maxY: Math.max(screenToModel(marqueeStart.x, marqueeStart.y).y, screenToModel(marqueeEnd.x, marqueeEnd.y).y)
					};
					const newlySelected = [];
					[...getVisibleUserDrawings(), ...getVisibleSymbols(), ...getVisibleLinesAndPolylines()].forEach(item => {
						const bbox = getEntityBBox(item, true);
						if (!bbox) return;

						let isSelected = isIntersectingSelection ?
							(bbox.x < rectModel.maxX && bbox.x + bbox.width > rectModel.minX && bbox.y < rectModel.maxY && bbox.y + bbox.height > rectModel.minY) :
							(bbox.x >= rectModel.minX && (bbox.x + bbox.width) <= rectModel.maxX && bbox.y >= rectModel.minY && (bbox.y + bbox.height) <= rectModel.maxY);
						
						if (isSelected) { newlySelected.push(item); }
					});
					
					if (isShiftPressed) {
						newlySelected.forEach(item => {
							const key = item.id || item.groupId;
							if (!multiSelection.some(sel => (sel.id || sel.groupId) === key)) { multiSelection.push(item); }
						});
					} else { multiSelection = newlySelected; }
					
					deleteBtn.disabled = multiSelection.length === 0;
					setActiveTool(null);
				}
				else if (wasDragged && currentTool === 'crop') {
					saveHistoryState();
					const c1 = screenToModel(marqueeStart.x, marqueeStart.y), c2 = screenToModel(marqueeEnd.x, marqueeEnd.y);
					const newExtents = { minX: Math.min(c1.x, c2.x), maxX: Math.max(c1.x, c2.x), minY: Math.min(c1.y, c2.y), maxY: Math.max(c1.y, c2.y) };
					if (newExtents.maxX > newExtents.minX && newExtents.maxY > newExtents.minY) {
						extents = newExtents;
						clipDiagramToExtents(newExtents);
						computeExtents();
						fitViewToExtents();
						populateSearchSuggestions();
						selectedEntity = null;
						selectedDrawingId = null;
						multiSelection = [];
						resetViewBtn.classList.add('hidden');
						originalExtents = null;
					}
					setActiveTool(null);
				}
			}

            // --- Unified State Reset ---
			activeResizeHandle = null; 
            isDraggingDrawing = false; 
            isDraggingGroup = false; 
            isDraggingMultiSelection = false;
			isPanning = false; 
            marqueeStart = null; 
            marqueeEnd = null;
			dxfCanvas.style.cursor = 'grab';
			draw();

			window.removeEventListener('mousemove', mouseMoveHandler);
			window.removeEventListener('mouseup', mouseUpHandler);
		};

		dxfCanvas.addEventListener('mousedown', e => {
			if (e.button !== 0) return;

			if (editingLabelEntity) {
				saveHistoryState();
				editingLabelEntity = null;
				window.removeEventListener('mousemove', mouseMoveHandler); // Detach the move listener
				draw();
				e.stopPropagation();
				e.preventDefault();
				return;
			}
			
			const rect = dxfCanvas.getBoundingClientRect();
			const mousePos = { x: e.clientX - rect.left, y: e.clientY - rect.top };
			
			const clickedHandle = getHandleAtScreenPos(mousePos.x, mousePos.y);
			if (clickedHandle) {
				activeResizeHandle = clickedHandle;
				isPanning = false; marqueeStart = null; activeDrawing = null; isDraggingDrawing = false;
				isDraggingGroup = false; isDraggingMultiSelection = false;
				dxfCanvas.style.cursor = 'crosshair';
				lastPos = { x: e.clientX, y: e.clientY };
				window.addEventListener('mousemove', mouseMoveHandler);
				window.addEventListener('mouseup', mouseUpHandler);
				return;
			}
			
			if (currentTool.startsWith('draw-')) {
				isPanning = false; selectedDrawingId = null; updateInfoPanelForDrawing(null);
				document.getElementById('tooltip').style.opacity = 0;
				const modelPos = screenToModel(mousePos.x, mousePos.y);
				if (currentTool === 'draw-ground' || currentTool === 'draw-text') {
					let newDrawing = { id: crypto.randomUUID(), type: currentTool, start: modelPos, color: DEFAULT_DRAW_COLOR, rotation: 0 };
					if (currentTool === 'draw-ground') {
						newDrawing.size = 0.5; newDrawing.strokeWidth = 1.5;
						saveHistoryState(); addToVisibleEntitiesIfFiltered(newDrawing); userDrawings.push(newDrawing); clearDrawingsBtn.disabled = false;
						setActiveTool(null); draw();
					} else {
						showInputPrompt("Ingrese el texto:", (text) => {
							if (text) {
								newDrawing.text = text; newDrawing.modelHeight = 0.5;
								saveHistoryState(); addToVisibleEntitiesIfFiltered(newDrawing); userDrawings.push(newDrawing); populateSearchSuggestions();
								clearDrawingsBtn.disabled = false; draw();
							}
							setActiveTool(null);
						});
					}
				} else if (currentTool === 'draw-ct') {
					showInputPrompt("Ingrese el nombre del centro:", (name) => {
						if (name && name.trim()) {
							const ctId = crypto.randomUUID();
							const seccionadorId = crypto.randomUUID();

							const newCtDrawing = {
								id: ctId, type: 'draw-ct', label: name.trim(), symbolType: 'ct',
								start: modelPos, color: SYMBOL_STROKE_COLOR, size: SYMBOL_SIZE * GLOBAL_SYMBOL_SCALE,
								rotation: 0, ctIconType: activeCtIconType, labelOffset: { x: 0, y: 0 }, associatedSeccionadorId: seccionadorId 
							};
							const seccionadorSize = SYMBOL_SIZE * GLOBAL_SYMBOL_SCALE * 0.75;
							const seccionadorOffset = newCtDrawing.size + seccionadorSize;
							const seccionadorPos = { x: modelPos.x + seccionadorOffset, y: modelPos.y };
							const newSeccionadorDrawing = {
								id: seccionadorId, type: 'draw-seccionador', start: seccionadorPos, color: SYMBOL_STROKE_COLOR,
								size: seccionadorSize, rotation: 0, associatedCtId: ctId, isOpen: false, symbolStyle: 'standard'
							};
							saveHistoryState();
							addToVisibleEntitiesIfFiltered(newCtDrawing);
							addToVisibleEntitiesIfFiltered(newSeccionadorDrawing);
							userDrawings.push(newCtDrawing, newSeccionadorDrawing);
							populateSearchSuggestions();
							clearDrawingsBtn.disabled = false;
							draw();
						}
						setActiveTool(null);
					});
				} else if (currentTool === 'draw-seccionador') {
					showInputPrompt("Ingrese el nombre del elemento de red (opcional):", (name) => {
						if (name !== null) { // Proceed if user did not cancel
							const newSeccionador = {
								id: crypto.randomUUID(),
								type: 'draw-seccionador',
								label: name ? name.trim() : '',
								symbolType: 'seccionador',
								start: modelPos,
								color: SYMBOL_STROKE_COLOR,
								size: SYMBOL_SIZE * GLOBAL_SYMBOL_SCALE * 0.75,
								rotation: 0,
								isOpen: false,
								symbolStyle: activeSeccionadorIconType,
								labelOffset: { x: 0, y: 0 }
							};
							saveHistoryState();
							addToVisibleEntitiesIfFiltered(newSeccionador);
							userDrawings.push(newSeccionador);
							if (newSeccionador.label) {
								populateSearchSuggestions();
							}
							clearDrawingsBtn.disabled = false;
							draw();
						}
						setActiveTool(null);
					});
				} else if (currentTool === 'draw-mundo-interno') {
					const newMundoInterno = {
						id: crypto.randomUUID(),
						type: 'draw-mundo-interno',
						start: modelPos,
						color: SYMBOL_STROKE_COLOR,
						size: 0.2, // A reasonable default size
						rotation: 0,
						symbolStyle: activeMundoInternoIconType
					};
					saveHistoryState();
					addToVisibleEntitiesIfFiltered(newMundoInterno);
					userDrawings.push(newMundoInterno);
					clearDrawingsBtn.disabled = false;
					draw();
					setActiveTool(null);
				} else {
					activeDrawing = { id: crypto.randomUUID(), type: currentTool, start: modelPos, end: modelPos, color: DEFAULT_DRAW_COLOR, strokeWidth: 1.5, rotation: 0, isFilled: true };
				}
				window.addEventListener('mousemove', mouseMoveHandler);
				window.addEventListener('mouseup', mouseUpHandler);
				return;
			}
			
			if (currentTool === 'crop' || currentTool === 'marquee-select') {
				isPanning = false; marqueeStart = mousePos; marqueeEnd = mousePos;
				window.addEventListener('mousemove', mouseMoveHandler);
				window.addEventListener('mouseup', mouseUpHandler);
				return;
			}
			
			isPanning = false;
			marqueeStart = mousePos;
			marqueeEnd = mousePos;
			lastPos = { x: e.clientX, y: e.clientY };
			dxfCanvas.style.cursor = 'grab';

            window.addEventListener('mousemove', mouseMoveHandler);
            window.addEventListener('mouseup', mouseUpHandler);
		});

		
        dxfCanvas.addEventListener('wheel', e => {
			e.preventDefault();
			const rect = dxfCanvas.getBoundingClientRect(), mouseX = e.clientX - rect.left, mouseY = e.clientY - rect.top, oldScale = view.scale, factor = e.deltaY < 0 ? 1.1 : 0.9;
			view.scale *= factor;
			view.offsetX = mouseX - ((mouseX - view.offsetX) / oldScale) * view.scale;
			view.offsetY = mouseY - ((mouseY - view.offsetY) / oldScale) * view.scale;
			draw();
		});
        
        closeInfoPanelBtn.addEventListener('click', () => {
            infoPanel.classList.add('translate-x-full');
            selectedEntity = null;
			selectedDrawingId = null;
			selectedGroupId = null;
			multiSelection = [];
			draw();
        });

			manualModeToggle.addEventListener('change', (e) => {
				isManualModeEnabled = e.target.checked;
				updateManualModeTitle();
			});

			resetViewBtn.addEventListener('click', () => {
				if (originalExtents) {
					saveHistoryState();
					extents = { ...originalExtents };
					originalExtents = null;
				fitViewToExtents();
				resetViewBtn.classList.add('hidden');
				draw();
			}
		});

        // --- Croquis Guardados (LocalStorage) ---

		function populateSavedSketchesList() {
			const sketches = JSON.parse(localStorage.getItem('savedSketches') || '[]');
			savedSketchesList.innerHTML = '';

			if (sketches.length === 0) {
				savedSketchesList.innerHTML = '<li class="px-2 py-1 text-gray-500">No hay croquis guardados.</li>';
				return;
			}

			sketches.forEach((sketch, index) => {
				const li = document.createElement('li');
				li.className = 'flex justify-between items-center px-2 py-1 hover:bg-gray-100 rounded';
				
				const sketchName = document.createElement('span');
				sketchName.textContent = sketch.name;
				sketchName.className = 'truncate cursor-pointer flex-grow';
				sketchName.title = sketch.name;
				sketchName.dataset.index = index;
				sketchName.classList.add('load-sketch');

				const deleteBtn = document.createElement('button');
				deleteBtn.innerHTML = '<svg class="w-4 h-4 text-red-500 hover:text-red-700" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002 2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm4 0a1 1 0 012 0v6a1 1 0 11-2 0V8z" clip-rule="evenodd" /></svg>';
				deleteBtn.title = 'Eliminar croquis';
				deleteBtn.className = 'p-1 rounded-full';
				deleteBtn.dataset.index = index;
				deleteBtn.classList.add('delete-sketch');

				li.appendChild(sketchName);
				li.appendChild(deleteBtn);
				savedSketchesList.appendChild(li);
			});
		}

		saveSketchBtn.addEventListener('click', () => {
			showInputPrompt("Nombre para el croquis:", (name) => {
				if (!name || name.trim() === '') return;

				const sketches = JSON.parse(localStorage.getItem('savedSketches') || '[]');
				const sketchData = {
					name: name,
					timestamp: new Date().toISOString(),
					linesAndPolylines,
					symbols,
					userDrawings,
					extents,
					originalExtents,
				};

				sketches.push(sketchData);
				localStorage.setItem('savedSketches', JSON.stringify(sketches));
				populateSavedSketchesList();
			});
		});

		savedSketchesMenuBtn.addEventListener('click', (e) => {
			e.stopPropagation();
			savedSketchesMenu.classList.toggle('hidden');
		});

		document.addEventListener('click', (e) => {
			if (!savedSketchesMenu.classList.contains('hidden') && !savedSketchesMenu.contains(e.target) && !savedSketchesMenuBtn.contains(e.target)) {
				savedSketchesMenu.classList.add('hidden');
			}
		});
		
		savedSketchesList.addEventListener('click', (e) => {
			const target = e.target.closest('.load-sketch, .delete-sketch');
			if (!target) return;

			const index = parseInt(target.dataset.index, 10);
			const sketches = JSON.parse(localStorage.getItem('savedSketches') || '[]');
			const sketch = sketches[index];

			if (!sketch) return;

			if (target.classList.contains('load-sketch')) {
				linesAndPolylines = sketch.linesAndPolylines || [];
				symbols = sketch.symbols || [];
				userDrawings = sketch.userDrawings || [];
				extents = sketch.extents;
				originalExtents = sketch.originalExtents || null;
				activeSubgraphFilter = null;
				updateSubgraphUiState(false);
				
				if (originalExtents) {
					resetViewBtn.classList.remove('hidden');
				} else {
					resetViewBtn.classList.add('hidden');
				}

				document.getElementById('initial-message').classList.add('hidden');
				dxfCanvas.classList.remove('hidden');

				fitViewToExtents();
				resizeCanvas();
				saveHistoryState();
				
				savedSketchesMenu.classList.add('hidden');
			} else if (target.classList.contains('delete-sketch')) {
				showConfirm(`¿Estás seguro de que quieres eliminar "${sketch.name}"?`, () => {
					sketches.splice(index, 1);
					localStorage.setItem('savedSketches', JSON.stringify(sketches));
					populateSavedSketchesList();
				});
			}
		});

        const uploadSketchInput = document.getElementById('upload-sketch-file');
        const downloadSketchBtn = document.getElementById('download-sketch-btn');

        downloadSketchBtn.addEventListener('click', () => {
            const data = {
                linesAndPolylines,
                symbols,
                userDrawings,
                extents,
                originalExtents
            };
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'croquis.json';
            a.click();
            URL.revokeObjectURL(url);
        });

        uploadSketchInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
			if (!file) {
                e.target.value = '';
                return;
            }
            const reader = new FileReader();
            reader.onload = (event) => {
                const data = JSON.parse(event.target.result);
                linesAndPolylines = data.linesAndPolylines || [];
                symbols = data.symbols || [];
                userDrawings = data.userDrawings || [];
                extents = data.extents;
				originalExtents = data.originalExtents || null;
				activeSubgraphFilter = null;
				updateSubgraphUiState(false);
				
				if (originalExtents) {
					resetViewBtn.classList.remove('hidden');
				} else {
					resetViewBtn.classList.add('hidden');
				}
				
				document.getElementById('initial-message').classList.add('hidden');
				dxfCanvas.classList.remove('hidden');

                fitViewToExtents();
                resizeCanvas();
				saveHistoryState();
            };
			
			const loadFileAction = () => {
                reader.readAsText(file);
                e.target.value = '';
            };

            if (file) {
				loadFileAction();
            }
        });

        dxfInput.addEventListener('change', function(event) {
            const file = event.target.files[0];
            if (!file) {
				event.target.value = '';
				return;
			}
            const reader = new FileReader();

			const loadDxfAction = () => {
				reader.onload = function(evt) {
					const text = evt.target.result;
					blockDescMap = parseBlockDescriptions(text);
					const parser = new window.DxfParser();
					let dxf;
					try {
						dxf = parser.parseSync(text);
					} catch(err) {
						showConfirm('Error al analizar el archivo DXF: ' + err.message, () => {});
						return;
					}
					
					const isAdding = symbols.length > 0 || linesAndPolylines.length > 0;
					let offsetX = 0;

					if (isAdding) {
						const newTempExtents = { minX: Infinity };
						 dxf.entities.forEach(ent => {
							if (ent.type === 'INSERT' && ent.position) {
								 newTempExtents.minX = Math.min(newTempExtents.minX, ent.position.x);
							} else if (ent.vertices && ent.vertices.length > 0) {
								ent.vertices.forEach(v => { newTempExtents.minX = Math.min(newTempExtents.minX, v.x); });
							} else if (ent.center) {
								newTempExtents.minX = Math.min(newTempExtents.minX, ent.center.x - (ent.radius || 0));
							} else if (ent.startPoint) {
								newTempExtents.minX = Math.min(newTempExtents.minX, ent.startPoint.x);
							}
						});
						if (newTempExtents.minX !== Infinity) {
							offsetX = (extents.maxX + 20) - newTempExtents.minX;
						}
					} else {
						// First file load, so reset everything
						linesAndPolylines = [];
						symbols = [];
						originalExtents = null;
						userDrawings = [];
						resetViewBtn.classList.add('hidden');
						activeSubgraphFilter = null;
						updateSubgraphUiState(false);
						setActiveTool(null);
						selectedDrawingId = null;
						selectedGroupId = null;
					}

					processDxfBlocks(dxf);

					const getSymbolType = (blockName, blockDesc, xdata) => {
						// New high-priority rule for TR1/TR2
						if (xdata && xdata['1018']) {
							const name = xdata['1018'].toUpperCase();
							if (name.endsWith('-TR1') || name.endsWith('-TR2')) {
								return 'seccionador';
							}
						}

						const n = (blockName || '').toLowerCase(), d = (blockDesc || '').toLowerCase();
						if (d.includes('nodo')) return null;
						if (d.includes('trafo') || d.includes('transformador') || ['1612', '1489', '1493'].includes(n)) return 'ct';
						if (d.includes('seccionador') || d.includes('secc') || ['1436', '1393', '1397', '1400', '1448', '1401', '1415', '1420'].includes(n)) return 'seccionador';
						
						// New logic: Infer from xdata if type is uncertain
						if (xdata && xdata['1018']) {
							const name = xdata['1018'].toUpperCase();
							if (name.startsWith('CT')) return 'ct';
							if (name.startsWith('B')) return 'seccionador'; // Assumption based on "B1" element
                            // Heuristics for numeric IDs based on user feedback
                            if (/^\d+-\d+$/.test(name)) return 'seccionador'; // e.g., "78752-9"
                            if (/^\d+$/.test(name)) return 'ct'; // e.g., "78752"
						}
						
						return null;
					};

					const newCts = [], newSeccionadores = [], newSymbols = [], newLinesAndPolylines = [];
					const groupId = crypto.randomUUID();

					(dxf.entities || []).forEach(entity => {
						const name = entity.name;
						const desc = blockDescMap[name] || '';
						if (name && name.toUpperCase().startsWith('DE-')) return;

						if (entity.type === 'INSERT') {
                            const xdata = extractAllXData(entity);
							const symbolType = getSymbolType(name, desc, xdata);
							
							const symbolEntity = { 
								type: 'SYMBOL',
								blockName: name,
								symbolType: symbolType,
								position: { x: entity.position.x + offsetX, y: entity.position.y }, 
								rotation: entity.rotation || 0,
								xScale: entity.xScale || 1,
								yScale: entity.yScale || 1,
								label: xdata['1018'], 
								connection: xdata['1019'],
                                extendedAttributes: xdata,
								labelOffset: { x: 0, y: 0 },
								isOpen: false,
								groupId: groupId,
								labelScale: 1,
								ctIconType: 'plain'
							};
							if (symbolEntity.symbolType === 'ct') newCts.push(symbolEntity);
							else if (symbolEntity.symbolType === 'seccionador') newSeccionadores.push(symbolEntity);
							else newSymbols.push(symbolEntity);
						} else {
							const newEnt = JSON.parse(JSON.stringify(entity));
							const xdata = extractAllXData(entity);
                            newEnt.extendedAttributes = xdata;
							newEnt.groupId = groupId;
							if (newEnt.vertices) {
								newEnt.vertices.forEach(v => { v.x += offsetX; });
							}
							if (newEnt.center) {
								newEnt.center.x += offsetX;
							}
							 if (newEnt.startPoint) {
								newEnt.startPoint.x += offsetX;
							}
							
							// Asegurarse de que las líneas tengan el formato start/end que la función de dibujo espera
							if (newEnt.type === 'LINE' && newEnt.vertices && newEnt.vertices.length >= 2) {
								newEnt.start = newEnt.vertices[0];
								newEnt.end = newEnt.vertices[1];
							}

							newLinesAndPolylines.push(newEnt);
						}
					});
					
                    // --- Create virtual CTs for those that don't have a symbol ---
                    const allCtsMap = new Map();
                    newCts.forEach(ct => { if (ct.label) allCtsMap.set(ct.label, ct); });

                    // 1. Group seccionadores by the implicit CT they reference.
                    const implicitCtGroups = new Map();
                    newSeccionadores.forEach(secc => {
                        if (secc.extendedAttributes && secc.extendedAttributes['1198']) {
                            const ctRefRaw = secc.extendedAttributes['1198'];
                            const ctNameMatch = ctRefRaw.match(/\d+$/);
                            if (ctNameMatch) {
                                const ctName = ctNameMatch[0];
                                // Only consider CTs that don't already have a symbol
                                if (!allCtsMap.has(ctName)) {
                                    if (!implicitCtGroups.has(ctName)) {
                                        implicitCtGroups.set(ctName, []);
                                    }
                                    implicitCtGroups.get(ctName).push(secc);
                                }
                            }
                        }
                    });

                    const implicitCtsToCreate = [];
                    // 2. For each group, find the main seccionador and create one virtual CT.
                    implicitCtGroups.forEach((seccionadoresInGroup, ctName) => {
                        // A virtual CT is only created if there is more than one seccionador in the group,
                        // or if one of them is a main transformer entry (TR1).
                        const hasTR1 = seccionadoresInGroup.some(s => s.label && s.label.toUpperCase().endsWith('-TR1'));
                        const isGroupEligible = seccionadoresInGroup.length > 1;

                        if (hasTR1 || isGroupEligible) {
                            // 3. Find the reference seccionador for positioning. Priority: "..-TR1", then "..-1", then the first one.
                            let positionReferenceSecc = seccionadoresInGroup.find(s => s.label && s.label.toUpperCase().endsWith('-TR1'));
                            if (!positionReferenceSecc) {
                                positionReferenceSecc = seccionadoresInGroup.find(s => s.label && s.label.endsWith('-1'));
                            }
                            if (!positionReferenceSecc) {
                                positionReferenceSecc = seccionadoresInGroup[0]; // Fallback to the first one in the group
                            }

                            if (positionReferenceSecc) {
                                const newExtendedAttributes = JSON.parse(JSON.stringify(positionReferenceSecc.extendedAttributes || {}));
                                newExtendedAttributes['1018'] = ctName;

                                const virtualCt = {
                                    type: 'SYMBOL',
                                    blockName: 'VIRTUAL_CT',
                                    symbolType: 'ct',
                                    // Use the exact same insertion point coordinates as the reference seccionador (-TR1).
                                    position: { ...positionReferenceSecc.position },
                                    rotation: 0,
                                    xScale: 1,
                                    yScale: 1,
                                    label: ctName,
                                    connection: positionReferenceSecc.connection,
                                    extendedAttributes: newExtendedAttributes,
                                    labelOffset: { x: 0, y: 0 },
                                    isOpen: false,
                                    groupId: positionReferenceSecc.groupId,
									labelScale: 1,
                                    ctIconType: 'plain'
                                };
                                implicitCtsToCreate.push(virtualCt);
                                // Add to map to ensure it's considered "existing" for subsequent logic
                                allCtsMap.set(ctName, virtualCt);
                                positionReferenceSecc.isReplacedByVirtualCt = true;
                            }
                        }
                    });

                    newCts.push(...implicitCtsToCreate);

					newCts.forEach(ct => {
						ct.outlets = [];
						newSeccionadores.forEach(secc => {
							const dist = Math.sqrt(Math.pow(secc.position.x - ct.position.x, 2) + Math.pow(secc.position.y - ct.position.y, 2));
							if (dist < 1.5) { 
								ct.outlets.push({ name: secc.label, connection: secc.connection });
							}
						});
					});
					
					linesAndPolylines.push(...newLinesAndPolylines);
					symbols.push(...newSymbols, ...newCts, ...newSeccionadores);
					populateSearchSuggestions();
					computeExtents();

					if (!isAdding) {
						document.getElementById('initial-message').classList.add('hidden');
						dxfCanvas.classList.remove('hidden');
						clearDrawingsBtn.disabled = true;
						deleteBtn.disabled = true;
						undoStack = [];
						redoStack = [];
					}
					
					document.getElementById('dxf-upload-label-span').textContent = 'Añadir DXF';

					requestAnimationFrame(() => {
						fitViewToExtents();
						resizeCanvas();
						updateHistoryButtons();
						saveHistoryState();
					});
				};
				reader.readAsText(file);
				event.target.value = '';
			};
            
			if (file) {
                loadDxfAction();
            }
        });

        homeBtn.addEventListener('click', function() {
            const initialMessage = document.getElementById('initial-message');
            // Si el lienzo está visible, vamos a la pantalla de inicio
            if (!dxfCanvas.classList.contains('hidden')) {
                // Limpiar todo el estado
                linesAndPolylines = []; symbols = []; userDrawings = [];
                selectedEntity = null; originalExtents = null; selectedDrawingId = null;
                deleteBtn.disabled = true;
                updateInfoPanel(null);
                setActiveTool(null);
                view = { offsetX: 0, offsetY: 0, scale: 1 };
                document.getElementById('dxf-upload-label-span').textContent = 'DXF';
                selectedGroupId = null;
                undoStack = [];
                redoStack = [];
				multiSelection = [];
                updateHistoryButtons();
                resetViewBtn.classList.add('hidden');
				activeSubgraphFilter = null;
				updateSubgraphUiState(false);

                // Cambiar vistas
                dxfCanvas.classList.add('hidden');
                initialMessage.classList.remove('hidden');
            } else {
                // Si estamos en la pantalla de inicio, vamos a un lienzo en blanco
                dxfCanvas.classList.remove('hidden');
                initialMessage.classList.add('hidden');
                
                // Reiniciar para un lienzo en blanco
                computeExtents();
                fitViewToExtents();
                resizeCanvas();
                saveHistoryState();
            }
        });

		function populateCtSymbolPicker() {
			const grid = document.getElementById('ct-symbol-grid');
			grid.innerHTML = '';
                const iconTypes = ['plain', 'triangle', 'solid-circle', 'dotted-circle', 'rhombus', 'pp-circle', 'pp-solid-circle', 'parallel-lines-circle', 'pp-parallel-lines-circle', 'circle-rhombus', 'hexagon', 'switch', 'uni-subterraneo'];

			const iconNames = {
                'plain': 'CT Genérico',
                'triangle': 'CT Aéreo Acc. Vía Pública',
                'solid-circle': 'CT Nivel Acc. Vía Pública',
                'dotted-circle': 'CT Sub Acc. Vía Pública',
                'rhombus': 'CC Nivel Acc. Vía Pública',
                'pp-circle': 'CT Sub Acc. Prop Privada',
                'pp-solid-circle': 'CT Nivel Acc. Prop Privada',
                'parallel-lines-circle': 'CBP Nivel Acc. Vía Pública',
                'pp-parallel-lines-circle': 'CBP PP Nivel Acc. Vía Pública',
                'circle-rhombus': 'CM Nivel Acc. Vía Pública',
                'hexagon': 'CT Sumergible',
                'switch': 'Caja Seccionadora',
                'uni-subterraneo': 'UNI CT Sub Acc. Vía Pública'
            };

			iconTypes.forEach(type => {
				const wrapper = document.createElement('div');
				wrapper.className = 'p-2 border rounded-md hover:bg-gray-100 cursor-pointer flex items-center justify-between flex-col space-y-1 h-28';
				wrapper.dataset.iconType = type;

				const canvas = document.createElement('canvas');
				canvas.width = 64;
				canvas.height = 64;
				wrapper.appendChild(canvas);

				const label = document.createElement('span');
				label.className = 'text-xs text-gray-600 text-center break-words w-full px-1';
				label.textContent = iconNames[type] || type.replace(/-/g, ' ');
				wrapper.appendChild(label);

				grid.appendChild(wrapper);

				// Draw on this mini-canvas
				const ctx = canvas.getContext('2d');
				const pos = { x: 32, y: 32 }; // Center of the mini-canvas
				const size = 14; 
				const yOffset = -size * 0.2;
				
				ctx.strokeStyle = SYMBOL_STROKE_COLOR;
				ctx.lineWidth = 1.5;

				// Draw square
				ctx.fillStyle = CT_FILL_COLOR;
				ctx.fillRect(pos.x - (size * CT_COVER_FACTOR), pos.y + yOffset - (size * CT_COVER_FACTOR), (size * CT_COVER_FACTOR) * 2, (size * CT_COVER_FACTOR) * 2);
				ctx.strokeRect(pos.x - size, pos.y + yOffset - size, size * 2, size * 2);
				
				drawCtIcon(ctx, type, pos, size, yOffset);
			});
		}
		
		function populateMundoInternoSymbolPicker() {
			const grid = document.getElementById('mundo-interno-symbol-grid');
			grid.innerHTML = '';
			const iconTypes = [
				{ id: 'solid-black-circle', name: 'UNI MT Secc. Bajo Carga' },
				{ id: 'half-f-circle', name: 'MD Secc Bajo Carga C/Fusible' },
				{ id: 'arrow', name: 'MD Entrada' }
			];

			iconTypes.forEach(icon => {
				const wrapper = document.createElement('div');
				wrapper.className = 'p-2 border rounded-md hover:bg-gray-100 cursor-pointer flex items-center justify-center flex-col space-y-1';
				wrapper.dataset.iconType = icon.id;

				const canvas = document.createElement('canvas');
				canvas.width = 64;
				canvas.height = 64;
				wrapper.appendChild(canvas);

				const label = document.createElement('span');
				label.className = 'text-xs text-gray-500';
				label.textContent = icon.name;
				wrapper.appendChild(label);

				grid.appendChild(wrapper);

				const ctx = canvas.getContext('2d');
				const pos = { x: 32, y: 32 };
				const radius = 24;

				ctx.strokeStyle = SYMBOL_STROKE_COLOR;
				ctx.lineWidth = 1.5;

				switch (icon.id) {
					case 'solid-black-circle':
						ctx.fillStyle = SYMBOL_STROKE_COLOR;
						ctx.beginPath();
						ctx.arc(pos.x, pos.y, radius, 0, 2 * Math.PI);
						ctx.fill();
						break;
					case 'half-f-circle':
						// Draw black bottom half
						ctx.fillStyle = SYMBOL_STROKE_COLOR;
						ctx.beginPath();
						ctx.arc(pos.x, pos.y, radius, 0, Math.PI, false);
						ctx.fill();
						// Draw outline
						ctx.beginPath();
						ctx.arc(pos.x, pos.y, radius, 0, 2 * Math.PI);
						ctx.stroke();
						// Draw F in top half, rotated
						const fontSize = radius * 1.2;
						ctx.font = `bold ${fontSize}px Inter, sans-serif`;
						ctx.fillStyle = SYMBOL_STROKE_COLOR;
						ctx.textAlign = 'center';
						ctx.textBaseline = 'middle';
						
						ctx.save();
						ctx.translate(pos.x, pos.y - radius * 0.5); // Move to top half center
						ctx.rotate(-Math.PI / 2);                   // Rotate -90 degrees
						ctx.fillText('F', 0, 0);                     // Draw at new origin
						ctx.restore();
						break;
					case 'arrow':
						const arrowSizeBase = radius; // Use radius as the base size unit
						const lengthFactor = 1.4;
						const headHeight = arrowSizeBase * 0.5;
						const headWidth = arrowSizeBase * 0.5;
						const topY = pos.y - (arrowSizeBase * lengthFactor);
						const bottomY = pos.y + (arrowSizeBase * lengthFactor);

						ctx.beginPath();
						ctx.moveTo(pos.x, bottomY);
						ctx.lineTo(pos.x, topY);
						ctx.moveTo(pos.x - headWidth, topY + headHeight);
						ctx.lineTo(pos.x, topY);
						ctx.lineTo(pos.x + headWidth, topY + headHeight);
						ctx.stroke();
						break;
				}
			});
    	}

		function populateSeccionadorSymbolPicker() {
			const grid = document.getElementById('seccionador-symbol-grid');
			grid.innerHTML = '';
			const iconTypes = [
				{ id: 'standard', name: 'Secc. Autodesconectador' },
				{ id: 'punto-verde', name: 'MT Seccionador' },
				{ id: 'circulo-punto-verde', name: 'Secc. Bajo Carga' },
				{ id: 'capacitor', name: 'Capacitor' },
				{ id: 'rueda', name: 'MT Detector de Falla' },
				{ id: 'secz', name: 'MT Seccionalizador' }
			];

			iconTypes.forEach(icon => {
				const wrapper = document.createElement('div');
				wrapper.className = 'p-2 border rounded-md hover:bg-gray-100 cursor-pointer flex items-center justify-center flex-col space-y-1 h-28';
				wrapper.dataset.iconType = icon.id;

				const canvas = document.createElement('canvas');
				canvas.width = 64;
				canvas.height = 64;
				wrapper.appendChild(canvas);

				const label = document.createElement('span');
				label.className = 'text-xs text-gray-600 text-center break-words w-full px-1';
				label.textContent = icon.name;
				wrapper.appendChild(label);

				grid.appendChild(wrapper);

				const ctx = canvas.getContext('2d');
				ctx.strokeStyle = SYMBOL_STROKE_COLOR;
				ctx.lineWidth = 1.5;
				const secSize = 18; // Size for preview
				
				ctx.save();
				ctx.translate(32, 32); // Center of the mini-canvas

				// Re-using drawing logic from the main draw function
				if (icon.id === 'punto-verde') {
					ctx.fillStyle = ctx.strokeStyle;
					ctx.beginPath();
					ctx.moveTo(0, -secSize); ctx.lineTo(secSize, 0); ctx.lineTo(0, secSize); ctx.lineTo(-secSize, 0); ctx.closePath();
					ctx.fill();
					ctx.fillStyle = '#4ade80';
					ctx.beginPath();
					ctx.arc(0, 0, secSize * 0.35, 0, 2 * Math.PI);
					ctx.fill();
				} else if (icon.id === 'circulo-punto-verde') {
					ctx.fillStyle = ctx.strokeStyle;
					ctx.beginPath();
					ctx.arc(0, 0, secSize, 0, 2 * Math.PI);
					ctx.fill();
					ctx.fillStyle = '#4ade80';
					ctx.beginPath();
					ctx.arc(0, 0, secSize * 0.45, 0, 2 * Math.PI);
					ctx.fill();
				} else if (icon.id === 'capacitor') {
					const lineLength = secSize * 0.8;
					const gap = secSize * 0.3;
					ctx.beginPath();
					ctx.moveTo(-gap, -lineLength); ctx.lineTo(-gap, lineLength);
					ctx.moveTo(gap, -lineLength); ctx.lineTo(gap, lineLength);
					ctx.stroke();
				} else if (icon.id === 'rueda') {
					const radius = secSize;
					ctx.beginPath();
					ctx.arc(0, 0, radius, 0, 2 * Math.PI);
					for (let i = 0; i < 4; i++) {
						const angle = i * Math.PI / 4;
						ctx.moveTo(-radius * Math.cos(angle), -radius * Math.sin(angle));
						ctx.lineTo(radius * Math.cos(angle), radius * Math.sin(angle));
					}
					ctx.stroke();
				} else if (icon.id === 'secz') {
                    const halfWidth = secSize;
                    const halfHeight = secSize;
                    const dotRadius = secSize * 0.3;

                    // Top triangle (pointing down)
                    ctx.beginPath();
                    ctx.moveTo(-halfWidth, -halfHeight); // Top-left
                    ctx.lineTo(halfWidth, -halfHeight);  // Top-right
                    ctx.lineTo(0, 0);           // Tip at center
                    ctx.closePath();
                    ctx.fillStyle = SYMBOL_STROKE_COLOR;
                    ctx.fill();

                    // Bottom triangle (pointing up)
                    ctx.beginPath();
                    ctx.moveTo(-halfWidth, halfHeight); // Bottom-left
                    ctx.lineTo(halfWidth, halfHeight);  // Bottom-right
                    ctx.lineTo(0, 0);           // Tip at center
                    ctx.closePath();
                    ctx.fillStyle = SYMBOL_STROKE_COLOR;
                    ctx.fill();

                    // Green circle in the middle, on top
                    ctx.beginPath();
                    ctx.arc(0, 0, dotRadius, 0, 2 * Math.PI);
                    ctx.fillStyle = '#4ade80'; // green
                    ctx.fill();
                } else { // 'standard'
					ctx.fillStyle = ctx.strokeStyle;
					ctx.beginPath();
					ctx.moveTo(0, -secSize); ctx.lineTo(-secSize, 0); ctx.lineTo(0, secSize); ctx.closePath();
					ctx.fill();
					ctx.beginPath();
					ctx.moveTo(0, -secSize); ctx.lineTo(secSize, 0); ctx.lineTo(0, secSize); ctx.lineTo(-secSize, 0); ctx.closePath();
					ctx.stroke();
					ctx.lineWidth = 1;
					ctx.strokeStyle = '#1f2937';
					const kHeight = secSize * 0.6;
					const kWidth = kHeight * 0.5;
					const kCenterX = secSize * 0.35; 
					const verticalX = kCenterX - kWidth / 2;
					const diagonalX = kCenterX + kWidth / 2;
					ctx.beginPath();
					ctx.moveTo(verticalX, -kHeight / 2); ctx.lineTo(verticalX, kHeight / 2);
					ctx.moveTo(verticalX, 0); ctx.lineTo(diagonalX, -kHeight / 2);
					ctx.moveTo(verticalX, 0); ctx.lineTo(diagonalX, kHeight / 2);
					ctx.stroke();
				}
				ctx.restore();
			});
    	}

		drawCtBtn.addEventListener('click', () => {
			setActiveTool(null);
			ctPickerModal.classList.remove('hidden');
			ctPickerModal.classList.add('flex');
		});

		drawSeccionadorBtn.addEventListener('click', () => {
			setActiveTool(null);
			seccionadorPickerModal.classList.remove('hidden');
			seccionadorPickerModal.classList.add('flex');
		});

		closeCtPickerBtn.addEventListener('click', () => {
			ctPickerModal.classList.add('hidden');
			ctPickerModal.classList.remove('flex');
			delete ctPickerModal.dataset.editingDrawingId;
            delete ctPickerModal.dataset.bulkChange;
		});
		drawMundoInternoBtn.addEventListener('click', () => {
			setActiveTool(null);
			mundoInternoPickerModal.classList.remove('hidden');
		mundoInternoPickerModal.classList.add('flex');
	});

	closeMundoInternoPickerBtn.addEventListener('click', () => {
		mundoInternoPickerModal.classList.add('hidden');
		mundoInternoPickerModal.classList.remove('flex');
	});

	closeSeccionadorPickerBtn.addEventListener('click', () => {
		seccionadorPickerModal.classList.add('hidden');
		seccionadorPickerModal.classList.remove('flex');
	});

	ctSymbolGrid.addEventListener('click', (e) => {
		const selectedSymbolDiv = e.target.closest('[data-icon-type]');
		if (selectedSymbolDiv) {
			const newIconType = selectedSymbolDiv.dataset.iconType;
			const editingId = ctPickerModal.dataset.editingDrawingId;
			const isBulkChange = ctPickerModal.dataset.bulkChange === 'true';

			if (isBulkChange) {
                saveHistoryState();
                // Apply to all DXF symbols
                symbols.forEach(s => {
                    if (s.symbolType === 'ct') {
                        s.ctIconType = newIconType;
                    }
                });
                // Apply to all user-drawn symbols
                userDrawings.forEach(d => {
                    if (d.type === 'draw-ct') {
                        d.ctIconType = newIconType;
                    }
                });
                draw();
                delete ctPickerModal.dataset.bulkChange; // Clean up the flag
            } else if (editingId) {
				// We are editing an existing manual CT
				const drawingToUpdate = userDrawings.find(d => d.id === editingId);
				if (drawingToUpdate) {
					saveHistoryState();
					drawingToUpdate.ctIconType = newIconType;
					draw();
				}
				// Clean up
				delete ctPickerModal.dataset.editingDrawingId;

			} else {
				// Original behavior: set the type for the next drawing
				activeCtIconType = newIconType;
				currentTool = 'draw-ct';
				setActiveTool(drawCtBtn);
			}
			
			ctPickerModal.classList.add('hidden');
			ctPickerModal.classList.remove('flex');
		}
	});

	mundoInternoSymbolGrid.addEventListener('click', (e) => {
		const selectedSymbolDiv = e.target.closest('[data-icon-type]');
		if (selectedSymbolDiv) {
			activeMundoInternoIconType = selectedSymbolDiv.dataset.iconType;
			currentTool = 'draw-mundo-interno';
			setActiveTool(drawMundoInternoBtn);
			mundoInternoPickerModal.classList.add('hidden');
			mundoInternoPickerModal.classList.remove('flex');
		}
	});

	seccionadorSymbolGrid.addEventListener('click', (e) => {
		const selectedSymbolDiv = e.target.closest('[data-icon-type]');
		if (selectedSymbolDiv) {
			activeSeccionadorIconType = selectedSymbolDiv.dataset.iconType;
			currentTool = 'draw-seccionador';
			setActiveTool(drawSeccionadorBtn);
			seccionadorPickerModal.classList.add('hidden');
			seccionadorPickerModal.classList.remove('flex');
		}
	});

	subgraphFilterBtn.addEventListener('click', () => {
		cachedSubgraphGraph = buildGraphForSubgraph();
		renderSubgraphOptions(cachedSubgraphGraph);
		subgraphModal.classList.remove('hidden');
		subgraphModal.classList.add('flex');
	});

	closeSubgraphModalBtn.addEventListener('click', () => {
		subgraphModal.classList.add('hidden');
		subgraphModal.classList.remove('flex');
	});

	cancelSubgraphBtn.addEventListener('click', () => {
		subgraphModal.classList.add('hidden');
		subgraphModal.classList.remove('flex');
	});

	applySubgraphBtn.addEventListener('click', () => {
		const selectedNodes = Array.from(subgraphPointsList.querySelectorAll('input[type="checkbox"]:checked')).map(cb => cb.value);
		applySubgraphFilterWithNodes(selectedNodes, cachedSubgraphGraph);
		subgraphModal.classList.add('hidden');
		subgraphModal.classList.remove('flex');
	});

	clearSubgraphFilterBtn.addEventListener('click', () => {
		clearSubgraphFilter();
		subgraphModal.classList.add('hidden');
		subgraphModal.classList.remove('flex');
	});

	drawSeccionadorBtn.addEventListener('click', (e) => {
		setActiveTool(e.currentTarget);
	});

	helpBtn.addEventListener('click', () => {
		helpModal.classList.remove('hidden');
		helpModal.classList.add('flex');
	});

	closeHelpModalBtn.addEventListener('click', () => {
		helpModal.classList.add('hidden');
		helpModal.classList.remove('flex');
	});

	helpModal.addEventListener('click', (e) => {
		// Close if clicked on the background overlay
		if (e.target === helpModal) {
			helpModal.classList.add('hidden');
			helpModal.classList.remove('flex');
		}
	});

    uploadSketchInput.addEventListener('change', (e) => {
        const file = e.target.files[0];
		if (!file) {
                e.target.value = '';
                return;
            }
            const reader = new FileReader();
            reader.onload = (event) => {
                const data = JSON.parse(event.target.result);
                linesAndPolylines = data.linesAndPolylines || [];
                symbols = data.symbols || [];
                userDrawings = data.userDrawings || [];
                extents = data.extents;
				originalExtents = data.originalExtents || null;
				activeSubgraphFilter = null;
				updateSubgraphUiState(false);
				
				if (originalExtents) {
					resetViewBtn.classList.remove('hidden');
				} else {
					resetViewBtn.classList.add('hidden');
				}
				
				document.getElementById('initial-message').classList.add('hidden');
				dxfCanvas.classList.remove('hidden');

                fitViewToExtents();
                resizeCanvas();
				saveHistoryState();
            };
			
			const loadFileAction = () => {
                reader.readAsText(file);
                e.target.value = '';
            };

            if (file) {
				loadFileAction();
            }
        });

		// Initial population of the saved sketches list
		populateSavedSketchesList();
		populateCtSymbolPicker();
		populateMundoInternoSymbolPicker();
		populateSeccionadorSymbolPicker();
		updateSubgraphUiState(false);

        // Show the initial message on load instead of a blank canvas.
        // The "Inicio" button will now properly initialize the blank canvas.
        document.getElementById('initial-message').classList.remove('hidden');
        document.getElementById('dxf-canvas').classList.add('hidden');
    })();
    </script>
</body>
</html>
