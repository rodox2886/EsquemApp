<!DOCTYPE html>
<html lang="es">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>EsquemApp - Visualizador de Red</title>
	<script src="https://cdn.tailwindcss.com"></script>
	<script src="https://d3js.org/d3.v7.min.js"></script>
	<style>
		body {
			font-family: 'Inter', sans-serif;
			background-color: #f7fafc;
		}
		.link, .cable-line {
			fill: none;
			/* stroke is now set dynamically in JS */
			stroke-width: 1.5px;
		}
		.connection-line {
			fill: none;
			/* stroke is now set dynamically in JS */
			stroke-width: 1.5px;
		}
		.node .symbol, .custom-element-group .symbol, .connector-group .symbol {
			/* stroke is now set dynamically in JS */
			stroke-width: 1.5px;
		}
		.custom-element-group .symbol.star {
			stroke: #0ea5e9; /* Sky blue */
			fill: #e0f2fe;
		}

		.annotation {
			/* stroke is now set dynamically in JS */
			stroke-width: 1.5px;
		}
		.node.se-node .symbol {
			fill: #ef4444;
		}
		
		.node text, .custom-element-group text {
			font-size: 9px;
			font-family: 'Inter', sans-serif;
			fill: #1f2937;
			font-weight: 500;
			cursor: pointer;
			user-select: none;
		}
		
		.terminal-output-label {
			font-size: 8px;
			font-family: 'Inter', sans-serif;
			fill: #4b5563; /* Gray-600 */
			font-weight: 500;
			cursor: pointer;
			user-select: none;
		}

		.text-annotation {
			font-size: 9px;
			font-family: 'Inter', sans-serif;
			font-weight: 500;	
			/* fill is set dynamically */
			cursor: pointer;
			user-select: none;
			stroke: none;
		}
		.node.b-node text, .custom-element-group .custom-ct-text {
			fill: #800000; /* Burgundy */
			font-size: 18px;
		}

		#tooltip {
			position: absolute;
			text-align: center;
			padding: 8px;
			font: 12px sans-serif;
			background: rgba(0, 0, 0, 0.75);
			color: white;
			border-radius: 8px;
			pointer-events: none;
			opacity: 0;
			transition: opacity 0.2s;
		}
		.loader {
			border: 4px solid #f3f3f3;
			border-top: 4px solid #2563eb; /* Blue */
			border-radius: 50%;
			width: 40px;
			height: 40px;
			animation: spin 1s linear infinite;
		}
		@keyframes spin {
			0% { transform: rotate(0deg); }
			100% { transform: rotate(360deg); }
		}

		/* New Selection Style */
		.node.selected, .annotation-group.selected, .custom-element-group.selected, .link-visual.selected {
			filter: drop-shadow(0px 0px 4px rgba(37, 99, 235, 0.8)); /* Blue glow */
		}
		.node.selected .symbol, .node.selected > rect, .node.selected > circle, .node.selected > path,
		.annotation-group.selected .annotation,
		.custom-element-group.selected .symbol, .custom-element-group.selected > g > .symbol,
		.node.multi-selected .symbol, .node.multi-selected > rect, .node.multi-selected > circle, .node.multi-selected > path,
		.connector-group.connection-selected .symbol,
		.link-visual.selected {
			stroke-width: 2.5px !important;
		}


		.message-box {
			position: fixed;
			top: 50%;
			left: 50%;
			transform: translate(-50%, -50%);
			background-color: white;
			padding: 24px;
			border-radius: 12px;
			box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
			z-index: 1000;
			text-align: center;
			min-width: 320px;
		}
		.message-box button {
			margin-top: 15px;
			margin-left: 5px;
			margin-right: 5px;
			padding: 8px 15px;
			color: white;
			border: none;
			border-radius: 8px;
			cursor: pointer;
			transition: background-color 0.2s;
		}
		 .message-box .btn-confirm { background-color: #2563eb; } /* Blue */
		 .message-box .btn-confirm:hover { background-color: #1d4ed8; }
		 .message-box .btn-danger { background-color: #ef4444; }
		 .message-box .btn-danger:hover { background-color: #dc2626; }
		 .message-box .btn-cancel { background-color: #6b7280; }
		 .message-box .btn-cancel:hover { background-color: #4b5563; }

		.connector-group {
			cursor: pointer;
			transition: all 0.2s ease-in-out;
		}
		.connector-group.manual-mode {
			cursor: move;
		}
		.connector-group:hover {
			filter: brightness(1.2);
		}
		.node, .custom-element-group {
			transition: filter 0.2s ease-in-out;
		}
		.node:hover, .custom-element-group:hover {
			filter: drop-shadow(0 4px 6px rgba(0,0,0,0.1));
		}
		#info-panel {
			transition: transform 0.3s ease-in-out;
		}
		.tool-btn.active {
			background-color: #10b981 !important; /* Green */
			color: white !important;
		}
		.selection-tool-btn {
            background-color: rgba(16, 185, 129, 0.1);
        }
        .selection-tool-btn:hover {
            background-color: rgba(16, 185, 129, 0.2);
        }
        .shape-tool-btn {
            background-color: rgba(59, 130, 246, 0.1); /* Blue */
        }
        .shape-tool-btn:hover {
            background-color: rgba(59, 130, 246, 0.2); /* Blue */
        }
        .ct-tool-btn {
             background-color: rgba(245, 158, 11, 0.1); /* Amber */
        }
        .ct-tool-btn:hover {
             background-color: rgba(245, 158, 11, 0.2);
        }
		#graph-svg.drawing-mode, #graph-svg.lasso-select-mode, #graph-svg.marquee-select-mode {
			cursor: crosshair;
		}
		.annotation-group, .custom-element-group {
			cursor: move;
		}
		.symbol-option {
			cursor: pointer;
			padding: 8px;
			border-radius: 6px;
			transition: background-color 0.2s;
		}
		.symbol-option:hover {
			background-color: #f3f4f6;
		}
		.symbol-option.active {
			background-color: #d1fae5; /* Lightest Green */
			border: 1px solid #a7f3d0; /* Lighter Green */
		}
		details > summary {
			list-style: none;
			cursor: pointer;
		}
		details > summary::-webkit-details-marker {
			display: none;
		}
		details > summary::after {
			content: '▸';
			float: right;
			transition: transform 0.2s;
		}
		details[open] > summary::after {
			transform: rotate(90deg);
		}
		.resize-handle {
			fill: #10b981; /* Green */
			stroke: white;
			stroke-width: 1px;
			opacity: 0;
			pointer-events: none;
		}
		.annotation-group.selected .resize-handle {
			opacity: 1;
			pointer-events: all;
		}
		.lasso-path {
			fill: rgba(16, 185, 129, 0.1);
			stroke: #10b981;
			stroke-width: 1.5px;
			stroke-dasharray: 4 2;
		}
		.selection-marquee {
			fill: rgba(16, 185, 129, 0.1);
			stroke: #10b981;
			stroke-width: 1px;
			stroke-dasharray: 4 2;
		}
	</style>
	<link rel="preconnect" href="https://fonts.googleapis.com">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
</head>
<body class="bg-gray-100 text-gray-800">

	<div id="tooltip"></div>
	<div id="message-box-container"></div>
	<div id="context-menu" class="absolute hidden bg-white border border-gray-300 rounded-md shadow-lg z-50">
		<ul class="py-1"></ul>
	</div>
	
	<!-- Modal for copying image -->
	<div id="copy-image-modal" class="fixed inset-0 bg-black bg-opacity-50 hidden items-center justify-center z-50">
		<div class="bg-white p-6 rounded-lg shadow-xl max-w-3xl w-full">
			<div class="flex justify-between items-center mb-4">
				<h3 class="text-lg font-bold">Copiar Imagen del Diagrama</h3>
				<button id="close-modal-btn" class="text-gray-500 hover:text-gray-800 text-2xl leading-none">&times;</button>
			</div>
			<p class="text-sm text-gray-600 mb-4">Haz clic derecho sobre la imagen y selecciona "Copiar imagen" para pegarla en otro programa.</p>
			<div class="border rounded-md p-2 bg-gray-100 max-h-[60vh] overflow-auto">
				<img id="image-to-copy" src="" alt="Vista previa del diagrama" class="max-w-full h-auto mx-auto">
			</div>
		</div>
	</div>


	<div class="flex h-screen">
		<!-- Tools Sidebar -->
		<div id="tools-sidebar" class="flex flex-col items-center space-y-2 p-2 bg-white shadow-md z-20 border-r border-gray-200">
			<button id="lasso-select-btn" title="Selección Libre (Lasso)" class="tool-btn p-2 text-gray-600 rounded-md transition-colors selection-tool-btn">
				<svg class="w-6 h-6" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
					<path d="M5.6 14.3c-2.4-1.5-3.5-4.4-2.4-7.2C4.3 4.3 7 3 9.8 3.5c4.6.8 7.8 5.3 6.9 9.9-1 4.7-5.5 8-10.2 7-2-.5-3.8-1.6-5.1-3.2"/>
				</svg>
			</button>
			<button id="marquee-select-btn" title="Selección de Área" class="tool-btn p-2 text-gray-600 rounded-md transition-colors selection-tool-btn">
				<svg class="w-6 h-6" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
					<rect x="3" y="3" width="18" height="18" rx="2" ry="2" stroke-dasharray="4 2"></rect>
				</svg>
			</button>
			<hr class="w-full border-gray-200 my-1">
			<button id="draw-ct-btn" title="Añadir CT" class="tool-btn p-2 text-gray-600 rounded-md transition-colors ct-tool-btn">
				<svg class="w-6 h-6" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="-1 -1 26 26" stroke-width="1.5" stroke="currentColor">
					<rect x="2" y="2" width="20" height="20" stroke="currentColor" fill="none"/>
					<path stroke-linecap="round" stroke-linejoin="round" d="M12 6L6 16h12z" />
				</svg>
			</button>
			<button id="draw-seccionador-btn" title="Añadir Seccionador" class="tool-btn p-2 text-gray-600 rounded-md transition-colors ct-tool-btn">
				<svg class="w-6 h-6" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
					<path stroke-linecap="round" stroke-linejoin="round" d="M12 2L2 12l10 10 10-10L12 2z" />
				</svg>
			</button>
			<button id="draw-ellipse-btn" title="Elipse" class="tool-btn p-2 text-gray-600 rounded-md transition-colors shape-tool-btn">
			 <svg class="w-6 h-6" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><ellipse cx="12" cy="12" rx="10" ry="6"/></svg>
			</button>
			<button id="draw-rect-btn" title="Rectángulo" class="tool-btn p-2 text-gray-600 rounded-md transition-colors shape-tool-btn">
				<svg class="w-6 h-6" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M2.25 3h19.5a2.25 2.25 0 012.25 2.25v13.5A2.25 2.25 0 0121.75 21H2.25A2.25 2.25 0 010 18.75V5.25A2.25 2.25 0 012.25 3z" /></svg>
			</button>
			  <button id="draw-line-btn" title="Línea" class="tool-btn p-2 text-gray-600 rounded-md transition-colors shape-tool-btn">
				<svg class="w-6 h-6" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><line x1="5" y1="19" x2="19" y2="5" /></svg>
			</button>
			<button id="draw-dashed-line-btn" title="Línea Punteada" class="tool-btn p-2 text-gray-600 rounded-md transition-colors shape-tool-btn">
				<svg class="w-6 h-6" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" stroke-dasharray="4 4"><line x1="5" y1="19" x2="19" y2="5" /></svg>
			</button>
			<button id="draw-text-btn" title="Texto" class="tool-btn p-2 text-gray-600 rounded-md transition-colors shape-tool-btn">
				<svg class="w-6 h-6" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
					<text x="0" y="18" font-family="Inter, sans-serif" font-size="14" font-weight="bold">Abc</text>
				</svg>
			</button>
			  <button id="draw-ground-btn" title="Tierra Eléctrica" class="tool-btn p-2 text-gray-600 rounded-md transition-colors shape-tool-btn">
				<svg class="w-6 h-6" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
					<line x1="12" y1="2" x2="12" y2="9"></line>
					<line x1="8" y1="9" x2="16" y2="9"></line>
					<line x1="9" y1="13" x2="15" y2="13"></line>
					<line x1="10" y1="17" x2="14" y2="17"></line>
				</svg>
			</button>
		</div>

		<div class="flex-grow flex flex-col">
			<div class="max-w-6xl mx-auto p-4 md:p-6 lg:p-8 flex-grow flex flex-col w-full">
				<header class="shadow-sm rounded-xl p-4 mb-6 text-gray-800 bg-white border border-gray-200">
					<div class="flex justify-between items-start mb-4">
						<div>
							<h1 class="text-2xl font-bold">
								<span style="color: #2563eb;">Esquem</span><span style="color: #10b981;">App</span>
							</h1>
						</div>
						<div class="flex items-center gap-2">
							 <button id="undo-btn" title="Deshacer" class="p-2 bg-gray-100 hover:bg-gray-200 text-gray-700 rounded-full transition-colors disabled:opacity-50 disabled:cursor-not-allowed" disabled>
								<svg class="w-5 h-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M9 15L3 9m0 0l6-6M3 9h12a6 6 0 010 12h-3" /></svg>
							</button>
							<button id="redo-btn" title="Rehacer" class="p-2 bg-gray-100 hover:bg-gray-200 text-gray-700 rounded-full transition-colors disabled:opacity-50 disabled:cursor-not-allowed" disabled>
								<svg class="w-5 h-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M15 15l6-6m0 0l-6-6m6 6H9a6 6 0 000 12h3" /></svg>
							</button>
							<button id="delete-btn" title="Eliminar Selección" class="p-2 bg-red-100 text-red-600 rounded-full hover:bg-red-200 transition-colors disabled:bg-gray-100 disabled:text-gray-400 disabled:cursor-not-allowed" disabled>
								<svg class="w-5 h-5" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm4 0a1 1 0 012 0v6a1 1 0 11-2 0V8z" clip-rule="evenodd" /></svg>
							</button>
							<button id="clear-drawings-btn" title="Limpiar Lienzo" class="p-2 bg-yellow-100 text-yellow-600 rounded-full hover:bg-yellow-200 transition-colors disabled:bg-gray-100 disabled:text-gray-400 disabled:cursor-not-allowed" disabled>
								<svg class="w-5 h-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
									<path stroke-linecap="round" stroke-linejoin="round" d="M19.5 14.25v-2.625a3.375 3.375 0 00-3.375-3.375h-1.5A1.125 1.125 0 0113.5 7.125v-1.5a3.375 3.375 0 00-3.375-3.375H8.25m5.231 13.481L15 17.25m-4.5-15H5.625c-.621 0-1.125.504-1.125 1.125v17.25c0 .621.504 1.125 1.125 1.125h12.75c.621 0 1.125-.504 1.125-1.125V11.25a9 9 0 00-9-9z" />
								</svg>
							</button>
						</div>
					</div>
					<div class="flex flex-wrap items-center justify-between gap-2">
						<!-- Left Group -->
						<div class="flex flex-wrap items-center gap-2">
							<label for="file-upload" title="Subir archivo de datos (.csv)" class="cursor-pointer p-2 bg-gray-100 hover:bg-gray-200 text-gray-700 rounded-full shadow-sm transition-colors">
								<svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
									<path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
									<polyline points="17 8 12 3 7 8"></polyline>
									<line x1="12" y1="3" x2="12" y2="15"></line>
								</svg>
							</label>
							<input id="file-upload" type="file" class="hidden" accept=".csv, .txt">
							<span id="file-name" class="text-gray-500 text-sm">Ningún archivo seleccionado</span>
							
							<div class="flex items-center bg-gray-100 rounded-full px-3 py-1 ml-2">
								<svg class="w-5 h-5 text-gray-400" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
									<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
								</svg>
								<input type="text" id="search-input" list="search-suggestions" placeholder="Buscar elemento..." class="bg-transparent text-gray-700 placeholder-gray-400 focus:outline-none ml-2 text-sm w-48">
								<datalist id="search-suggestions"></datalist>
							</div>

							<div class="relative inline-block text-left ml-2">
								<div>
									<button type="button" id="saved-sketches-menu-button" class="p-2 bg-gray-100 hover:bg-gray-200 text-gray-700 rounded-full transition-colors" aria-expanded="false" aria-haspopup="true" title="Croquis Guardados">
										<svg class="w-5 h-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
											<path stroke-linecap="round" stroke-linejoin="round" d="M2.25 12.75V12A2.25 2.25 0 014.5 9.75h15A2.25 2.25 0 0121.75 12v.75m-8.69-6.44l-2.12-2.12a1.5 1.5 0 00-1.061-.44H4.5A2.25 2.25 0 002.25 6v12a2.25 2.25 0 002.25 2.25h15A2.25 2.25 0 0021.75 18V9a2.25 2.25 0 00-2.25-2.25h-5.379a1.5 1.5 0 01-1.06-.44z" />
										</svg>
									</button>
								</div>
								<div id="saved-sketches-menu" class="origin-top-left absolute left-0 mt-2 w-64 rounded-md shadow-lg bg-white ring-1 ring-black ring-opacity-5 focus:outline-none hidden z-10" role="menu">
									<div class="p-2">
										<h4 class="text-sm font-semibold text-gray-700 mb-2 px-2">Croquis Guardados</h4>
										<ul id="saved-sketches-list" class="text-gray-700 text-sm max-h-60 overflow-y-auto"></ul>
									</div>
								</div>
							</div>
							<button id="save-sketch-btn" title="Guardar Croquis en Navegador" class="p-2 bg-gray-100 hover:bg-gray-200 text-gray-700 rounded-full transition-colors">
								<svg class="w-5 h-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
								  <path stroke-linecap="round" stroke-linejoin="round" d="M9 13.5l3 3m0 0l3-3m-3 3v-6m1.06-4.19l-2.12-2.12a1.5 1.5 0 00-1.061-.44H4.5A2.25 2.25 0 002.25 6v12a2.25 2.25 0 002.25 2.25h15A2.25 2.25 0 0021.75 18V9a2.25 2.25 0 00-2.25-2.25h-5.379a1.5 1.5 0 01-1.06-.44z" />
								</svg>
							</button>
							<button id="copy-image-btn" title="Copiar Imagen" class="p-2 bg-gray-100 hover:bg-gray-200 text-gray-700 rounded-full transition-colors">
								<svg class="w-5 h-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
									<path stroke-linecap="round" stroke-linejoin="round" d="M6.827 6.175A2.31 2.31 0 015.186 7.23c-.38.054-.757.112-1.134.175C2.999 7.58 2.25 8.507 2.25 9.574V18a2.25 2.25 0 002.25 2.25h15A2.25 2.25 0 0021.75 18V9.574c0-1.067-.75-1.994-1.802-2.169a47.865 47.865 0 00-1.134-.175 2.31 2.31 0 01-1.64-1.055l-.822-1.316a2.192 2.192 0 00-1.736-1.039 48.776 48.776 0 00-5.232 0 2.192 2.192 0 00-1.736 1.039l-.821 1.316z" />
									<path stroke-linecap="round" stroke-linejoin="round" d="M16.5 12.75a4.5 4.5 0 11-9 0 4.5 4.5 0 019 0zM18.75 10.5h.008v.008h-.008V10.5z" />
								</svg>
							</button>
							<button id="filter-selection-btn" title="Filtrar Selección" class="px-3 py-1 text-sm rounded bg-green-100 text-green-700 hover:bg-green-200 transition-colors font-semibold flex items-center gap-1 disabled:bg-gray-100 disabled:text-gray-400 disabled:cursor-not-allowed" disabled>
								<svg class="w-4 h-4" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M12 3c2.755 0 5.455.232 8.083.678.533.09.917.556.917 1.096v1.044a2.25 2.25 0 01-.659 1.591l-5.432 5.432a2.25 2.25 0 00-.659 1.591v2.927a2.25 2.25 0 01-1.244 2.013L9.75 21v-6.572a2.25 2.25 0 00-.659-1.591L3.659 7.409A2.25 2.25 0 013 5.818V4.774c0-.54.384-1.006.917-1.096A48.32 48.32 0 0112 3z" /></svg>
								<span>Filtrar</span>
							</button>
							<button id="reset-view-btn" title="Restablecer Vista" class="hidden px-3 py-1 text-sm rounded bg-gray-200 text-gray-800 hover:bg-gray-300 transition-colors font-semibold flex items-center gap-1">
								<svg class="w-4 h-4" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
									<path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/>
									<path d="M3 3v5h5"/>
								</svg>
								<span>Restablecer</span>
							</button>
							<button id="revert-to-csv-btn" title="Volver al CSV Original" class="hidden px-3 py-1 text-sm rounded bg-orange-100 text-orange-700 hover:bg-orange-200 transition-colors font-semibold flex items-center gap-1">
								<svg class="w-4 h-4" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor">
									<path stroke-linecap="round" stroke-linejoin="round" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
								</svg>
								<span>CSV Original</span>
							</button>
						</div>
						 <!-- Right Group -->
						<div class="flex items-center flex-wrap justify-end gap-2">
							<label for="upload-sketch-file" title="Subir Croquis (.json)" class="cursor-pointer px-3 py-1 text-sm rounded bg-blue-100 text-blue-600 hover:bg-blue-200 transition-colors font-semibold flex items-center gap-1">
								<svg class="w-4 h-4" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 M -5 21 q -4 0 -4 -4 v -12 q 0 -4 4 -4 h 18 q 4 0 4 4 v 5 h -2 v -5 q 0 -3 -3 -3 h -16 q -3 0 -3 3 v 10 q 0 3 3 3 h 8 v 2 Z m 15 2 l -6 -6 l 1.5 -1.5 l 4.5 4.5 l 4.5 -4.5 l 1.5 1.5 Z" stroke-width="0"><path stroke-linecap="round" stroke-linejoin="round" d="M12 19.5v-15m0 0l-6.75 6.75M12 4.5l6.75 6.75" /></svg>
								<span>JSON</span>
							</label>
							<input id="upload-sketch-file" type="file" class="hidden" accept=".json">
							<button id="download-sketch-btn" title="Descargar Croquis (.json)" class="px-3 py-1 text-sm rounded bg-blue-100 text-blue-600 hover:bg-blue-200 transition-colors font-semibold flex items-center gap-1">
								<svg class="w-4 h-4" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor">
								  <path stroke-linecap="round" stroke-linejoin="round" d="M12 4.5v15m0 0l6.75-6.75M12 19.5l-6.75-6.75" />
								</svg>
								<span>JSON</span>
							</button>
						</div>
					</div>
				</header>

				<main id="visualization-container" class="bg-white shadow-sm rounded-xl p-2 sm:p-4 overflow-auto flex-grow border border-gray-300" style="min-height: 70vh;">
					<div id="initial-message" class="hidden flex-col items-center justify-center h-full text-center text-gray-500" style="min-height: 65vh;">
						<svg class="w-16 h-16 mb-4 text-gray-300" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 17v-2m3 2v-4m3 4v-6m2 10H7a2 2 0 01-2-2V7c0-1.1.9-2 2-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"></path></svg>
						<h2 class="text-xl font-semibold">Esperando archivo de datos</h2>
						<p class="mt-2 max-w-md">Por favor, selecciona un archivo CSV para comenzar la visualización. El gráfico aparecerá aquí.</p>
					</div>
					<div id="loading-indicator" class="hidden flex-col items-center justify-center h-full" style="min-height: 65vh;">
						<div class="loader"></div>
						<p class="mt-4 text-gray-600">Procesando datos y generando gráfico...</p>
					</div>
					<svg id="graph-svg"></svg>
				</main>
			</div>
		</div>
		
		<div id="info-panel" class="relative w-80 bg-white shadow-lg p-6 transform translate-x-full transition-transform duration-300 ease-in-out">
			<button id="close-info-panel-btn" class="absolute top-4 right-4 text-gray-500 hover:text-gray-800 z-10">
				<svg class="w-6 h-6" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12" /></svg>
			</button>
			<div id="info-content">
				<p class="text-gray-500">Seleccione un elemento para ver sus detalles.</p>
			</div>
		</div>
	</div>


	<script>
		// --- Global State ---
		let originalGraphData = null;
		let initialCsvData = null;
		let initialCsvName = '';
		let currentGraphData = { nodes: [], edges: [], annotations: [], customElements: [], rootId: null };
		let savedSketches = [];
		try {
			const sketchesJSON = localStorage.getItem('esquemapp-saved-sketches');
			if (sketchesJSON) {
				const parsedSketches = JSON.parse(sketchesJSON);
				if (Array.isArray(parsedSketches)) {
					savedSketches = parsedSketches;
				}
			}
		} catch (e) {
			console.error("Error al cargar croquis guardados:", e);
			savedSketches = []; // Reset on error
		}
		let selectedNode = null;
		let selectedAnnotation = null;
		let selectedCustomElement = null;
		let selectedConnection = null, selectedEdge = null;
		let history = [];
		let historyIndex = -1;
		let parentMap = null;
		let directedAdj = null;
		let rootNode = null;

		// Drawing and Selection State
		let currentTool = 'select';
		let currentToolOptions = {};
		let drawing = false;
		let startCoords = {};
		let currentAnnotation = null;
		let multiSelectedNodes = new Set();
		
		const colorThemes = {
			green: { main: '#10b981', closed: '#4ade80', stroke: '#1f2937' },
			blue: { main: '#2563eb', closed: '#93c5fd', stroke: '#1e40af' },
			red: { main: '#ef4444', closed: '#fca5a5', stroke: '#7f1d1d' },
			gray: { main: '#6b7280', closed: '#d1d5db', stroke: '#1f2937' }
		};

		const selectionColors = [
			{ name: 'green', hex: '#10b981' },
			{ name: 'blue', hex: '#2563eb' },
			{ name: 'red', hex: '#ef4444' },
			{ name: 'gray', hex: '#6b7280' }
		];
		
		const textColors = [
			{ name: 'black', hex: '#1f2937' },
			{ name: 'burgundy', hex: '#800000' },
			{ name: 'blue', hex: '#2563eb' },
			{ name: 'green', hex: '#10b981' },
			{ name: 'gray', hex: '#6b7280' }
		];

		// --- Helper and Drag Functions ---
		const isBNode = (node) => node && node.data && node.data.baseName && node.data.baseName.match(/^B\d+/);
		
		const isSeccionadorType = (nodeData) => {
			if (!nodeData || !nodeData.description) return false;
			const seccionadorDescriptions = [
				'UNI MT Seccionador',
				'UNI MT Secc. Bajo Carga',
				'UNI MT Secc. Autodesconectador',
				'UNI MT Seccionalizador',
				'Seccionalizador Unipolar',
				'UNI MT Reconectador'
			];
			return seccionadorDescriptions.includes(nodeData.description);
		};

		const textDrag = d3.drag()
			.on("start", function(event, d) {
				if (currentTool !== 'select') return;
				d3.select(this).raise();
				if (d.customTextX === undefined) {
					d.customTextX = +d3.select(this).attr('x');
				}
				if (d.customTextY === undefined) {
					d.customTextY = +d3.select(this).attr('y');
				}
			})
			.on("drag", function(event, d) {
				if (currentTool !== 'select') return;
				const transform = d3.zoomTransform(d3.select("#graph-svg").node());
				const k = transform.k;
				
				d.customTextX += event.dx / k;
				d.customTextY += event.dy / k;

				d3.select(this)
					.attr('x', d.customTextX)
					.attr('y', d.customTextY)
					.attr('text-anchor', 'start');
			})
			.on("end", function(event, d) {
				if (currentTool !== 'select') return;
				const element = currentGraphData.nodes.find(n => n.id === d.id) || currentGraphData.customElements.find(el => el.id === d.id);
				if (element) {
					element.customTextX = d.customTextX;
					element.customTextY = d.customTextY;
					element.textAnchor = 'start';
				}
				saveState();
			});
			
		const connectionTextDrag = d3.drag()
			.on("start", function(event, d) {
				if (currentTool !== 'select') return;
				d3.select(this).raise();
				const connection = d.element.connections[d.connIndex];
				if (connection.customTextX === undefined) {
					connection.customTextX = +d3.select(this).attr('x');
				}
				if (connection.customTextY === undefined) {
					connection.customTextY = +d3.select(this).attr('y');
				}
			})
			.on("drag", function(event, d) {
				if (currentTool !== 'select') return;
				const transform = d3.zoomTransform(d3.select("#graph-svg").node());
				const k = transform.k;
				const connection = d.element.connections[d.connIndex];
				
				connection.customTextX += event.dx / k;
				connection.customTextY += event.dy / k;

				d3.select(this)
					.attr('x', connection.customTextX)
					.attr('y', connection.customTextY);
			})
			.on("end", function(event, d) {
				if (currentTool !== 'select') return;
				saveState();
			});

		function showMessageBox(message, type = 'info', onConfirm = null) {
			const container = document.getElementById('message-box-container');
			container.innerHTML = `
				<div class="message-box">
					<p>${message}</p>
					<button id="message-box-ok" class="btn-confirm">OK</button>
					${onConfirm ? '<button id="message-box-cancel" class="btn-cancel">Cancelar</button>' : ''}
				</div>
			`;
			const okButton = document.getElementById('message-box-ok');
			okButton.focus();
			okButton.onclick = () => {
				container.innerHTML = '';
				if (onConfirm) onConfirm(true);
			};
			if (onConfirm) {
				document.getElementById('message-box-cancel').onclick = () => {
					container.innerHTML = '';
					onConfirm(false);
				};
			}
		}
		function showChoiceBox(message, choices, onChoose) {
			const container = document.getElementById('message-box-container');
			
			const choiceButtonsHTML = choices.map((choice, index) => 
				`<button id="choice-btn-${index}" class="${choice.class}">${choice.text}</button>`
			).join('');

			container.innerHTML = `
				<div class="message-box">
					<p class="mb-4">${message}</p>
					<div>
						${choiceButtonsHTML}
						<button id="choice-btn-cancel" class="btn-cancel">Cancelar</button>
					</div>
				</div>
			`;

			choices.forEach((choice, index) => {
				document.getElementById(`choice-btn-${index}`).onclick = () => {
					container.innerHTML = '';
					onChoose(choice.text);
				};
			});

			document.getElementById('choice-btn-cancel').onclick = () => {
				container.innerHTML = '';
				onChoose(null); // Indicate cancellation
			};
		}

		function showTextInputBox(message, defaultValue = '', onConfirm) {
			const container = document.getElementById('message-box-container');
			
			const keydownHandler = (e) => {
				if (e.key === 'Enter') {
					e.preventDefault();
					confirmAction();
				} else if (e.key === 'Escape') {
					cancelAction();
				}
			};

			const confirmAction = () => {
				const inputField = document.getElementById('text-input-field');
				const value = inputField ? inputField.value : null;
				container.innerHTML = '';
				document.removeEventListener('keydown', keydownHandler);
				onConfirm(value);
			};

			const cancelAction = () => {
				container.innerHTML = '';
				document.removeEventListener('keydown', keydownHandler);
				onConfirm(null);
			};
			
			container.innerHTML = `
				<div class="message-box">
					<p class="mb-4">${message}</p>
					<input type="text" id="text-input-field" class="w-full p-2 border border-gray-300 rounded-md mb-4" value="${defaultValue}">
					<div>
						<button id="message-box-ok" class="btn-confirm">OK</button>
						<button id="message-box-cancel" class="btn-cancel">Cancelar</button>
					</div>
				</div>
			`;
			
			const inputField = document.getElementById('text-input-field');
			const okButton = document.getElementById('message-box-ok');
			const cancelButton = document.getElementById('message-box-cancel');

			inputField.focus();
			inputField.select();

			okButton.onclick = confirmAction;
			cancelButton.onclick = cancelAction;
			document.addEventListener('keydown', keydownHandler);
		}

		function showError(message) {
			document.getElementById('loading-indicator').classList.add('hidden');
			document.getElementById('loading-indicator').classList.remove('flex');
			document.getElementById('graph-svg').classList.add('hidden');

			const initialMessage = document.getElementById('initial-message');
			initialMessage.classList.remove('hidden');
			initialMessage.innerHTML = `
				<svg class="w-16 h-16 mb-4 text-red-400" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
				<h2 class="text-xl font-semibold text-red-600">Error</h2>
				<p class="mt-2 max-w-md">${message}</p>
			`;
			updateDeleteButtonState();
		}

		function handleFileSelect(event) {
			if (event.target.disabled) return;
			const file = event.target.files[0];
			if (!file) return;

			parentMap = null;
			directedAdj = null;

			document.getElementById('file-name').textContent = file.name;
			document.getElementById('loading-indicator').classList.remove('hidden');
			document.getElementById('loading-indicator').classList.add('flex');
			
			d3.select("#graph-svg").selectAll("*").remove();
			clearSelections();
			updateDeleteButtonState();
			updateClearDrawingsButtonState();
			document.getElementById('search-input').value = '';
			document.getElementById('search-suggestions').innerHTML = '';


			const reader = new FileReader();
			reader.onload = e => {
				setTimeout(() => {
					try {
						const processed = processData(e.target.result);
						initialCsvData = JSON.parse(JSON.stringify(processed));
						initialCsvName = file.name;
						originalGraphData = JSON.parse(JSON.stringify(processed));
						currentGraphData = processed;

						console.log("Processed data:", currentGraphData);
						if (currentGraphData.nodes.length > 0 && currentGraphData.rootId) {
							document.getElementById('initial-message').classList.add('hidden');
							document.getElementById('graph-svg').classList.remove('hidden');
							history = [];
							historyIndex = -1;
							saveState();
							drawGraph(currentGraphData);
						} else {
						 showError("No se encontró un elemento raíz dibujable o no hay elementos válidos en el archivo. Por favor, revise el formato del archivo.");
						}
						document.getElementById('revert-to-csv-btn').classList.add('hidden');
					} catch (error) {
						console.error("Error processing file:", error);
						showError(`Ocurrió un error al procesar el archivo: ${error.message}`);
					} finally {
						document.getElementById('loading-indicator').classList.add('hidden');
						document.getElementById('loading-indicator').classList.remove('flex');
					}
				}, 50);
			};
			reader.onerror = () => {
				showError("No se pudo leer el archivo.");
			};
			reader.readAsText(file, 'ISO-8859-1');
			event.target.value = '';
		}

		function processData(csvText) {
			const lines = csvText.split(/\r?\n/);
			if (lines.length === 0) {
				throw new Error("El archivo está vacío.");
			}

			const firstLine = lines[0];
			let delimiter = '\t';
			if (firstLine.split(';').length > firstLine.split('\t').length) {
				delimiter = ';';
			}

			const headers = firstLine.split(delimiter).map(h => h.trim());
			
			const idIndex = headers.indexOf('ID');
			const nombreIndex = headers.indexOf('NOMBRE');
			const conexionesIndex = headers.indexOf('CONEXIONES');
			const xyIndex = headers.indexOf('X,Y');
			const longIndex = headers.indexOf('LONG.');
			const anguloIndex = headers.indexOf('ANGULO');
			let descripcionClaseIndex = -1;
			for(let i = 0; i < headers.length; i++) {
				if(headers[i] === 'DESCRIPCION' && i < nombreIndex) {
					descripcionClaseIndex = i;
				}
			}
			
			if (idIndex === -1 || nombreIndex === -1 || conexionesIndex === -1 || descripcionClaseIndex === -1 || xyIndex === -1 || longIndex === -1 || anguloIndex === -1) {
				throw new Error("El archivo CSV no contiene las columnas requeridas: 'ID', 'NOMBRE', 'DESCRIPCION', 'CONEXIONES', 'X,Y', 'LONG.' y 'ANGULO'.");
			}

			const dataMap = new Map();
			for (let i = 1; i < lines.length; i++) {
				if (lines[i].trim() === '') continue;
				const data = lines[i].split(delimiter);
				const id = data[idIndex];
				if (id) {
					const nodeData = {
						id: id,
						nombre: data[nombreIndex],
						descripcion: data[descripcionClaseIndex],
						conexionesRaw: data[conexionesIndex],
						coordsRaw: data[xyIndex],
						longitud: parseFloat(data[longIndex]?.replace(',', '.')) || 0,
						angulo: parseFloat(data[anguloIndex]?.replace(',', '.')) || 0
					};
					dataMap.set(id, nodeData);
				}
			}

			const nodes = [];
			dataMap.forEach(nodeData => {
				if (nodeData.coordsRaw) {
					const parts = nodeData.coordsRaw.split(',');
					if (parts.length === 2) {
						// --- MODIFICATION START: Filter by specific descriptions ---
						const isCTNodeToHide = nodeData.nombre.startsWith('CT-') && nodeData.descripcion === 'UNI MT Nodo de ConexiÃ³n';
						
						const isDrawable = nodeData.nombre &&	
											 !nodeData.nombre.startsWith('DE-') &&
											 !nodeData.nombre.startsWith('BC-') &&
											 !nodeData.nombre.startsWith('SD_') &&	
											 !/TR\d+$/.test(nodeData.nombre) &&
											 nodeData.descripcion !== 'UNI MT Interruptor' &&
											 nodeData.descripcion !== 'MD Cliente MT' &&
											 nodeData.descripcion !== 'MD Secc Bajo Carga C/Fusible' &&
											 nodeData.descripcion !== 'MD Secc. Autodesconectador' &&
											 nodeData.descripcion !== 'MD Interruptor con ProtecciÃ³n' &&
											 !isCTNodeToHide;
						// --- MODIFICATION END ---

						const node = {	
							id: nodeData.id,	
							name: nodeData.nombre,	
							baseName: nodeData.nombre,	
							description: nodeData.descripcion,
							state: 'closed',
							x: parseFloat(parts[0]),
							y: parseFloat(parts[1]),
							isDrawable: isDrawable
						};
						if (node.baseName.match(/^B\d+/)) {
							node.connections = [];
							node.symbolType = 'ct-default';
						}
						nodes.push(node);
					}
				}
			});

			const edges = [];
			const processedEdges = new Set();
			const nodeIdsWithCoords = new Set(nodes.map(n => n.id));

			dataMap.forEach(sourceNodeData => {
				if (!sourceNodeData.conexionesRaw || !nodeIdsWithCoords.has(sourceNodeData.id)) return;

				const potentialTargetIds = sourceNodeData.conexionesRaw.match(/\d{8,}/g);

				if (potentialTargetIds) {
					potentialTargetIds.forEach(targetId => {
						if (nodeIdsWithCoords.has(targetId)) {
							const edgeKey = [sourceNodeData.id, targetId].sort().join('-');
							if (!processedEdges.has(edgeKey)) {
								const isDashed = sourceNodeData.descripcion === 'UNI MT Tramo Subterraneo';
								edges.push({	
									source: sourceNodeData.id,	
									target: targetId,	
									state: 'closed',
									isDashed: isDashed,
									length: sourceNodeData.longitud,
									angle: sourceNodeData.angulo
								});	
								processedEdges.add(edgeKey);	
							}
						}
					});
				}
			});
			
			const rootId = nodes.find(n => n.isDrawable)?.id || null;
			
			parentMap = null; 

			return { nodes, edges, annotations: [], customElements: [], rootId: rootId };
		}
		
		// --- Drawing and Annotation ---

		function setCurrentTool(tool, buttonElement = null, options = {}) {
			if (currentTool === tool && JSON.stringify(currentToolOptions) === JSON.stringify(options) && tool !== 'select') {
				setCurrentTool('select');
				return;
			}

			currentTool = tool;
			currentToolOptions = options;
			const svg = d3.select("#graph-svg");
			const g = svg.select("g.graph-content");
			const toolsSidebar = document.getElementById('tools-sidebar');
			
			toolsSidebar.querySelectorAll('.tool-btn').forEach(btn => btn.classList.remove('active'));
			
			if (tool !== 'select' && buttonElement) {
				 buttonElement.classList.add('active');
			}
			
			svg.classed('drawing-mode', false).classed('lasso-select-mode', false).classed('marquee-select-mode', false);
			svg.on('.drag', null).on('click', null);

			if (tool === 'select') {
				svg.style('cursor', 'default');
				g.style('pointer-events', 'all');
				initializeZoom();
			} else if (tool === 'lasso-select') {
				clearSelections();
				svg.classed('lasso-select-mode', true);
				g.style('pointer-events', 'all');
				svg.on('.zoom', null);
				initializeLassoSelect();
			} else if (tool === 'marquee-select') {
				clearSelections();
				svg.classed('marquee-select-mode', true);
				g.style('pointer-events', 'all');
				svg.on('.zoom', null);
				initializeMarqueeSelect();
			} else {
				clearSelections();
				updateDeleteButtonState();
				svg.classed('drawing-mode', true);
				svg.style('cursor', 'crosshair');
				g.style('pointer-events', 'none');
				svg.on('.zoom', null);
				initializeDrawing();
			}
		}
		
		function initializeDrawing() {
			const svg = d3.select("#graph-svg");
			const g = svg.select("g.graph-content");
			const drawingArea = svg.select("#drawing-area").node();

			svg.on('.drag', null).on('click', null);

			const clickHandler = (event) => {
				if (event.target !== svg.node() && event.target !== drawingArea) return;

				const [x, y] = d3.pointer(event, g.node());

				if (currentTool === 'text') {
					showTextInputBox("Ingrese el texto para la anotación:", "", (text) => {
						if (text && text.trim() !== "") {
							const annotationData = { id: `anno-${Date.now()}`, type: 'text', x, y, text, color: '#1f2937' };
							currentGraphData.annotations.push(annotationData);
							saveState();
							drawAnnotations();
							updateClearDrawingsButtonState();
						}
					});
				} else if (currentTool === 'ground') {
					const annotationData = {
						id: `anno-${Date.now()}`,
						type: 'ground',
						x: x,
						y: y,
						scale: 1.5,
						rotation: 0,
						color: '#1f2937'
					};
					currentGraphData.annotations.push(annotationData);
					saveState();
					drawAnnotations();
					updateClearDrawingsButtonState();
				} else if (currentTool === 'custom-element') {
					const symbolType = currentToolOptions.symbolType;
					const defaultName = symbolType === 'ct-default' ? "CT-Nuevo" : "Seccionador-Nuevo";
					
					const createNewElement = (name, numConnections) => {
						const newElement = {
							id: `custom-${Date.now()}`,
							name: name,
							x: x,
							y: y,
							symbolType: symbolType,
							numConnections: numConnections,
							distributionMode: 'auto',
							connections: Array.from({ length: numConnections }, (_, i) => ({
								id: i,
								name: `Salida ${i + 1}`,
								state: 'closed',
								symbolType: 'seccionador'
							})),
							state: 'closed',
							color: 'green'
						};
						currentGraphData.customElements.push(newElement);
						updateCustomElementConnections(newElement);
						saveState();
						drawCustomElements();
					};

					showTextInputBox(`Ingrese el nombre del nuevo elemento:`, defaultName, (name) => {
						if (name && name.trim() !== "") {
							if (symbolType === 'seccionador') {
								createNewElement(name.trim(), 0);
							} else {
								showTextInputBox("Ingrese el número de salidas (1 por defecto):", "1", (numStr) => {
									const numConnections = parseInt(numStr, 10);
									if (numStr !== null && !isNaN(numConnections) && numConnections >= 0 && numConnections <= 8) {
										createNewElement(name.trim(), numConnections);
									} else if (numStr !== null) {
										showMessageBox("Por favor, ingrese un número válido entre 0 y 8.");
									}
								});
							}
						}
					});
				}
			};
			
			if (['text', 'ground', 'custom-element'].includes(currentTool)) {
				svg.on('click', clickHandler);
			} else {
				const drawingDrag = d3.drag()
					.on("start", (event) => {
						if (event.sourceEvent.target !== svg.node() && event.sourceEvent.target !== drawingArea) {
							drawing = false;
							return;
						}
						drawing = true;
						const [x, y] = d3.pointer(event, g.node());
						startCoords = { x, y };
						let newElement;
						const defaultColor = currentTool.includes('line') ? '#10b981' : '#6b7280';

						switch(currentTool) {
							case 'ellipse': newElement = g.append('ellipse').attr('class', 'annotation'); break;
							case 'rect': newElement = g.append('rect').attr('class', 'annotation'); break;
							case 'line':
							case 'dashed-line':
								 newElement = g.append('line').attr('class', 'annotation');
								 if (currentTool === 'dashed-line') newElement.attr('stroke-dasharray', '5,5');
								 break;
						}
						
						if (newElement) {
							newElement.attr('fill', 'none').style('stroke', defaultColor);
						}

						currentAnnotation = { id: `anno-${Date.now()}`, type: currentTool, element: newElement, data: {} };
					})
					.on("drag", (event) => {
						if (!drawing) return;
						const [pointerX, pointerY] = d3.pointer(event, g.node());
						const { element, data } = currentAnnotation;
						
						switch(currentTool) {
							case 'ellipse':
								const rx = Math.abs(pointerX - startCoords.x) / 2;
								const ry = Math.abs(pointerY - startCoords.y) / 2;
								const cx = startCoords.x + (pointerX - startCoords.x) / 2;
								const cy = startCoords.y + (pointerY - startCoords.y) / 2;
								element.attr('cx', cx).attr('cy', cy).attr('rx', rx).attr('ry', ry);
								data.cx = cx; data.cy = cy; data.rx = rx; data.ry = ry;
								break;
							case 'rect':
								element.attr('x', Math.min(startCoords.x, pointerX)).attr('y', Math.min(startCoords.y, pointerY))
										.attr('width', Math.abs(pointerX - startCoords.x)).attr('height', Math.abs(pointerY - startCoords.y));
								data.x = +element.attr('x'); data.y = +element.attr('y'); data.width = +element.attr('width'); data.height = +element.attr('height');
								break;
							case 'line':
							case 'dashed-line':
								const dx = pointerX - startCoords.x;
								const dy = pointerY - startCoords.y;
								const angle = Math.atan2(dy, dx);
								const fortyFive = Math.PI / 4;
								const snapAngle = Math.round(angle / fortyFive) * fortyFive;
								const dist = Math.sqrt(dx * dx + dy * dy);
								const endX = startCoords.x + dist * Math.cos(snapAngle);
								const endY = startCoords.y + dist * Math.sin(snapAngle);
								element.attr('x1', startCoords.x).attr('y1', startCoords.y).attr('x2', endX).attr('y2', endY);
								data.x1 = startCoords.x; data.y1 = startCoords.y; data.x2 = endX; data.y2 = endY;
								break;
						}
					})
					.on("end", () => {
						if (!drawing) return;
						drawing = false;
						const defaultColor = currentTool.includes('line') ? '#10b981' : '#6b7280';
						const annotationData = { id: currentAnnotation.id, type: currentAnnotation.type, color: defaultColor, ...currentAnnotation.data };
						currentGraphData.annotations.push(annotationData);
						saveState();
						currentAnnotation.element.remove();
						currentAnnotation = null;
						drawAnnotations();
						updateClearDrawingsButtonState();
					});
				svg.call(drawingDrag);
			}
		}
		
		function drawAnnotations() {
			const g = d3.select("g.graph-content");
			g.selectAll('.annotation-group').remove();

			const annotationGroups = g.selectAll('.annotation-group')
				.data(currentGraphData.annotations, d => d.id)
				.join('g')
				.attr('class', 'annotation-group')
				.classed('selected', d => selectedAnnotation && selectedAnnotation.id === d.id)
				.each(function(d) {
					const group = d3.select(this);
					let element;
					const color = d.color || '#6b7280';

					if (d.type === 'ground') {
						group.attr('transform', `translate(${d.x}, ${d.y}) rotate(${d.rotation || 0})`);
					}

					switch(d.type) {
						case 'ellipse':
							element = group.append('ellipse').attr('cx', d.cx).attr('cy', d.cy).attr('rx', d.rx).attr('ry', d.ry);
							break;
						case 'rect':
							element = group.append('rect').attr('x', d.x).attr('y', d.y).attr('width', d.width).attr('height', d.height);
							break;
						case 'line':
						case 'dashed-line':
							group.append('line').attr('x1', d.x1).attr('y1', d.y1).attr('x2', d.x2).attr('y2', d.y2).attr('stroke', 'transparent').attr('stroke-width', 10);
							element = group.append('line').attr('x1', d.x1).attr('y1', d.y1).attr('x2', d.x2).attr('y2', d.y2);
							if (d.type === 'dashed-line') element.attr('stroke-dasharray', '5,5');
							break;
						case 'text':
							element = group.append('text').attr('class', 'text-annotation').attr('x', d.x).attr('y', d.y).text(d.text).style('fill', color);
							break;
						case 'ground':
							const scale = d.scale || 1;
							group.append('line').attr('class', 'annotation').attr('x1', 0).attr('y1', -12 * scale).attr('x2', 0).attr('y2', 6 * scale).style('stroke', color);
							group.append('line').attr('class', 'annotation').attr('x1', -9 * scale).attr('y1', 6 * scale).attr('x2', 9 * scale).attr('y2', 6 * scale).style('stroke', color);
							group.append('line').attr('class', 'annotation').attr('x1', -6 * scale).attr('y1', 12 * scale).attr('x2', 6 * scale).attr('y2', 12 * scale).style('stroke', color);
							group.append('line').attr('class', 'annotation').attr('x1', -3 * scale).attr('y1', 18 * scale).attr('x2', 3 * scale).attr('y2', 18 * scale).style('stroke', color);
							break;
					}

					if (element) {
						element.attr('class', `annotation ${d.type}-annotation`);
						if (d.type !== 'text') {
							element.attr('fill', 'none').style('stroke', color);
						}
					}
					
					addResizeHandles(group, d);
				});

			annotationGroups.on("click", function(event, d) {
				event.stopPropagation();
				if (currentTool !== 'select') return;
				clearSelections();
				selectedAnnotation = d;
				d3.select(this).classed('selected', true);
				updateDeleteButtonState();
				updateInfoPanel();
			});
			
			annotationGroups.on("dblclick", function(event, d) {
				if (currentTool !== 'select') return;
				event.preventDefault();
				event.stopPropagation();

				if (d.type === 'ground') {
					d.rotation = (d.rotation || 0) + 45;
					saveState();
					drawAnnotations();
				} else if (d.type === 'text') {
					showTextInputBox("Editar texto:", d.text, (newText) => {
						if (newText !== null && newText !== d.text) {
							d.text = newText;
							saveState();
							drawAnnotations();
						}
					});
				}
			});

			annotationGroups.call(d3.drag()
				.on("start", function(event, d) {
					if (currentTool !== 'select' || d3.select(event.sourceEvent.target).classed('resize-handle')) return;
					d3.select(this).raise();
					if (!selectedAnnotation || selectedAnnotation.id !== d.id) {
						clearSelections();
						selectedAnnotation = d;
						d3.select(this).classed('selected', true);
						updateDeleteButtonState();
						updateInfoPanel();
					}
				})
				.on("drag", function(event, d) {
					if (currentTool !== 'select' || d3.select(event.sourceEvent.target).classed('resize-handle')) return;
					
					const transform = d3.zoomTransform(d3.select("#graph-svg").node());
					const dx = event.dx / transform.k;
					const dy = event.dy / transform.k;

					if (d.type === 'ground' || d.type === 'rect' || d.type === 'text' || d.type === 'ellipse') {
						d.x ? d.x += dx : d.cx += dx;
						d.y ? d.y += dy : d.cy += dy;
					} else if (d.type === 'line' || d.type === 'dashed-line') {
						d.x1 += dx; d.y1 += dy;
						d.x2 += dx; d.y2 += dy;
					}
					drawAnnotations();
				})
				.on("end", function(event, d) {
					if (currentTool !== 'select' || d3.select(event.sourceEvent.target).classed('resize-handle')) return;
					saveState();
				})
			);
		}

		function addResizeHandles(group, d) {
			const handleRadius = 4;
			let handles = [];

			if (d.type === 'rect') {
				handles = [
					{ x: d.x, y: d.y, cursor: 'nwse-resize', type: 'top-left' },
					{ x: d.x + d.width, y: d.y, cursor: 'nesw-resize', type: 'top-right' },
					{ x: d.x, y: d.y + d.height, cursor: 'nesw-resize', type: 'bottom-left' },
					{ x: d.x + d.width, y: d.y + d.height, cursor: 'nwse-resize', type: 'bottom-right' }
				];
			} else if (d.type === 'ellipse') {
				 handles = [
					{ x: d.cx, y: d.cy - d.ry, cursor: 'ns-resize', type: 'top' },
					{ x: d.cx + d.rx, y: d.cy, cursor: 'ew-resize', type: 'right' },
					{ x: d.cx, y: d.cy + d.ry, cursor: 'ns-resize', type: 'bottom' },
					{ x: d.cx - d.rx, y: d.cy, cursor: 'ew-resize', type: 'left' }
				];
			} else if (d.type === 'line' || d.type === 'dashed-line') {
				handles = [
					{ x: d.x1, y: d.y1, cursor: 'move', type: 'start' },
					{ x: d.x2, y: d.y2, cursor: 'move', type: 'end' }
				];
			} else if (d.type === 'ground') {
				const scale = d.scale || 1;
				handles = [{ x: 0, y: 18 * scale + 8, cursor: 'ns-resize', type: 'scale' }];
			}

			group.selectAll('.resize-handle')
				.data(handles)
				.join('circle')
				.attr('class', 'resize-handle')
				.attr('cx', h => h.x)
				.attr('cy', h => h.y)
				.attr('r', handleRadius)
				.style('cursor', h => h.cursor)
				.call(d3.drag()
					.on('start', function(event) { event.sourceEvent.stopPropagation(); })
					.on('drag', (event, h) => {
						const transform = d3.zoomTransform(d3.select("#graph-svg").node());
						const k = transform.k;
						const dx = event.dx / k;
						const dy = event.dy / k;

						if (d.type === 'rect') {
							if (h.type.includes('left')) { d.x += dx; d.width -= dx; }
							if (h.type.includes('right')) { d.width += dx; }
							if (h.type.includes('top')) { d.y += dy; d.height -= dy; }
							if (h.type.includes('bottom')) { d.height += dy; }
						} else if (d.type === 'ellipse') {
							if (h.type === 'top') { d.ry -= dy; }
							else if (h.type === 'bottom') { d.ry += dy; }
							else if (h.type === 'left') { d.rx -= dx; }
							else if (h.type === 'right') { d.rx += dx; }
							d.rx = Math.max(5, d.rx);
							d.ry = Math.max(5, d.ry);
						} else if (d.type === 'line' || d.type === 'dashed-line') {
							if (h.type === 'start') { d.x1 += dx; d.y1 += dy; }
							else { d.x2 += dx; d.y2 += dy; }
						} else if (d.type === 'ground') {
							d.scale = Math.max(0.2, (d.scale || 1) + dy / 20);
						}
						drawAnnotations();
					})
					.on('end', saveState)
				);
		}

		// --- Core D3 Graphing ---
		let zoom;

		function initializeZoom() {
			const svg = d3.select("#graph-svg");
			const g = svg.select("g.graph-content");
			zoom = d3.zoom()
				.scaleExtent([0.01, 8])
				.on("zoom", (event) => {
					g.attr("transform", event.transform);
				});
			svg.call(zoom)
			 .on("dblclick.zoom", null);	
		}

		function reorderGraphFromNode(node) {
			if (!node || !node.data || !node.data.id) {
				showMessageBox("No se pudo reordenar el gráfico. El nodo seleccionado no es válido.");
				return;
			}
			
			currentGraphData.rootId = node.data.id;
			directedAdj = null;	
			parentMap = null;
			clearSelections();
			updateDeleteButtonState();
			drawGraph(currentGraphData);
		}

		function getNodeRadius(node) {
			const circleRadius = 8;
			const baseSymbolRadius = 15;

			if (!node || !node.data.isDrawable) return 0;

			// For B-nodes (CTs), their symbol size is scaled.
			if (isBNode(node)) {
				return baseSymbolRadius * 1.3;
			}

			// For Seccionadores loaded from file, their symbol size is also scaled.
			const seccionadorDescriptions = [
				'UNI MT Seccionador', 
				'UNI MT Secc. Bajo Carga', 
				'UNI MT Secc. Autodesconectador'
			];
			if (seccionadorDescriptions.includes(node.data.description)) {
				return baseSymbolRadius * 0.8;
			}
			
			// Correctly scale the reconectador to match its drawn size
			if (node.data.description === 'UNI MT Reconectador') {
				return baseSymbolRadius * 1.5;
			}

			// Default case for other standard nodes
			return circleRadius;
		}

		function redrawAllLinks(nodeMap) {
			const linksGroup = d3.select("g.links");
			linksGroup.selectAll("*").remove();

			const edges = currentGraphData.edges.filter(e => !e.isMergeLink);

			const linkGenerator = d => {
				const sourceNode = nodeMap.get(d.source);
				const targetNode = nodeMap.get(d.target);
				if (!sourceNode || !targetNode) return '';
				const sourceX = sourceNode.customX ?? sourceNode.scaledX;
				const sourceY = sourceNode.customY ?? sourceNode.scaledY;
				const targetX = targetNode.customX ?? targetNode.scaledX;
				const targetY = targetNode.customY ?? targetNode.scaledY;
				return `M ${sourceX},${sourceY} V ${targetY} H ${targetX}`;
			};

			// Visual layer
			linksGroup.selectAll('.link-visual')
				.data(edges)
				.enter()
				.append('path')
				.attr('class', d => `link-visual cable-line ${selectedEdge && selectedEdge.source === d.source && selectedEdge.target === d.target ? 'selected' : ''}`)
				.attr('id', d => `link-visual-${d.source}-${d.target}`)
				.style('stroke', d => d.color || '#10b981')
				.style('stroke-dasharray', d => d.isDashed ? '5,5' : 'none')
				.attr('d', linkGenerator);

			// Interaction layer
			linksGroup.selectAll('.link-interaction')
				.data(edges)
				.enter()
				.append('path')
				.attr('class', 'link-interaction')
				.style('fill', 'none')
				.style('stroke', 'transparent')
				.style('stroke-width', '10px')
				.style('cursor', 'pointer')
				.attr('d', linkGenerator)
				.on('click', (event, d) => {
					event.stopPropagation();
					if (currentTool !== 'select') return;
					clearSelections();
					selectedEdge = d;
					d3.selectAll('.link-visual').classed('selected', e => e === d);
					updateDeleteButtonState();
					updateInfoPanel();
				});
		}


		function drawGraph({ nodes, edges, annotations, customElements, rootId }) {
			const svg = d3.select("#graph-svg");
			svg.selectAll("*").remove();
			const container = document.getElementById('visualization-container');

			const hasGraphElements = nodes && nodes.length > 0;
			const hasDrawingElements = (annotations && annotations.length > 0) || (customElements && customElements.length > 0);

			if (!hasGraphElements && !hasDrawingElements) {
				initializeBlankCanvas();
				return;
			}
			
			document.getElementById('initial-message').classList.add('hidden');
			document.getElementById('graph-svg').classList.remove('hidden');

			const contextMenu = d3.select("#context-menu");
			d3.select('body').on('click', () => contextMenu.classed('hidden', true));
			
			const defs = svg.append('defs');
			defs.append('pattern').attr('id', 'grid').attr('width', 20).attr('height', 20).attr('patternUnits', 'userSpaceOnUse').append('path').attr('d', 'M 20 0 L 0 0 0 20').attr('fill', 'none').attr('stroke', '#e5e7eb').attr('stroke-width', '0.5');
			
			const drawingArea = svg.append('rect').attr('id', 'drawing-area').attr('width', '100%').attr('height', '100%').attr('fill', 'url(#grid)');

			drawingArea.on('click', (event) => {
				if (currentTool === 'select') {
					clearSelections();
					updateDeleteButtonState();
				}
			});

			const g = svg.append("g").attr("class", "graph-content");

			if (hasGraphElements) {
				const nodeMap = new Map(nodes.map(d => [d.id, d]));
				
				if (!parentMap) {
					const initialAdj = new Map(nodes.map(d => [d.id, []]));
					edges.forEach(({ source, target }) => {
						initialAdj.get(source)?.push(target);
						initialAdj.get(target)?.push(source);
					});
					parentMap = new Map();
					const queue = [rootId];
					const visited = new Set([rootId]);
					parentMap.set(rootId, null);
					while (queue.length > 0) {
						const u = queue.shift();
						const neighbors = initialAdj.get(u) || [];
						for (const v of neighbors) {
							if (!visited.has(v)) {
								visited.add(v);
								parentMap.set(v, u);
								queue.push(v);
							}
						}
					}
				}
				
				rootNode = d3.stratify().id(d => d.id).parentId(d => parentMap.get(d.id))(nodes);

				// REVISED LOGIC: Naming logic for B-nodes based on the closest ancestor's name, with a fallback to children.
				rootNode.descendants().forEach(d => {
					if (isBNode(d)) {
						let nameSourceNode = null;
						let currentNode = d;
						// Search upwards through ancestors first
						while (currentNode.parent && !nameSourceNode) {
							if (currentNode.parent.data.baseName && currentNode.parent.data.baseName.match(/^(\d+)-/)) {
								nameSourceNode = currentNode.parent;
							}
							currentNode = currentNode.parent;
						}

						// If no suitable ancestor was found, check immediate children as a fallback
						if (!nameSourceNode) {
							 nameSourceNode = (d.children || []).find(child => child.data.baseName && child.data.baseName.match(/^(\d+)-/));
						}

						if (nameSourceNode) {
							const match = nameSourceNode.data.baseName.match(/^(\d+)-/);
							if (match && match[1]) {
								const newName = `CT-${match[1]}`;
								d.data.displayName = newName;
								const nodeInData = currentGraphData.nodes.find(n => n.id === d.data.id);
								if (nodeInData) nodeInData.displayName = newName;
							}
						}
					}
					// Set a default display name if one hasn't been assigned
					if (!d.data.displayName) d.data.displayName = d.data.baseName;
				});
				
				const nodesWithCoords = nodes.filter(n => n.x !== undefined && n.y !== undefined);
				if (nodesWithCoords.length === 0) {
					showError("El archivo no contiene datos de coordenadas válidos para graficar.");
					return;
				}
				
				const xExtent = d3.extent(nodesWithCoords, d => d.x);
				const yExtent = d3.extent(nodesWithCoords, d => d.y);

				const graphCoordWidth = xExtent[1] - xExtent[0];
				const graphCoordHeight = yExtent[1] - yExtent[0];
				
				const spacingMultiplier = 40;

				const targetDisplayWidth = graphCoordWidth * spacingMultiplier;
				const targetDisplayHeight = graphCoordHeight * spacingMultiplier;

				const xScale = d3.scaleLinear().domain(xExtent).range([0, targetDisplayWidth]);
				const yScale = d3.scaleLinear().domain(yExtent).range([targetDisplayHeight, 0]);

				nodes.forEach(node => {
					if (node.x !== undefined) {
						node.scaledX = xScale(node.x);
						node.scaledY = yScale(node.y);
					}
				});

				const svgPadding = 4000;
				const margin = { top: 80, right: 80, bottom: 80, left: 80 };

				svg.attr("width", targetDisplayWidth + margin.left + margin.right + svgPadding * 2)
				   .attr("height", targetDisplayHeight + margin.top + margin.bottom + svgPadding * 2);

				g.attr("transform", `translate(${margin.left + svgPadding}, ${margin.top + svgPadding})`);
				
				const symbolSize = 30, symbolRadius = symbolSize / 2, circleRadius = 8;
				const linksGroup = g.append("g").attr("class", "links");
				const nodesGroup = g.append("g").attr("class", "nodes");
				
				const isFilteredView = !document.getElementById('reset-view-btn').classList.contains('hidden');
				let centroid = null;
				if (isFilteredView && nodes.length > 0) {
					centroid = {
						x: d3.mean(nodes, n => n.customX ?? n.scaledX),
						y: d3.mean(nodes, n => n.customY ?? n.scaledY)
					};
				}

				const nodeElements = nodesGroup.selectAll('.node')
					.data(nodes.filter(d => d.isDrawable), d => d.id) // MODIFIED: Filter by isDrawable
					.enter().append('g')
					.attr('class', d => `node ${isBNode({data:d}) ? 'b-node' : 'standard-node'} ${d.baseName && d.baseName.startsWith('SE-') ? 'se-node' : ''} ${selectedNode && selectedNode.data.id === d.id ? 'selected' : ''}`)
					.attr('transform', d => `translate(${d.customX ?? d.scaledX},${d.customY ?? d.scaledY})`)
					.on("click", (event, d) => {
						event.stopPropagation();
						if (currentTool !== 'select') return;
						clearSelections();
						selectedNode = rootNode.descendants().find(n => n.id === d.id);
						d3.select(event.currentTarget).classed('selected', true);
						updateInfoPanel();
						updateDeleteButtonState();
					}).on("dblclick", (event, d) => {
						event.preventDefault();
						event.stopPropagation();
						const hierarchyNode = rootNode.descendants().find(n => n.id === d.id);
						if (hierarchyNode) reorderGraphFromNode(hierarchyNode);
					});

				nodeElements.each(function(d) {
					const group = d3.select(this);
					const d3Node = {data: d};
					const symbolToDraw = d.symbolType || d.description;

					if (isBNode(d3Node)) {
						 group.append('rect').attr('x', -symbolRadius).attr('y', -symbolRadius).attr('width', symbolSize).attr('height', symbolSize).attr('fill', 'white').style('stroke', 'none');
					}
					getSymbolSVG(symbolToDraw, group, d);
				});

				const textElements = nodeElements.append('text')
					.attr('dy', '0.31em')
					.attr('x', d => {
						if (d.customTextX !== undefined) return d.customTextX;
						if (isBNode({data:d}) || isSeccionadorType(d)) {
							const radius = getNodeRadius({data:d});
							return radius + 6;
						}
						return 0;
					})
					.attr('y', d => {
						if (d.customTextY !== undefined) return d.customTextY;
						if (isBNode({data:d}) || isSeccionadorType(d)) {
							return 0;
						}
						const radius = getNodeRadius({data:d});
						return radius + 6;
					})
					.attr('text-anchor', d => {
						if (d.textAnchor) return d.textAnchor;
						if (isBNode({data:d}) || isSeccionadorType(d)) {
							return 'start';
						}
						return 'middle';
					})
					.text(d => d.displayName || d.baseName)
					.attr('pointer-events', 'auto')
					.style('font-size', d => d.fontSize ? `${d.fontSize}px` : null) // Use null to let CSS handle default
					.style('fill', d => d.textColor || null) // Use null to let CSS handle default
					.style('visibility', d => d.textVisible === false ? 'hidden' : 'visible');


				textElements.on("dblclick", (event, d) => {
					event.preventDefault();
					event.stopPropagation();
					if (currentTool !== 'select') return;
					
					showTextInputBox("Editar nombre:", d.displayName || d.baseName, (newName) => {
						if (newName && newName.trim() !== "") {
							const nodeInData = currentGraphData.nodes.find(n => n.id === d.id);
							if (nodeInData) {
								nodeInData.displayName = newName.trim();
								saveState();
								drawGraph(currentGraphData);
							}
						}
					});
				});

				textElements.call(textDrag);

				redrawAllLinks(nodeMap);
				
				nodeElements.call(d3.drag().on("start", dragstarted).on("drag", dragged).on("end", dragended));
				
				function dragstarted(event, d) {
					if(currentTool === 'select') {
						d3.select(this).raise();
					}
				}
				
				function dragged(event, d) {
					if(currentTool !== 'select') return;
					const transform = d3.zoomTransform(svg.node());
					d.customX = (d.customX || d.scaledX) + event.dx / transform.k;
					d.customY = (d.customY || d.scaledY) + event.dy / transform.k;
					d3.select(this).attr("transform", `translate(${d.customX},${d.customY})`);
					redrawAllLinks(nodeMap);
				}
				
				function dragended(event, d) {
					if(currentTool === 'select') {
						const sourceNode = currentGraphData.nodes.find(n => n.id === d.id);
						if (sourceNode) {
							sourceNode.customX = d.customX;
							sourceNode.customY = d.customY;
						}
						updateAllCustomConnections();
						saveState();
					}
				}

				initializeZoom();
				const rootCoords = nodes.find(n => n.id === rootId);
				if (rootCoords) {
					const parent = svg.node().parentElement;
					const parentWidth = parent.clientWidth;
					const scale = 0.75;
					
					const targetContentX = rootCoords.scaledX;
					const targetContentY = rootCoords.scaledY;
					
					const targetViewportX = parentWidth / 2;
					const targetViewportY = 120;
					
					const translateX = targetViewportX - targetContentX * scale;
					const translateY = targetViewportY - targetContentY * scale;
					
					const initialTransform = d3.zoomIdentity.translate(translateX, translateY).scale(scale);
					svg.call(zoom.transform, initialTransform);
				}
				
				populateSearchSuggestions();

			} else {
				const width = container.clientWidth;
				const height = container.clientHeight;
				svg.attr("width", width).attr("height", height);
				rootNode = null;
				initializeZoom();
			}

			drawAnnotations();
			drawCustomElements();
			updateDeleteButtonState();
			updateUndoRedoButtons();
			updateClearDrawingsButtonState();
		}
		
		// --- Search and Zoom Functions ---
		function populateSearchSuggestions() {
			if (!currentGraphData.nodes) return;
			const suggestions = document.getElementById('search-suggestions');
			suggestions.innerHTML = '';
			const visibleNodes = currentGraphData.nodes.filter(d => d.isDrawable); // MODIFIED: Filter by isDrawable

			visibleNodes.forEach(d => {
				const option = document.createElement('option');
				option.value = d.displayName || d.baseName;
				suggestions.appendChild(option);
			});
		}

		function handleSearch(event) {
			const searchTerm = event.target.value;
			if (!currentGraphData.nodes) return;

			const targetNode = currentGraphData.nodes.find(d => (d.displayName || d.baseName) === searchTerm);

			if (targetNode) {
				zoomToNode(targetNode);
				event.target.value = '';
				event.target.blur();
			}
		}

		function zoomToNode(node) {
			if (!node) return;

			clearSelections();
			selectedNode = rootNode.descendants().find(n => n.id === node.id);
			d3.selectAll('.node').filter(d => d.id === node.id).classed('selected', true);
			updateInfoPanel();
			updateDeleteButtonState();

			const svg = d3.select("#graph-svg");
			const container = document.getElementById('visualization-container');
			const width = container.clientWidth;
			
			const nodeX = node.customX !== undefined ? node.customX : node.scaledX;
			const nodeY = node.customY !== undefined ? node.customY : node.scaledY;

			const scale = 1.2;
			const tx = width / 2 - scale * nodeX;
			const ty = 120 - scale * nodeY; // Position 120px from the top

			const transform = d3.zoomIdentity.translate(tx, ty).scale(scale);

			svg.transition()
				.duration(750)
				.call(zoom.transform, transform);
		}


		// --- Custom Element Functions ---
		
		function getPointOnSquarePerimeter(angle, radius) {
			const cos = Math.cos(angle);
			const sin = Math.sin(angle);
			
			if (Math.abs(cos) < 1e-9) return { x: 0, y: radius * Math.sign(sin) };
			if (Math.abs(sin) < 1e-9) return { x: radius * Math.sign(cos), y: 0 };

			if (Math.abs(cos) > Math.abs(sin)) {
				return { x: radius * Math.sign(cos), y: radius * sin / Math.abs(cos) };
			} else {
				return { x: radius * cos / Math.abs(sin), y: radius * Math.sign(sin) };
			}
		}

		function drawCustomElements() {
			const g = d3.select("g.graph-content");
			g.selectAll('.custom-element-group').remove();	

			const customGroups = g.selectAll('.custom-element-group')
				.data(currentGraphData.customElements, d => d.id)
				.join('g')
				.attr('class', 'custom-element-group')
				.classed('selected', d => selectedCustomElement && selectedCustomElement.id === d.id)
				.attr('transform', d => `translate(${d.x}, ${d.y}) rotate(${d.rotation || 0})`);

			customGroups.each(function(d_el) {
				const group = d3.select(this);
				group.selectAll("*").remove();
				
				const theme = colorThemes[d_el.color] || colorThemes.green;

				let baseRadius = 15;
				const isCustomCT = ['star', 'ct-default', 'ct-circle-in-square', 'ct-circle-with-lines', 'ct-box-switch'].includes(d_el.symbolType);
				const isSeccionador = ['seccionador', 'secc-autodesc', 'secc-autodesc-b-c', 'md-barra-ct'].includes(d_el.symbolType);

				if (isCustomCT) {
					baseRadius *= 1.3;
				} else if (isSeccionador) {
					baseRadius *= 0.8;
				}
				const symbolRadius = baseRadius;
				
				const symbolGroup = group.append('g').attr('class', 'symbol-container');
				getSymbolSVG(d_el.symbolType || 'ct-default', symbolGroup, d_el);
				
				if (d_el.symbolType !== 'ground') {
					const textElement = group.append('text')
						.attr('dy', '0.31em')
						.text(d => d.name)
						.style('font-size', d => d.fontSize ? `${d.fontSize}px` : null)
						.style('fill', d => d.textColor || null)
						.style('visibility', d => d.textVisible === false ? 'hidden' : 'visible');


					const isCustomSeccionador = ['seccionador', 'secc-autodesc', 'secc-autodesc-b-c', 'md-barra-ct', 'seccionalizador', 'seccionalizador-unipolar', 'reconectador'].includes(d_el.symbolType);

					if (isCustomCT || isCustomSeccionador) {
						textElement
							.classed('custom-ct-text', isCustomCT)
							.attr('x', d => d.customTextX !== undefined ? d.customTextX : symbolRadius + 6)
							.attr('y', d => d.customTextY !== undefined ? d.customTextY : 0)
							.attr('text-anchor', d => d.textAnchor || 'start');
					} else {
						textElement
							.attr('x', d => d.customTextX !== undefined ? d.customTextX : 0)
							.attr('y', d => d.customTextY !== undefined ? d.customTextY : symbolRadius + 6)
							.attr('text-anchor', d => d.textAnchor || 'middle');
					}
					
					textElement.call(textDrag);

					textElement.on("dblclick", (event, d_text) => {
						event.preventDefault();
						event.stopPropagation();
						if (currentTool !== 'select') return;
						showTextInputBox("Editar nombre:", d_text.name, (newName) => {
							if (newName && newName.trim() !== "" && newName !== d_text.name) {
								d_text.name = newName.trim();
								saveState();
								drawCustomElements();
								updateInfoPanel();
							}
						});
					});
				}

				const numOutputs = d_el.numConnections || 0;
				const outputSymbolRadius = 12;

				for (let i = 0; i < numOutputs; i++) {
					let angle;
					const connection = d_el.connections[i];
					if (d_el.distributionMode === 'manual' && connection && typeof connection.angle === 'number') {
						angle = connection.angle;
					} else if (numOutputs === 1 && d_el.connections[0] && typeof d_el.connections[0].angle === 'number') {
						angle = d_el.connections[0].angle;
					}
					else {
						angle = (Math.PI / (numOutputs + 1)) * (i + 1);
					}
					
					const { x: edgeX, y: edgeY } = getPointOnSquarePerimeter(angle, symbolRadius);
					const symbolX = edgeX + (outputSymbolRadius + 4) * Math.cos(angle);
					const symbolY = edgeY + (outputSymbolRadius + 4) * Math.sin(angle);

					const connectionGroup = group.append('g')
						.datum({ connIndex: i, element: d_el })
						.attr('class', 'connector-group')
						.classed('connection-selected', selectedConnection && selectedConnection.parentElement.id === d_el.id && selectedConnection.connIndex === i)
						.attr('transform', `translate(${symbolX}, ${symbolY})`);

					const symbolData = { state: connection.state, color: d_el.color };
					getSymbolSVG(connection.symbolType || 'seccionador', connectionGroup, symbolData, outputSymbolRadius);
					
					const connText = connectionGroup.append('text')
						.attr('class', 'terminal-output-label')
						.attr('x', d => connection.customTextX !== undefined ? connection.customTextX : outputSymbolRadius + 4)
						.attr('y', d => connection.customTextY !== undefined ? connection.customTextY : 0)
						.attr('dy', '0.31em')
						.attr('text-anchor', 'start')
						.text(connection.name || `Salida ${i + 1}`);

					connText.call(connectionTextDrag);

					connText.on('dblclick', function(event) {
						event.preventDefault();
						event.stopPropagation();
						showTextInputBox("Editar nombre de salida:", connection.name, (newName) => {
							if (newName && newName.trim() !== "" && newName !== connection.name) {
								connection.name = newName;
								saveState();
								drawCustomElements();
								updateInfoPanel();
							}
						});
					});

					connectionGroup.on('click', function(event) {
						event.stopPropagation();
						if (currentTool !== 'select') return;
						clearSelections();
						selectedConnection = { parentElement: d_el, connIndex: i };
						d3.select(this).classed('connection-selected', true);
						updateDeleteButtonState();
						updateInfoPanel();
					});

					if (d_el.distributionMode === 'manual') {
						connectionGroup.classed('manual-mode', true).call(d3.drag()
							.on('start', function(event) {
								event.sourceEvent.stopPropagation();
							})
							.on('drag', function(event, connData) {
								const [pointerX, pointerY] = d3.pointer(event.sourceEvent, g.node());
								const newAngle = Math.atan2(pointerY - d_el.y, pointerX - d_el.x);
								d_el.connections[connData.connIndex].angle = newAngle;
								drawCustomElements();
							})
							.on('end', function() {
								saveState();
							})
						);
					}

					if (numOutputs === 1 && d_el.connections[0] && d_el.connections[0].point) {
						const connection = d_el.connections[0];
						const vecX = (connection.point.x - d_el.x) - symbolX;
						const vecY = (connection.point.y - d_el.y) - symbolY;
						const mag = Math.sqrt(vecX * vecX + vecY * vecY);
						
						let lineStartX = symbolX;
						let lineStartY = symbolY;

						if (mag > 0) {
							const normX = vecX / mag;
							const normY = vecY / mag;
							lineStartX = symbolX + normX * outputSymbolRadius;
							lineStartY = symbolY + normY * outputSymbolRadius;
						}

						group.append('line')
							.attr('class', 'connection-line')
							.attr('x1', lineStartX)
							.attr('y1', lineStartY)
							.attr('x2', connection.point.x - d_el.x)
							.attr('y2', connection.point.y - d_el.y)
							.style('stroke', theme.main);
					}
				}
			});

			customGroups.on('click', function(event, d) {
				event.stopPropagation();
				if (currentTool !== 'select') return;
				clearSelections();
				selectedCustomElement = d;
				d3.select(this).classed('selected', true);
				updateDeleteButtonState();
				updateInfoPanel();
			}).on('dblclick', function(event, d) {
				if (currentTool !== 'select') return;
				event.preventDefault();
				event.stopPropagation();
				
				showTextInputBox("Editar nombre:", d.name, (newName) => {
					if (newName && newName.trim() !== "" && newName !== d.name) {
						d.name = newName;
						saveState();
						drawCustomElements();
						updateInfoPanel();
					}
				});
			}).call(d3.drag()
				.on("start", function(event, d) {
					if (currentTool !== 'select') return;
					d3.select(this).raise();
					if (!selectedCustomElement || selectedCustomElement.id !== d.id) {
						clearSelections();
						selectedCustomElement = d;
						d3.select(this).classed('selected', true);
						updateDeleteButtonState();
						updateInfoPanel();
					}
				})
				.on("drag", function(event, d) {
					if (currentTool !== 'select') return;
					const transform = d3.zoomTransform(d3.select("#graph-svg").node());
					const k = transform.k;
					d.x += event.dx / k;
					d.y += event.dy / k;
					
					updateCustomElementConnections(d);
					drawCustomElements();
				})
				.on("end", function(event, d) {
					if (currentTool !== 'select') return;
					saveState();
				})
			);
		}
		
		function updateAllCustomConnections() {
			currentGraphData.customElements.forEach(updateCustomElementConnections);
			drawCustomElements();
		}

		function updateCustomElementConnections(element) {
			if (element.numConnections !== 1) {
				if (!element.connections || element.connections.length !== element.numConnections) {
					element.connections = Array.from({ length: element.numConnections }, (_, i) => ({ id: i, name: `Salida ${i + 1}`, state: 'closed', symbolType: 'seccionador' }));
				}
				return;
			}

			if (!element.connections || element.connections.length !== 1) {
				 element.connections = [{ id: 0, name: 'Salida 1', point: null, angle: -Math.PI / 2, state: 'closed', symbolType: 'seccionador' }];
			}
			
			const closestPathPoint = findClosestConnectionPoint({ x: element.x, y: element.y });
			element.connections[0].point = closestPathPoint;

			if (closestPathPoint) {
				const dx = closestPathPoint.x - element.x;
				const dy = closestPathPoint.y - element.y;
				element.connections[0].angle = Math.atan2(dy, dx);
			} else {
				element.connections[0].angle = -Math.PI / 2;
			}
		}

		function findClosestConnectionPoint(point) {
			const g = d3.select("g.graph-content");
			const cables = g.selectAll('.cable-line, .annotation.line-annotation').nodes();
			let bestCandidate = null;
			let minDistance = 150;	
			const searchRadius = 200;	

			const isPointNearBBox = (p, bbox, threshold) => {
				const closestX = Math.max(bbox.x, Math.min(p.x, bbox.x + bbox.width));
				const closestY = Math.max(bbox.y, Math.min(p.y, bbox.y + bbox.height));
				const dx = p.x - closestX;
				const dy = p.y - closestY;
				return (dx * dx + dy * dy) < (threshold * threshold);
			};

			const candidateCables = cables.filter(pathNode => {
				try {
					const bbox = pathNode.getBBox();
					if (bbox.width === 0 && bbox.height === 0 && pathNode.getTotalLength() === 0) return false;
					return isPointNearBBox(point, bbox, searchRadius);
				} catch (e) {
					return false;
				}
			});

			candidateCables.forEach(pathNode => {
				const result = getClosestPointOnPath(pathNode, point);
				if (result && result.distance < minDistance) {
					minDistance = result.distance;
					bestCandidate = result.point;
				}
			});

			return bestCandidate;
		}

		function getClosestPointOnPath(pathNode, point) {
			if (pathNode.tagName === 'line') {
				const x1 = pathNode.x1.baseVal.value;
				const y1 = pathNode.y1.baseVal.value;
				const x2 = pathNode.x2.baseVal.value;
				const y2 = pathNode.y2.baseVal.value;

				const A = point.x - x1;
				const B = point.y - y1;
				const C = x2 - x1;
				const D = y2 - y1;

				const dot = A * C + B * D;
				const len_sq = C * C + D * D;
				let param = -1;
				if (len_sq !== 0)	
					param = dot / len_sq;

				let xx, yy;

				if (param < 0) {
					xx = x1;
					yy = y1;
				} else if (param > 1) {
					xx = x2;
					yy = y2;
				} else {
					xx = x1 + param * C;
					yy = y1 + param * D;
				}

				const dx = point.x - xx;
				const dy = point.y - yy;
				return { point: { x: xx, y: yy }, distance: Math.sqrt(dx * dx + dy * dy) };

			} else { // It's a path
				const pathLength = pathNode.getTotalLength();
				if (pathLength === 0) return null;
				let precision = 8;
				let bestPoint = null;
				let bestLength = 0;
				let bestDistance = Infinity;

				for (let scanLength = 0; scanLength <= pathLength; scanLength += precision) {
					const p = pathNode.getPointAtLength(scanLength);
					const dx = p.x - point.x;
					const dy = p.y - point.y;
					const dist = Math.sqrt(dx * dx + dy * dy);
					if (dist < bestDistance) {
						bestPoint = p;
						bestLength = scanLength;
						bestDistance = dist;
					}
				}
				
				precision /= 2;
				while (precision > 0.5) {
					const beforeLength = Math.max(0, bestLength - precision);
					const afterLength = Math.min(pathLength, bestLength + precision);
					
					const pBefore = pathNode.getPointAtLength(beforeLength);
					const dBefore = Math.hypot(pBefore.x - point.x, pBefore.y - point.y);

					const pAfter = pathNode.getPointAtLength(afterLength);
					const dAfter = Math.hypot(pAfter.x - point.x, pAfter.y - point.y);

					if (dBefore < bestDistance) {
						bestDistance = dBefore;
						bestPoint = pBefore;
						bestLength = beforeLength;
					}
					if (dAfter < bestDistance) {
						bestDistance = dAfter;
						bestPoint = pAfter;
						bestLength = afterLength;
					}
					precision /= 2;
				}
				return { point: bestPoint, distance: bestDistance };
			}
		}


		// --- History, State, and Sketch Management ---
		function hideInfoPanel() {
			document.getElementById('info-panel').classList.add('translate-x-full');
		}
		
		function clearSelections() {
			selectedNode = null;
			selectedAnnotation = null;
			selectedCustomElement = null;
			selectedConnection = null;
			selectedEdge = null;
			d3.selectAll('.node.selected').classed('selected', false);
			d3.selectAll('.annotation-group.selected').classed('selected', false);
			d3.selectAll('.custom-element-group.selected').classed('selected', false);
			d3.selectAll('.connector-group.connection-selected').classed('connection-selected', false);
			d3.selectAll('.link-visual.selected').classed('selected', false);
			
			multiSelectedNodes.clear();
			d3.selectAll('.node.multi-selected').classed('multi-selected', false);
			document.getElementById('filter-selection-btn').disabled = true;

			hideInfoPanel();
		}

		function updateDeleteButtonState() {
			document.getElementById('delete-btn').disabled = !selectedNode && !selectedAnnotation && !selectedCustomElement && !selectedConnection && !selectedEdge;
		}

		function updateUndoRedoButtons() {
			document.getElementById('undo-btn').disabled = historyIndex <= 0;
			document.getElementById('redo-btn').disabled = historyIndex >= history.length - 1;
		}
		
		function updateClearDrawingsButtonState() {
			document.getElementById('clear-drawings-btn').disabled = currentGraphData.nodes.length === 0 && currentGraphData.annotations.length === 0 && currentGraphData.customElements.length === 0;
		}

		function saveState() {
			history = history.slice(0, historyIndex + 1);
			const newState = JSON.parse(JSON.stringify(currentGraphData));
			history.push(newState);
			historyIndex++;
			updateUndoRedoButtons();
		}

		function undo() {
			if (historyIndex <= 0) return;
			historyIndex--;
			currentGraphData = JSON.parse(JSON.stringify(history[historyIndex]));
			directedAdj = null;
			parentMap = null;
			clearSelections();
			drawGraph(currentGraphData);
			updateUndoRedoButtons();
		}

		function redo() {
			if (historyIndex >= history.length - 1) return;
			historyIndex++;
			currentGraphData = JSON.parse(JSON.stringify(history[historyIndex]));
			directedAdj = null;
			parentMap = null;
			clearSelections();
			drawGraph(currentGraphData);
			updateUndoRedoButtons();
		}
		
		function downloadObjectAsJson(exportObj, exportName){
			const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(exportObj, null, 2));
			const downloadAnchorNode = document.createElement('a');
			downloadAnchorNode.setAttribute("href", dataStr);
			downloadAnchorNode.setAttribute("download", exportName);
			document.body.appendChild(downloadAnchorNode); // required for firefox
			downloadAnchorNode.click();
			downloadAnchorNode.remove();
		}

		function handleDownloadCurrentSketch() {
			if (currentGraphData.nodes.length === 0 && currentGraphData.annotations.length === 0 && currentGraphData.customElements.length === 0) {
				showMessageBox("No hay nada que descargar en el lienzo actual.");
				return;
			}
			const filename = `esquema-${new Date().toISOString().slice(0,10)}.json`;
			downloadObjectAsJson(currentGraphData, filename);
		}

		function loadSketchData(dataToLoad, fileName) {
			saveState();
			originalGraphData = JSON.parse(JSON.stringify(dataToLoad));
			currentGraphData = dataToLoad;
			directedAdj = null;
			parentMap = null;
			clearSelections();
			drawGraph(currentGraphData);

			if (initialCsvData) {
				document.getElementById('revert-to-csv-btn').classList.remove('hidden');
			}
			
			showMessageBox(`Croquis '${fileName}' cargado correctamente.`);
		}
		
		function mergeSketchData(sketchToMerge, fileName) {
			try {
				if (currentGraphData.nodes.length === 0 && currentGraphData.customElements.length === 0 && currentGraphData.annotations.length === 0) {
					// If current canvas is empty, just load the sketch
					originalGraphData = JSON.parse(JSON.stringify(sketchToMerge));
					currentGraphData = sketchToMerge;
				} else {
					const originalRootId = currentGraphData.rootId;
					const mergeRootId = sketchToMerge.rootId;
					const mergeSuffix = `_m${Date.now()}`;
					const idMap = new Map();
					let dataOffsetX = 0;
					let screenOffsetX = 0;
					const spacingMultiplier = 40;
					const screenPadding = 200;

					const currentDataNodes = currentGraphData.nodes.filter(n => n.x !== undefined);
					const mergeDataNodes = sketchToMerge.nodes.filter(n => n.x !== undefined);
					if (currentDataNodes.length > 0 && mergeDataNodes.length > 0) {
						const currentDataXExtent = d3.extent(currentDataNodes, d => d.x);
						const mergeDataXExtent = d3.extent(mergeDataNodes, d => d.x);
						const dataPadding = (currentDataXExtent[1] - currentDataXExtent[0]) * 0.2;
						dataOffsetX = currentDataXExtent[1] - mergeDataXExtent[0] + (dataPadding || 5);
					}

					const allCurrentDrawings = [...currentGraphData.customElements, ...currentGraphData.annotations];
					if (allCurrentDrawings.length > 0) {
						let currentScreenMaxX = -Infinity;
						allCurrentDrawings.forEach(el => {
							if (el.x !== undefined) currentScreenMaxX = Math.max(currentScreenMaxX, el.x + (el.width || 0));
							if (el.cx !== undefined) currentScreenMaxX = Math.max(currentScreenMaxX, el.cx + (el.rx || 0));
							if (el.x2 !== undefined) currentScreenMaxX = Math.max(currentScreenMaxX, el.x2);
						});
						if (isFinite(currentScreenMaxX)) {
							screenOffsetX = currentScreenMaxX + screenPadding;
						}
					}

					if (dataOffsetX && !screenOffsetX) screenOffsetX = dataOffsetX * spacingMultiplier;
					if (screenOffsetX && !dataOffsetX) dataOffsetX = screenOffsetX / spacingMultiplier;

					sketchToMerge.nodes.forEach(node => {
						const oldId = node.id;
						const newId = `${oldId}${mergeSuffix}`;
						idMap.set(oldId, newId);
						const newNode = { ...node, id: newId };
						if (newNode.x !== undefined && dataOffsetX) newNode.x += dataOffsetX;
						currentGraphData.nodes.push(newNode);
					});

					sketchToMerge.edges.forEach(edge => {
						const newSource = idMap.get(edge.source);
						const newTarget = idMap.get(edge.target);
						if (newSource && newTarget) {
							currentGraphData.edges.push({ ...edge, source: newSource, target: newTarget });
						}
					});
					
					const newMergeRootId = mergeRootId ? idMap.get(mergeRootId) : null;
					if (originalRootId && newMergeRootId) {
						currentGraphData.edges.push({
							source: originalRootId,
							target: newMergeRootId,
							state: 'closed',
							isMergeLink: true
						});
					}

					sketchToMerge.customElements.forEach(el => {
						const oldId = el.id;
						const newId = `${oldId}${mergeSuffix}`;
						idMap.set(oldId, newId);
						const newEl = { ...el, id: newId };
						if (newEl.x !== undefined && screenOffsetX) newEl.x += screenOffsetX;
						if (newEl.point?.x !== undefined && screenOffsetX) newEl.point.x += screenOffsetX;
						currentGraphData.customElements.push(newEl);
					});

					sketchToMerge.annotations.forEach(anno => {
						const oldId = anno.id;
						const newId = `${oldId}${mergeSuffix}`;
						idMap.set(oldId, newId);
						const newAnno = { ...anno, id: newId };
						if (screenOffsetX) {
							if (newAnno.x !== undefined) newAnno.x += screenOffsetX;
							if (newAnno.cx !== undefined) newAnno.cx += screenOffsetX;
							if (newAnno.x1 !== undefined) newAnno.x1 += screenOffsetX;
							if (newAnno.x2 !== undefined) newAnno.x2 += screenOffsetX;
						}
						currentGraphData.annotations.push(newAnno);
					});
				}

				parentMap = null;
				directedAdj = null;
				
				saveState();
				drawGraph(currentGraphData);
				
				showMessageBox(`Croquis '${fileName}' fusionado correctamente.`);

			} catch (error) {
				console.error("Error al fusionar el croquis:", error);
				if (error.message.includes("multiple roots")) {
					showError(`No se pudo fusionar el archivo. El croquis a fusionar parece tener una estructura incompatible.`);
				} else {
					showError(`No se pudo fusionar el archivo. (${error.message})`);
				}
			}
		}

		function handleUploadSketch(event) {
			if (event.target.disabled) return;
			const file = event.target.files[0];
			if (!file) return;

			const reader = new FileReader();
			reader.onload = (e) => {
				try {
					const uploadedData = JSON.parse(e.target.result);
					
					if (typeof uploadedData !== 'object' || uploadedData === null || !('nodes' in uploadedData) || !('edges' in uploadedData) || !('annotations' in uploadedData) || !('customElements' in uploadedData)) {
						throw new Error("El archivo no parece ser un croquis válido.");
					}

					const isCanvasEmpty = currentGraphData.nodes.length === 0 && currentGraphData.annotations.length === 0 && currentGraphData.customElements.length === 0;

					if (isCanvasEmpty) {
						loadSketchData(uploadedData, file.name);
					} else {
						showChoiceBox(
							"Ya hay un dibujo en el lienzo. ¿Qué deseas hacer?",
							[
								{ text: 'Reemplazar', class: 'btn-danger' },
								{ text: 'Añadir', class: 'btn-confirm' }
							],
							(choice) => {
								if (choice === 'Reemplazar') {
									loadSketchData(uploadedData, file.name);
								} else if (choice === 'Añadir') {
									mergeSketchData(uploadedData, file.name);
								}
							}
						);
					}
				} catch (error) {
					console.error("Error al cargar el croquis:", error);
					showError(`No se pudo cargar el archivo. Asegúrate de que es un archivo de croquis válido. (${error.message})`);
				} finally {
					event.target.value = '';
				}
			};
			reader.onerror = () => {
				showError("No se pudo leer el archivo del croquis.");
				event.target.value = '';
			};
			reader.readAsText(file);
		}

		function handleMergeSketch(event) {
			if (event.target.disabled) return;
			const file = event.target.files[0];
			if (!file) return;

			const reader = new FileReader();
			reader.onload = (e) => {
				try {
					const sketchToMerge = JSON.parse(e.target.result);

					if (typeof sketchToMerge !== 'object' || sketchToMerge === null || !('nodes' in sketchToMerge)) {
						throw new Error("El archivo no parece ser un croquis válido para fusionar.");
					}
					
					mergeSketchData(sketchToMerge, file.name);

				} catch (error) {
					console.error("Error al procesar el archivo para fusionar:", error);
					showError(`No se pudo procesar el archivo. (${error.message})`);
				} finally {
					event.target.value = '';
				}
			};
			reader.onerror = () => {
				showError("No se pudo leer el archivo del croquis a fusionar.");
				event.target.value = '';
			};
			reader.readAsText(file);
		}

		function handleSaveSketch() {
			if (currentGraphData.nodes.length === 0 && currentGraphData.annotations.length === 0 && currentGraphData.customElements.length === 0) {
				showMessageBox("No hay nada que guardar en el lienzo.");
				return;
			}
			const defaultName = `Croquis ${savedSketches.length + 1}`;
			showTextInputBox("Ingrese un nombre para el croquis:", defaultName, (name) => {
				if (name && name.trim() !== "") {
					const currentState = {
						name: name.trim(),
						data: JSON.parse(JSON.stringify(currentGraphData))
					};
					savedSketches.push(currentState);
					persistSavedSketches();
					updateSavedSketchesDropdown();
					showMessageBox(`'${name.trim()}' guardado correctamente.`);
				}
			});
		}

		function persistSavedSketches() {
			try {
				localStorage.setItem('esquemapp-saved-sketches', JSON.stringify(savedSketches));
			} catch (e) {
				console.error("Error al guardar croquis en localStorage:", e);
				showMessageBox("No se pudo guardar la lista de croquis. El almacenamiento del navegador podría estar lleno o deshabilitado.");
			}
		}

		function updateSavedSketchesDropdown() {
			const list = document.getElementById('saved-sketches-list');
			list.innerHTML = ''; // Clear list

			if (savedSketches.length === 0) {
				list.innerHTML = '<li class="text-center text-gray-500 py-4 px-2">No hay croquis guardados.</li>';
				return;
			}

			savedSketches.forEach((sketch, index) => {
				const li = document.createElement('li');
				li.className = 'flex justify-between items-center p-2 hover:bg-gray-100 rounded-md';
				li.innerHTML = `
					<span class="truncate flex-grow cursor-pointer" onclick="window.app.loadSketch(${index})">${sketch.name}</span>
					<div class="flex items-center flex-shrink-0">
						<button onclick="window.app.downloadSavedSketch(${index}, event)" title="Descargar" class="p-1 text-gray-500 hover:text-green-600">
							<svg class="w-4 h-4" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
								<path stroke-linecap="round" stroke-linejoin="round" d="M3 16.5v2.25A2.25 2.25 0 005.25 21h13.5A2.25 2.25 0 0021 18.75V16.5M16.5 12L12 16.5m0 0L7.5 12m4.5 4.5V3" />
							</svg>
						</button>
						<button onclick="window.app.deleteSketch(${index}, event)" title="Eliminar" class="p-1 text-gray-500 hover:text-red-600">
						 <svg class="w-4 h-4" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm4 0a1 1 0 012 0v6a1 1 0 11-2 0V8z" clip-rule="evenodd" /></svg>
						</button>
					</div>
				`;
				list.appendChild(li);
			});
		}

		function loadSketch(index) {
			if (index < 0 || index >= savedSketches.length) return;
			const sketchToLoad = savedSketches[index];

			try {
				saveState(); // Save current work to history before loading

				const dataToLoad = JSON.parse(JSON.stringify(sketchToLoad.data));

				originalGraphData = JSON.parse(JSON.stringify(dataToLoad));
				currentGraphData = dataToLoad;
				
				directedAdj = null;
				parentMap = null;

				clearSelections();
				drawGraph(currentGraphData);
				
				document.getElementById('saved-sketches-menu').classList.add('hidden');
				showMessageBox(`'${sketchToLoad.name}' cargado.`);
				
				if (initialCsvData) {
					document.getElementById('revert-to-csv-btn').classList.add('hidden');
				}

			} catch (error) {
				console.error(`Error loading sketch '${sketchToLoad.name}':`, error);
				showError(`No se pudo cargar el croquis '${sketchToLoad.name}'. El archivo puede estar dañado.`);
				// Attempt to restore previous state
				if (historyIndex > 0) {
					undo();
				}
			}
		}
		
		function downloadSavedSketch(index, event) {
			event.stopPropagation();
			if (index < 0 || index >= savedSketches.length) return;
			const sketch = savedSketches[index];
			const filename = `${sketch.name.replace(/ /g, '_')}.json`;
			downloadObjectAsJson(sketch.data, filename);
		}

		function deleteSketch(index, event) {
			event.stopPropagation();
			if (index < 0 || index >= savedSketches.length) return;
			
			const sketchName = savedSketches[index].name;
			showMessageBox(`¿Seguro que quieres eliminar '${sketchName}'?`, 'confirm', (confirmed) => {
				if (confirmed) {
					savedSketches.splice(index, 1);
					persistSavedSketches();
					updateSavedSketchesDropdown();
				}
			});
		}


		// --- Deletion Logic ---

		function handleDelete() {
			if (selectedNode) {
				showDeleteOptions();
			} else if (selectedAnnotation) {
				deleteSelectedAnnotation();
			} else if (selectedCustomElement) {
				deleteSelectedCustomElement();
			} else if (selectedConnection) {
				const message = `¿Seguro que quieres eliminar la Salida ${selectedConnection.connIndex + 1}?`;
				showMessageBox(message, 'confirm', (confirmed) => {
					if (confirmed) {
						deleteCustomElementConnection();
					}
				});
			} else if (selectedEdge) {
				deleteSelectedEdge();
			}
		}

		function deleteSelectedEdge() {
			if (!selectedEdge) return;
			const index = currentGraphData.edges.findIndex(e => e.source === selectedEdge.source && e.target === selectedEdge.target);
			if (index > -1) {
				currentGraphData.edges.splice(index, 1);
				clearSelections();
				updateDeleteButtonState();
				saveState();
				drawGraph(currentGraphData);
			}
		}

		function deleteCustomElementConnection() {
			if (!selectedConnection) return;
			const element = selectedConnection.parentElement;
			const connIndex = selectedConnection.connIndex;

			if (element && element.connections && element.connections.length > connIndex) {
				element.connections.splice(connIndex, 1);
				element.numConnections--;
				clearSelections();
				saveState();
				drawCustomElements();
				updateInfoPanel();
			}
		}

		function clearDrawings() {
			if (currentGraphData.nodes.length === 0 && currentGraphData.annotations.length === 0 && currentGraphData.customElements.length === 0) return;

			showMessageBox("¿Estás seguro de que quieres limpiar todo el lienzo? Se eliminará el gráfico cargado y todos los dibujos.", 'confirm', (confirmed) => {
				if (confirmed) {
					initialCsvData = null;
					initialCsvName = '';
					initializeBlankCanvas();
					document.getElementById('file-name').textContent = 'Ningún archivo seleccionado';
					document.getElementById('revert-to-csv-btn').classList.add('hidden');
				}
			});
		}
		
		function deleteSelectedAnnotation() {
			if (!selectedAnnotation) return;
			const index = currentGraphData.annotations.findIndex(a => a.id === selectedAnnotation.id);
			if (index > -1) {
				currentGraphData.annotations.splice(index, 1);
				clearSelections();
				updateDeleteButtonState();
				saveState();
				drawAnnotations();
				updateClearDrawingsButtonState();
			}
		}

		function deleteSelectedCustomElement() {
			if (!selectedCustomElement) return;
			const index = currentGraphData.customElements.findIndex(el => el.id === selectedCustomElement.id);
			if (index > -1) {
				currentGraphData.customElements.splice(index, 1);
				clearSelections();
				updateDeleteButtonState();
				saveState();
				drawCustomElements();
			}
		}

		function showDeleteOptions() {
			if (!selectedNode) return;
			const container = document.getElementById('message-box-container');
			const nodeName = selectedNode.data.displayName;
			container.innerHTML = `
				<div class="message-box">
					<p class="mb-4">¿Qué deseas eliminar para el nodo <b>${nodeName}</b>?</p>
					<button id="del-node" class="btn-danger">Solo este elemento</button>
					<button id="del-downstream" class="btn-danger">Rama Inferior (hijos)</button>
					<button id="del-upstream" class="btn-danger">Rama Superior (padres)</button>
					<button id="del-cancel" class="btn-cancel">Cancelar</button>
				</div>
			`;
			document.getElementById('del-node').onclick = () => { container.innerHTML = ''; deleteSingleNode(); };
			document.getElementById('del-downstream').onclick = () => { container.innerHTML = ''; deleteBranch(selectedNode, 'downstream'); };
			document.getElementById('del-upstream').onclick = () => { container.innerHTML = ''; deleteBranch(selectedNode, 'upstream'); };
			document.getElementById('del-cancel').onclick = () => { container.innerHTML = ''; };
		}
		
		function findConnectedComponents(nodes, edges) {
			if (nodes.length === 0) return [];
			const adj = new Map(nodes.map(d => [d.id, []]));
			edges.forEach(({ source, target }) => {
				if (adj.has(source)) adj.get(source).push(target);
				if (adj.has(target)) adj.get(target).push(source);
			});

			const visited = new Set();
			const components = [];

			nodes.forEach(node => {
				if (!visited.has(node.id)) {
					const component = new Set();
					const queue = [node.id];
					visited.add(node.id);
					component.add(node.id);

					while (queue.length > 0) {
						const u = queue.shift();
						const neighbors = adj.get(u) || [];
						neighbors.forEach(v => {
							if (!visited.has(v)) {
								visited.add(v);
								component.add(v);
								queue.push(v);
							}
						});
					}
					components.push(component);
				}
			});
			return components;
		}

		function pruneAndRedraw() {
			if (currentGraphData.nodes.length === 0) {
				initializeBlankCanvas();
				showMessageBox("Todos los elementos han sido eliminados.");
				return;
			}

			const components = findConnectedComponents(currentGraphData.nodes, currentGraphData.edges);
			if (components.length === 0) {
				initializeBlankCanvas();
				return;
			}

			let mainComponent;
			const rootComponent = components.find(c => c.has(currentGraphData.rootId));

			if (rootComponent) {
				mainComponent = rootComponent;
			} else {
				mainComponent = components.reduce((largest, current) =>
					current.size > largest.size ? current : largest
				);
				
				const mainComponentNodes = currentGraphData.nodes.filter(n => mainComponent.has(n.id));
				if (mainComponentNodes.length > 0) {
					const newRootNode = mainComponentNodes.reduce((topmost, current) => (current.y < topmost.y) ? current : topmost);
					currentGraphData.rootId = newRootNode.id;
				} else {
					initializeBlankCanvas();
					return;
				}
			}

			currentGraphData.nodes = currentGraphData.nodes.filter(n => mainComponent.has(n.id));
			currentGraphData.edges = currentGraphData.edges.filter(e => mainComponent.has(e.source) && mainComponent.has(e.target));

			directedAdj = null;
			parentMap = null;
			saveState();
			clearSelections();
			updateDeleteButtonState();
			drawGraph(currentGraphData);
		}

		function deleteSingleNode() {
			if (!selectedNode) return;
			const nodeIdToDelete = selectedNode.data.id;
			const parent = selectedNode.parent;
			const children = selectedNode.children || [];
			
			currentGraphData.nodes = currentGraphData.nodes.filter(n => n.id !== nodeIdToDelete);
			currentGraphData.edges = currentGraphData.edges.filter(e => e.source !== nodeIdToDelete && e.target !== nodeIdToDelete);

			if (parent && children.length > 0) {
				const parentId = parent.data.id;
				children.forEach(child => {
					const edgeExists = currentGraphData.edges.some(e =>
						(e.source === parentId && e.target === child.data.id) ||
						(e.source === child.data.id && e.target === parentId)
					);
					if (!edgeExists) {
						currentGraphData.edges.push({ source: parentId, target: child.data.id, state: 'closed' });
					}
				});
			}
			
			pruneAndRedraw();
		}

		function deleteBranch(startNode, direction = 'downstream') {
			if (!startNode) return;
			const nodesToDelete = new Set();

			if (direction === 'downstream') {
				nodesToDelete.add(startNode.data.id);
				const collectDescendants = (node) => {
					if (node.children) {
						node.children.forEach(child => {
							nodesToDelete.add(child.data.id);
							collectDescendants(child);
						});
					}
				};
				collectDescendants(startNode);
			} else if (direction === 'upstream') {
				const collectAncestors = (node) => {
					if (node.parent) {
						nodesToDelete.add(node.parent.data.id);
						collectAncestors(node.parent);
					}
				};
				collectAncestors(startNode);
				currentGraphData.rootId = startNode.data.id;
			}
			
			currentGraphData.nodes = currentGraphData.nodes.filter(n => !nodesToDelete.has(n.id));
			currentGraphData.edges = currentGraphData.edges.filter(e => !nodesToDelete.has(e.source) && !nodesToDelete.has(e.target));

			pruneAndRedraw();
		}

		function editConnectionName(elementId, connIndex) {
			const element = currentGraphData.customElements.find(el => el.id === elementId);
			if (element && element.connections[connIndex]) {
				const connection = element.connections[connIndex];
				showTextInputBox("Editar nombre de salida:", connection.name, (newName) => {
					if (newName && newName.trim() !== "" && newName !== connection.name) {
						connection.name = newName;
						saveState();
						drawCustomElements();
						updateInfoPanel();
					}
				});
			}
    	}

		function updateInfoPanel() {
			const panel = document.getElementById('info-panel');
			const content = document.getElementById('info-content');
			
			if (selectedNode) {
				const d = selectedNode;
				panel.classList.remove('translate-x-full');
				const nodeData = currentGraphData.nodes.find(n => n.id === d.data.id);
				if (!nodeData) {
					content.innerHTML = `<p class="text-gray-500">Error: No se encontraron datos para el nodo seleccionado.</p>`;
					return;
				}
				let html = `<h3 class="text-lg font-bold text-gray-800 mb-4">${d.data.displayName}</h3>`;
				
				const connectionCount = (d.parent ? 1 : 0) + (d.children ? d.children.length : 0);
				
				let textOptionsHTML = `
					<details class="mt-4 border-t pt-2">
						<summary class="font-semibold text-md text-gray-700">Opciones de Texto</summary>
						<div class="space-y-2 mt-2 p-2 bg-gray-50 rounded-md">
							<div class="flex justify-between items-center">
								<label for="text-visible-toggle" class="text-sm text-gray-600">Visible</label>
								<input type="checkbox" id="text-visible-toggle" ${nodeData.textVisible !== false ? 'checked' : ''} onchange="window.app.changeElementTextProperty('${d.data.id}', 'node', 'textVisible', this.checked)">
							</div>
							<div class="flex justify-between items-center">
								<label for="text-size-input" class="text-sm text-gray-600">Tamaño (px)</label>
								<input type="number" id="text-size-input" value="${nodeData.fontSize || (isBNode(d) ? 18 : 9)}" class="w-16 p-1 border border-gray-300 rounded-md text-sm" onchange="window.app.changeElementTextProperty('${d.data.id}', 'node', 'fontSize', this.value)">
							</div>
							<div>
								<label class="text-sm text-gray-600 mb-1 block">Color</label>
								<div class="flex gap-2 flex-wrap">
									${textColors.map(color => {
										const defaultColor = isBNode(d) ? '#800000' : '#1f2937';
										const currentColor = nodeData.textColor || defaultColor;
										const isActive = currentColor === color.hex;
										const borderClass = isActive ? 'ring-2 ring-offset-2 ring-gray-800' : 'ring-1 ring-gray-300';
										return `<div onclick="window.app.changeElementTextProperty('${d.data.id}', 'node', 'textColor', '${color.hex}')" class="w-6 h-6 rounded-full cursor-pointer ${borderClass}" style="background-color: ${color.hex};"></div>`;
									}).join('')}
								</div>
							</div>
						</div>
					</details>
				`;

				html += `<div class="space-y-3"><p class="text-sm text-gray-600">Conexiones: ${connectionCount}</p>`;

				// Add state toggle for nodes that can be opened/closed (i.e., not CTs)
				if (!isBNode(d)) {
					html += `<div class="flex justify-between items-center mb-2"><span class="text-sm text-gray-600">Estado: ${nodeData.state === 'closed' ? 'Cerrado' : 'Abierto'}</span><button onclick="window.app.toggleNodeState('${d.data.id}')" class="px-3 py-1 text-sm rounded ${nodeData.state === 'closed' ? 'bg-green-500' : 'bg-gray-400'} text-white">Cambiar</button></div>`;
				}

				// Add text options for all nodes
				html += textOptionsHTML;

				// Add symbol options for CTs and Seccionadores
				if (isBNode(d) || isSeccionadorType(nodeData)) {
					const ct_symbols = [
						{ name: 'Personalizado', type: 'star' },
						{ name: 'CT Aéreo', type: 'ct-default' },
						{ name: 'CT Subterráneo', type: 'ct-circle-in-square' },
						{ name: 'CBP', type: 'ct-circle-with-lines' },
						{ name: 'Caja Seccionadora', type: 'ct-box-switch' }
					];
					
					const seccionadores_symbols = [
						{ name: 'Seccionador', type: 'seccionador' },
						{ name: 'Secc. Autodesc.', type: 'secc-autodesc' },
						{ name: 'Secc. Autodesc. B/C Unipolar', type: 'secc-autodesc-b-c' },
						{ name: 'MD Barra CT', type: 'md-barra-ct' }
					];

					const otros_symbols = [
						{ name: 'Seccionalizador', type: 'seccionalizador' },
						{ name: 'Seccionalizador Unipolar', type: 'seccionalizador-unipolar' },
						{ name: 'Reconectador', type: 'reconectador' }
					];

					const buildNodeSymbolOptions = (symbols, node) => symbols.map(symbol => {
						const isActive = (node.data.symbolType || node.data.description) === symbol.type;
						return `<div class="symbol-option flex items-center gap-3 ${isActive ? 'active' : ''}" onclick="window.app.changeNodeSymbol('${node.data.id}', '${symbol.type}')">
									<svg width="30" height="30" viewBox="-15 -15 30 30">${getSymbolSVGString(symbol.type, node.data)}</svg>
									<span class="text-sm">${symbol.name}</span>
								</div>`;
					}).join('');

					html += `
						<details class="mt-4 border-t pt-2">
							<summary class="font-semibold text-md text-gray-700">Símbolos CT</summary>
							<div class="space-y-2 mt-2">${buildNodeSymbolOptions(ct_symbols, d)}</div>
						</details>
						<details class="mt-2 border-t pt-2">
							<summary class="font-semibold text-md text-gray-700">Seccionadores</summary>
							<div class="space-y-2 mt-2">${buildNodeSymbolOptions(seccionadores_symbols, d)}</div>
						</details>
						<details class="mt-2 border-t pt-2">
							<summary class="font-semibold text-md text-gray-700">Otros</summary>
							<div class="space-y-2 mt-2">${buildNodeSymbolOptions(otros_symbols, d)}</div>
						</details>
					`;
				}
				
				html += `</div>`;
				content.innerHTML = html;
			} else if (selectedCustomElement) {
				panel.classList.remove('translate-x-full');
				const d = selectedCustomElement;
				
				let textOptionsHTML = `
					<details class="mt-4 border-t pt-2">
						<summary class="font-semibold text-md text-gray-700">Opciones de Texto</summary>
						<div class="space-y-2 mt-2 p-2 bg-gray-50 rounded-md">
							<div class="flex justify-between items-center">
								<label for="text-visible-toggle" class="text-sm text-gray-600">Visible</label>
								<input type="checkbox" id="text-visible-toggle" ${d.textVisible !== false ? 'checked' : ''} onchange="window.app.changeElementTextProperty('${d.id}', 'custom', 'textVisible', this.checked)">
							</div>
							<div class="flex justify-between items-center">
								<label for="text-size-input" class="text-sm text-gray-600">Tamaño (px)</label>
								<input type="number" id="text-size-input" value="${d.fontSize || 18}" class="w-16 p-1 border border-gray-300 rounded-md text-sm" onchange="window.app.changeElementTextProperty('${d.id}', 'custom', 'fontSize', this.value)">
							</div>
							<div>
								<label class="text-sm text-gray-600 mb-1 block">Color</label>
								<div class="flex gap-2 flex-wrap">
									${textColors.map(color => {
										const defaultColor = '#800000';
										const currentColor = d.textColor || defaultColor;
										const isActive = currentColor === color.hex;
										const borderClass = isActive ? 'ring-2 ring-offset-2 ring-gray-800' : 'ring-1 ring-gray-300';
										return `<div onclick="window.app.changeElementTextProperty('${d.id}', 'custom', 'textColor', '${color.hex}')" class="w-6 h-6 rounded-full cursor-pointer ${borderClass}" style="background-color: ${color.hex};"></div>`;
									}).join('')}
								</div>
							</div>
						</div>
					</details>
				`;

				const ct_symbols = [
					{ name: 'Personalizado', type: 'star' },
					{ name: 'CT Aéreo', type: 'ct-default' },
					{ name: 'CT Subterráneo', type: 'ct-circle-in-square' },
					{ name: 'CBP', type: 'ct-circle-with-lines' },
					{ name: 'Caja Seccionadora', type: 'ct-box-switch' }
				];
				
				const seccionadores_symbols = [
					{ name: 'Seccionador', type: 'seccionador' },
					{ name: 'Secc. Autodesc.', type: 'secc-autodesc' },
					{ name: 'Secc. Autodesc. B/C Unipolar', type: 'secc-autodesc-b-c' },
					{ name: 'MD Barra CT', type: 'md-barra-ct' }
				];

				const otros_symbols = [
					{ name: 'Seccionalizador', type: 'seccionalizador' },
					{ name: 'Seccionalizador Unipolar', type: 'seccionalizador-unipolar' },
					{ name: 'Reconectador', type: 'reconectador' }
				];

				const buildSymbolOptions = (symbols) => symbols.map(symbol => {
					const isActive = (d.symbolType || 'ct-default') === symbol.type;
					return `<div class="symbol-option flex items-center gap-3 ${isActive ? 'active' : ''}" onclick="window.app.changeCustomElementSymbol('${d.id}', '${symbol.type}')">
								<svg width="30" height="30" viewBox="-15 -15 30 30">${getSymbolSVGString(symbol.type, d)}</svg>
								<span class="text-sm">${symbol.name}</span>
							</div>`;
				}).join('');

				let distributionButtonHTML = '';
				if (d.numConnections > 1) {
					const modeText = d.distributionMode === 'manual' ? 'Automática' : 'Manual';
					const buttonClass = d.distributionMode === 'manual' ? 'bg-blue-500' : 'bg-gray-400';
					 distributionButtonHTML = `<div class="mt-4"><button onclick="window.app.toggleDistributionMode('${d.id}')" class="w-full px-3 py-2 text-sm rounded ${buttonClass} text-white">Distribución ${modeText}</button></div>`;
				}
				
				let connectionsHTML = '';
				if (d.numConnections > 0) {
					connectionsHTML = '<h4 class="text-md font-semibold text-gray-700 mb-2 mt-4">Conexiones</h4><div class="space-y-2">';
					for (let i = 0; i < d.numConnections; i++) {
						const conn = d.connections[i] || { state: 'closed', symbolType: 'seccionador' };
						const state = conn.state === 'open' ? 'Abierta' : 'Cerrada';
						const buttonClass = conn.state === 'open' ? 'bg-gray-400' : 'bg-green-500';
						
						const symbolOptions = seccionadores_symbols.map(s =>
							`<option value="${s.type}" ${conn.symbolType === s.type ? 'selected' : ''}>${s.name}</option>`
						).join('');

						connectionsHTML += `
						<div class="p-2 border rounded-md mb-2 bg-gray-50">
							<div class="flex justify-between items-center mb-2">
								<span class="text-sm font-semibold text-gray-700">${conn.name || `Salida ${i + 1}`}</span>
								<button onclick="window.app.editConnectionName('${d.id}', ${i})" class="p-1 text-xs text-blue-600 hover:bg-blue-100 rounded">Editar Nombre</button>
							</div>
							<div class="flex justify-between items-center">
								<span class="text-sm text-gray-600">Estado: ${state}</span>
								<button onclick="window.app.toggleCustomConnectionState('${d.id}', ${i})" class="px-3 py-1 text-xs rounded ${buttonClass} text-white">${state === 'Abierta' ? 'Cerrar' : 'Abrir'}</button>
							</div>
							<div class="mt-2">
								<label class="text-xs text-gray-500">Símbolo:</label>
								<select onchange="window.app.changeConnectionSymbol('${d.id}', ${i}, this.value)" class="w-full p-1 border border-gray-300 rounded-md text-xs">
									${symbolOptions}
								</select>
							</div>
						</div>`;
					}
					connectionsHTML += '</div>';
				} else {
					const state = d.state === 'open' ? 'Abierto' : 'Cerrado';
					const buttonClass = d.state === 'open' ? 'bg-gray-400' : 'bg-green-500';
					connectionsHTML = `<div class="mt-4"><div class="flex justify-between items-center">
											<span class="text-sm text-gray-600">Estado: ${state}</span>
											<button onclick="window.app.toggleCustomElementState('${d.id}')" class="px-3 py-1 text-sm rounded ${buttonClass} text-white">Cambiar</button>
										</div></div>`;
				}
				
				let colorOptionsHTML = '<h4 class="text-md font-semibold text-gray-700 mb-2 mt-4">Color</h4><div class="flex gap-2">';
				selectionColors.forEach(color => {
					const isActive = (d.color || 'green') === color.name;
					const borderClass = isActive ? 'ring-2 ring-offset-2 ring-gray-800' : 'ring-1 ring-gray-300';
					colorOptionsHTML += `<div onclick="window.app.changeCustomElementColor('${d.id}', '${color.name}')" class="w-6 h-6 rounded-full cursor-pointer ${borderClass}" style="background-color: ${color.hex};"></div>`;
				});
				colorOptionsHTML += '</div>';


				content.innerHTML = `
					<h3 class="text-lg font-bold text-gray-800 mb-2">${d.name}</h3>
					<div class="flex items-center gap-2">
						<label for="num-outputs-input" class="text-sm text-gray-600">Salidas:</label>
						<input type="number" id="num-outputs-input" value="${d.numConnections}" class="w-16 p-1 border border-gray-300 rounded-md text-sm">
						<button onclick="window.app.updateCustomElementOutputs('${d.id}')" class="px-3 py-1 text-sm rounded bg-blue-500 text-white">Actualizar</button>
					</div>
					${distributionButtonHTML}
					${connectionsHTML}
					${colorOptionsHTML}
					${textOptionsHTML}
					<details class="mt-4 border-t pt-2">
						<summary class="font-semibold text-md text-gray-700">Símbolos CT</summary>
						<div class="space-y-2 mt-2">${buildSymbolOptions(ct_symbols)}</div>
					</details>
					<details class="mt-2 border-t pt-2">
						<summary class="font-semibold text-md text-gray-700">Seccionadores</summary>
						<div class="space-y-2 mt-2">${buildSymbolOptions(seccionadores_symbols)}</div>
					</details>
					<details class="mt-2 border-t pt-2">
						<summary class="font-semibold text-md text-gray-700">Otros</summary>
						<div class="space-y-2 mt-2">${buildSymbolOptions(otros_symbols)}</div>
					</details>
				`;
			} else if (selectedAnnotation) {
				panel.classList.remove('translate-x-full');
				const d = selectedAnnotation;
				let html = `<h3 class="text-lg font-bold text-gray-800 mb-4">Forma Dibujada</h3>`;
				html += `<p class="text-sm text-gray-600 mb-4">Tipo: ${d.type}</p>`;
				
				html += '<h4 class="text-md font-semibold text-gray-700 mb-2 mt-4">Color</h4><div class="flex gap-2">';
				selectionColors.forEach(color => {
					const isActive = (d.color) === color.hex;
					const borderClass = isActive ? 'ring-2 ring-offset-2 ring-gray-800' : 'ring-1 ring-gray-300';
					html += `<div onclick="window.app.changeAnnotationColor('${d.id}', '${color.hex}')" class="w-6 h-6 rounded-full cursor-pointer ${borderClass}" style="background-color: ${color.hex};"></div>`;
				});
				html += '</div>';
				content.innerHTML = html;

			} else if (selectedEdge) {
				panel.classList.remove('translate-x-full');
				const d = selectedEdge;
				const sourceNode = currentGraphData.nodes.find(n => n.id === d.source);
				const targetNode = currentGraphData.nodes.find(n => n.id === d.target);
				let html = `<h3 class="text-lg font-bold text-gray-800 mb-4">Cable</h3>`;
				if (sourceNode) html += `<p class="text-sm text-gray-600">De: ${sourceNode.displayName || sourceNode.baseName}</p>`;
				if (targetNode) html += `<p class="text-sm text-gray-600 mb-4">A: ${targetNode.displayName || targetNode.baseName}</p>`;

				html += '<h4 class="text-md font-semibold text-gray-700 mb-2 mt-4">Color</h4><div class="flex gap-2">';
				selectionColors.forEach(color => {
					const isActive = (d.color || '#10b981') === color.hex;
					const borderClass = isActive ? 'ring-2 ring-offset-2 ring-gray-800' : 'ring-1 ring-gray-300';
					html += `<div onclick="window.app.changeEdgeColor('${d.source}', '${d.target}', '${color.hex}')" class="w-6 h-6 rounded-full cursor-pointer ${borderClass}" style="background-color: ${color.hex};"></div>`;
				});
				html += '</div>';
				content.innerHTML = html;
			} else {
				hideInfoPanel();
			}
		}

		function changeAnnotationColor(id, color) {
			const annotation = currentGraphData.annotations.find(a => a.id === id);
			if (annotation) {
				annotation.color = color;
				saveState();
				drawAnnotations();
				updateInfoPanel();
			}
		}

		function changeEdgeColor(sourceId, targetId, color) {
			const edge = currentGraphData.edges.find(e => 
				(e.source.toString() === sourceId && e.target.toString() === targetId) ||
				(e.source.toString() === targetId && e.target.toString() === sourceId)
			);
			if (edge) {
				edge.color = color;
				saveState();
				const nodeMap = new Map(currentGraphData.nodes.map(d => [d.id, d]));
				redrawAllLinks(nodeMap);
				
				setTimeout(() => {
					selectedEdge = edge;
					d3.selectAll('.link-visual').classed('selected', e => e === edge);
					updateInfoPanel();
				}, 0);
			}
		}

		function toggleConnectionState(sourceId, targetId) {
			const nodeData = currentGraphData.nodes.find(n => n.id === sourceId);
			if (nodeData) {
				if (!nodeData.connections) nodeData.connections = [];
				let conn = nodeData.connections.find(c => c.targetId === targetId);
				if (conn) {
					conn.state = conn.state === 'closed' ? 'open' : 'closed';
				} else {
					nodeData.connections.push({ targetId: targetId, state: 'open' });
				}
				saveState();
				drawGraph(currentGraphData);
				updateInfoPanel();
			}
		}

		function toggleNodeState(nodeId) {
			const nodeData = currentGraphData.nodes.find(n => n.id === nodeId);
			if (nodeData) {
				nodeData.state = nodeData.state === 'closed' ? 'open' : 'closed';
				saveState();
				drawGraph(currentGraphData);
				
				// Re-select the node from the new hierarchy to avoid stale references
				if (rootNode) {
					selectedNode = rootNode.descendants().find(n => n.id === nodeId);
					if (selectedNode) {
						 d3.selectAll('.node').filter(d => d.id === nodeId).classed('selected', true);
					}
				}
				updateInfoPanel();
			}
		}

		function changeCustomElementSymbol(elementId, symbolType) {
			const element = currentGraphData.customElements.find(el => el.id === elementId);
			if (element) {
				element.symbolType = symbolType;
				saveState();
				drawCustomElements();
				updateInfoPanel();
			}
		}
		
		function changeConnectionSymbol(elementId, connIndex, symbolType) {
			const element = currentGraphData.customElements.find(el => el.id === elementId);
			if (element && element.connections[connIndex]) {
				element.connections[connIndex].symbolType = symbolType;
				saveState();
				drawCustomElements();
			}
		}

		function changeCustomElementColor(elementId, colorName) {
			const element = currentGraphData.customElements.find(el => el.id === elementId);
			if (element) {
				element.color = colorName;
				saveState();
				drawCustomElements();
				updateInfoPanel();
			}
		}

		function changeNodeSymbol(nodeId, symbolType) {
			const node = currentGraphData.nodes.find(n => n.id === nodeId);
			if (node) {
				node.symbolType = symbolType;
				saveState();
				drawGraph(currentGraphData);
				updateInfoPanel();
			}
		}
		
		function changeElementTextProperty(elementId, type, property, value) {
			let element;
			if (type === 'node') {
				element = currentGraphData.nodes.find(n => n.id === elementId);
			} else {
				element = currentGraphData.customElements.find(el => el.id === elementId);
			}

			if (element) {
				if (property === 'fontSize') {
					const size = parseInt(value, 10);
					if (!isNaN(size) && size > 0) {
						element[property] = size;
					} else {
						updateInfoPanel();
						return;
					}
				} else {
					element[property] = value;
				}

				saveState();

				if (type === 'node') {
					drawGraph(currentGraphData);
				} else {
					drawCustomElements();
				}
				
				if (type === 'node') {
					selectedNode = rootNode.descendants().find(n => n.id === elementId);
					d3.selectAll('.node').filter(d => d.id === elementId).classed('selected', true);
				} else {
					selectedCustomElement = currentGraphData.customElements.find(el => el.id === elementId);
					d3.selectAll('.custom-element-group').filter(d => d.id === elementId).classed('selected', true);
				}
				updateInfoPanel();
			}
		}

		function getSymbolSVG(symbolType, group, d, overrideRadius = null) {
			const theme = colorThemes[d.color] || colorThemes.green;
			let symbolRadius;

			if (overrideRadius) {
				symbolRadius = overrideRadius;
			} else {
				let baseRadius = 15;
				const isCT = (d && isBNode({data:d})) || ['star', 'ct-default', 'ct-circle-in-square', 'ct-circle-with-lines', 'ct-box-switch'].includes(symbolType);
				const seccionadorTypes = ['seccionador', 'UNI MT Seccionador', 'UNI MT Secc. Bajo Carga', 'secc-autodesc', 'UNI MT Secc. Autodesconectador', 'secc-autodesc-b-c', 'md-barra-ct'];
				const isSeccionador = seccionadorTypes.includes(symbolType);

				if (isCT) {
					baseRadius *= 1.3;
				} else if (isSeccionador) {
					baseRadius *= 0.8;
				}
				symbolRadius = baseRadius;
			}
			
			const innerRadius = symbolRadius * 0.8;
			const isClosedState = d ? d.state === 'closed' : true;
			const openColor = '#fff';
			const closedColor = isClosedState ? theme.closed : openColor;
			const innerSymbolGray = '#d4d4d8';
			const blackColor = '#1f2937';
			const symbolStrokeColor = theme.stroke;
			const r = symbolRadius;

			switch (symbolType) {
				case 'star':
					group.append('path').attr('class', 'symbol star')
						.attr('d', 'M0,-15 L4.408,-6.067 L14.266,-4.635 L7.132,2.317 L9.27,12.135 L0,7.5 L-9.27,12.135 L-7.132,2.317 L-14.266,-4.635 L-4.408,-6.067 Z')
						.style('stroke', theme.main === colorThemes.blue.main ? colorThemes.blue.main : '#0ea5e9');
					break;
				case 'ct-circle-in-square':
					group.append('rect').attr('class', 'symbol').attr('x', -r).attr('y', -r).attr('width', r * 2).attr('height', r * 2).attr('fill', innerSymbolGray).style('stroke', symbolStrokeColor);
					group.append('circle').attr('class', 'symbol').attr('r', innerRadius).attr('fill', innerSymbolGray).style('stroke', symbolStrokeColor);
					break;
				case 'ct-circle-with-lines':
					group.append('rect').attr('class', 'symbol').attr('x', -r).attr('y', -r).attr('width', r * 2).attr('height', r * 2).attr('fill', innerSymbolGray).style('stroke', symbolStrokeColor);
					group.append('circle').attr('class', 'symbol').attr('r', innerRadius).attr('fill', innerSymbolGray).style('stroke', symbolStrokeColor);
					const lineOffset = innerRadius * 0.4;
					const lineLength = innerRadius * 0.8;
					group.append('line').attr('x1', -lineLength).attr('y1', -lineOffset).attr('x2', lineLength).attr('y2', -lineOffset).style('stroke', theme.main).style('stroke-width', 1.5);
					group.append('line').attr('x1', -lineLength).attr('y1', lineOffset).attr('x2', lineLength).attr('y2', lineOffset).style('stroke', theme.main).style('stroke-width', 1.5);
					break;
				case 'ct-box-switch':
					group.append('rect').attr('class', 'symbol').attr('x', -r).attr('y', -r).attr('width', r * 2).attr('height', r * 2).attr('fill', innerSymbolGray).style('stroke', symbolStrokeColor);
					group.append('path').attr('class', 'symbol').attr('d', `M ${-r},0 L ${-r * 0.4},0`).attr('fill', 'none').style('stroke', symbolStrokeColor);
					group.append('path').attr('class', 'symbol').attr('d', `M 0,${-r * 0.8} L ${r * 0.4},0 L ${r},0`).attr('fill', 'none').style('stroke', symbolStrokeColor);
					break;
				case 'seccionador':
				case 'UNI MT Seccionador':
				case 'UNI MT Secc. Bajo Carga':
					group.append('path').attr('class', 'symbol').attr('d', `M 0,-${r} L ${r},0 L 0,${r} L -${r},0 Z`).attr('fill', closedColor).style('stroke', symbolStrokeColor);
					break;
				case 'secc-autodesc':
				case 'UNI MT Secc. Autodesconectador':
					group.append('path').attr('class', 'symbol').attr('d', `M 0,-${r} L ${r},0 L 0,${r} L -${r},0 Z`).attr('fill', openColor).style('stroke', symbolStrokeColor);
					if (isClosedState) {
						group.append('path').attr('d', `M 0,-${r} L -${r},0 L 0,${r} Z`).attr('fill', theme.closed).style('stroke', 'none');
						group.append('text').attr('x', r / 2.5).attr('text-anchor', 'middle').attr('dominant-baseline', 'central').attr('font-size', '8px').attr('font-weight', 'bold').attr('fill', blackColor).text('K');
					}
					break;
				case 'secc-autodesc-b-c':
				case 'Secc. Autodesc. B/C Unipolar':
					group.append('circle').attr('class', 'symbol').attr('r', r).attr('fill', closedColor).style('stroke', symbolStrokeColor);
					group.append('path').attr('class', 'symbol').attr('d', `M 0,-${r} L ${r},0 L 0,${r} L -${r},0 Z`).attr('fill', '#fff').style('stroke', symbolStrokeColor);
					break;
				case 'md-barra-ct':
				case 'MD Barra CT':
					group.append('rect').attr('class', 'symbol').attr('x', -r).attr('y', -r).attr('width', r * 2).attr('height', r * 2).attr('fill', closedColor).style('stroke', symbolStrokeColor);
					group.append('path').attr('class', 'symbol').attr('d', `M 0,-${r/2} L ${r/2},${r/2} L -${r/2},${r/2} Z`).attr('fill', '#fff').style('stroke', symbolStrokeColor);
					break;
				case 'seccionalizador':
				case 'UNI MT Seccionalizador':
					group.append('path').attr('class', 'symbol').attr('d', `M 0,-${r} L ${r},${r} L -${r},${r} Z`).attr('fill', closedColor).style('stroke', symbolStrokeColor);
					group.append('line').attr('class', 'symbol').attr('x1', -r).attr('y1', -r - (r*0.5)).attr('x2', r).attr('y2', -r - (r*0.5)).style('stroke', theme.main).style('stroke-width', 1.5);
					break;
				case 'seccionalizador-unipolar':
				case 'Seccionalizador Unipolar':
					group.append('circle').attr('class', 'symbol').attr('r', r).attr('fill', closedColor).style('stroke', symbolStrokeColor);
					const tS = 0.6;
					group.append('path').attr('class', 'symbol').attr('d', `M 0,-${r * tS} L ${r * tS},${r * tS} L -${r * tS},${r * tS} Z`).attr('fill', '#fff').style('stroke', symbolStrokeColor);
					const bO = 0.1;
					group.append('line').attr('class', 'symbol').attr('x1', -r * tS).attr('y1', -r * tS - (r * bO)).attr('x2', r * tS).attr('y2', -r * tS - (r * bO)).style('stroke', theme.main).style('stroke-width', 1.5);
					break;
				case 'reconectador':
				case 'UNI MT Reconectador':
					const r_rec = r * 1.5;
					const tBW = r_rec * 1.2;
					const tH = r_rec * 0.7;
					group.append('circle').attr('class', 'symbol').attr('r', r_rec).attr('fill', closedColor).style('stroke', theme.main).style('stroke-width', 1.5);
					group.append('path').attr('class', 'symbol').attr('d', `M ${-tBW / 2},-${tH} L ${tBW / 2},-${tH} L 0,0 Z`).attr('fill', '#fff').style('stroke', symbolStrokeColor);
					group.append('path').attr('class', 'symbol').attr('d', `M ${-tBW / 2},${tH} L ${tBW / 2},${tH} L 0,0 Z`).attr('fill', '#fff').style('stroke', symbolStrokeColor);
					break;
				case 'ct-default':
				default:
					group.append('rect').attr('class', 'symbol').attr('x', -r).attr('y', -r).attr('width', r * 2).attr('height', r * 2).attr('fill', innerSymbolGray).style('stroke', symbolStrokeColor);
					const s_2 = innerRadius;
					const triangleHeight = (innerRadius * 2 * Math.sqrt(3)) / 2;
					group.append('path').attr('class', 'symbol').attr('d', `M ${-s_2},${s_2} L ${s_2},${s_2} L 0,${s_2 - triangleHeight} Z`).attr('fill', innerSymbolGray).style('stroke', symbolStrokeColor);
					break;
			}
		}

		function getSymbolSVGString(symbolType, d, overrideRadius = null) {
			const theme = colorThemes[d.color] || colorThemes.green;
			let symbolRadius;

			if (overrideRadius) {
				symbolRadius = overrideRadius;
			} else {
				let baseRadius = 15;
				const isCT = ['star', 'ct-default', 'ct-circle-in-square', 'ct-circle-with-lines', 'ct-box-switch'].includes(symbolType);
				const isSeccionador = ['seccionador', 'secc-autodesc', 'secc-autodesc-b-c', 'md-barra-ct', 'UNI MT Seccionador', 'UNI MT Secc. Bajo Carga'].includes(symbolType);
				if (isCT) {
					baseRadius *= 1.3;
				} else if (isSeccionador) {
					baseRadius *= 0.8;
				}
				symbolRadius = baseRadius;
			}

			const innerRadius = symbolRadius * 0.8;
			const isClosedState = d ? d.state === 'closed' : true;
			const openColor = '#fff';
			const closedColor = isClosedState ? theme.closed : openColor;
			const innerSymbolGray = '#d4d4d8';
			const blackColor = '#1f2937';
			const symbolStrokeColor = theme.stroke;
			const r = symbolRadius;

			switch (symbolType) {
				case 'star':
					const starStroke = theme.main === colorThemes.blue.main ? colorThemes.blue.main : '#0ea5e9';
					return `<path class="symbol star" d="M0,-15 L4.408,-6.067 L14.266,-4.635 L7.132,2.317 L9.27,12.135 L0,7.5 L-9.27,12.135 L-7.132,2.317 L-14.266,-4.635 L-4.408,-6.067 Z" stroke="${starStroke}" fill="#e0f2fe" stroke-width="1.5"></path>`;
				case 'ct-circle-in-square':
					return `<rect class="symbol" x="${-r}" y="${-r}" width="${r*2}" height="${r*2}" fill="${innerSymbolGray}" stroke="${symbolStrokeColor}" stroke-width="1.5"></rect><circle class="symbol" r="${innerRadius}" fill="${innerSymbolGray}" stroke="${symbolStrokeColor}" stroke-width="1.5"></circle>`;
				case 'ct-circle-with-lines':
					const lineOffset = innerRadius * 0.4;
					const lineLength = innerRadius * 0.8;
					return `<rect class="symbol" x="${-r}" y="${-r}" width="${r*2}" height="${r*2}" fill="${innerSymbolGray}" stroke="${symbolStrokeColor}" stroke-width="1.5"></rect><circle class="symbol" r="${innerRadius}" fill="${innerSymbolGray}" stroke="${symbolStrokeColor}" stroke-width="1.5"></circle><line x1="${-lineLength}" y1="${-lineOffset}" x2="${lineLength}" y2="${-lineOffset}" style="stroke:${theme.main};stroke-width:1.5"></line><line x1="${-lineLength}" y1="${lineOffset}" x2="${lineLength}" y2="${lineOffset}" style="stroke:${theme.main};stroke-width:1.5"></line>`;
				case 'ct-box-switch':
					return `<rect class="symbol" x="${-r}" y="${-r}" width="${r*2}" height="${r*2}" fill="${innerSymbolGray}" stroke="${symbolStrokeColor}" stroke-width="1.5"></rect><path class="symbol" d="M ${-r},0 L ${-r*0.4},0" fill="none" stroke="${symbolStrokeColor}" stroke-width="1.5"></path><path class="symbol" d="M 0,${-r*0.8} L ${r*0.4},0 L ${r},0" fill="none" stroke="${symbolStrokeColor}" stroke-width="1.5"></path>`;
				case 'seccionador':
				case 'UNI MT Seccionador':
				case 'UNI MT Secc. Bajo Carga':
					return `<path class="symbol" d="M 0,-${r} L ${r},0 L 0,${r} L -${r},0 Z" fill="${closedColor}" stroke="${symbolStrokeColor}" stroke-width="1.5"></path>`;
				case 'secc-autodesc':
					let k_text = isClosedState ? `<text x="${r / 2.5}" text-anchor="middle" dominant-baseline="central" font-size="8px" font-weight="bold" fill="${blackColor}">K</text>` : '';
					let half_fill = isClosedState ? `<path d="M 0,-${r} L -${r},0 L 0,${r} Z" fill="${theme.closed}" style="stroke:none"></path>` : '';
					return `<path class="symbol" d="M 0,-${r} L ${r},0 L 0,${r} L -${r},0 Z" fill="${openColor}" stroke="${symbolStrokeColor}" stroke-width="1.5"></path>${half_fill}${k_text}`;
				case 'secc-autodesc-b-c':
					return `<circle class="symbol" r="${r}" fill="${closedColor}" stroke="${symbolStrokeColor}" stroke-width="1.5"></circle><path class="symbol" d="M 0,-${r} L ${r},0 L 0,${r} L -${r},0 Z" fill="#fff" stroke="${symbolStrokeColor}" stroke-width="1.5"></path>`;
				case 'md-barra-ct':
					return `<rect class="symbol" x="${-r}" y="${-r}" width="${r*2}" height="${r*2}" fill="${closedColor}" stroke="${symbolStrokeColor}" stroke-width="1.5"></rect><path class="symbol" d="M 0,-${r/2} L ${r/2},${r/2} L -${r/2},${r/2} Z" fill="#fff" stroke="${symbolStrokeColor}" stroke-width="1.5"></path>`;
				case 'seccionalizador':
					return `<path class="symbol" d="M 0,-${r} L ${r},${r} L -${r},${r} Z" fill="${closedColor}" stroke="${symbolStrokeColor}" stroke-width="1.5"></path><line class="symbol" x1="${-r}" y1="${-r - (r*0.5)}" x2="${r}" y2="${-r - (r*0.5)}" stroke="${theme.main}" stroke-width="1.5"></line>`;
				case 'seccionalizador-unipolar':
					const tS = 0.6; const bO = 0.1;
					return `<circle class="symbol" r="${r}" fill="${closedColor}" stroke="${symbolStrokeColor}" stroke-width="1.5"></circle><path class="symbol" d="M 0,-${r * tS} L ${r * tS},${r * tS} L -${r * tS},${r * tS} Z" fill="#fff" stroke="${symbolStrokeColor}" stroke-width="1.5"></path><line class="symbol" x1="${-r * tS}" y1="${-r * tS - (r * bO)}" x2="${r * tS}" y2="${-r * tS - (r * bO)}" stroke="${theme.main}" stroke-width="1.5"></line>`;
				case 'reconectador':
					const r_rec = r * 1.5; const tBW = r_rec * 1.2; const tH = r_rec * 0.7;
					return `<circle class="symbol" r="${r_rec}" fill="${closedColor}" stroke="${theme.main}" stroke-width="1.5"></circle><path class="symbol" d="M ${-tBW / 2},-${tH} L ${tBW / 2},-${tH} L 0,0 Z" fill="#fff" stroke="${symbolStrokeColor}" stroke-width="1.5"></path><path class="symbol" d="M ${-tBW / 2},${tH} L ${tBW / 2},${tH} L 0,0 Z" fill="#fff" stroke="${symbolStrokeColor}" stroke-width="1.5"></path>`;
				case 'ct-default':
				default:
					const s_2_str = innerRadius;
					const triangleHeight_str = (innerRadius * 2 * Math.sqrt(3)) / 2;
					return `<rect class="symbol" x="${-r}" y="${-r}" width="${r*2}" height="${r*2}" fill="${innerSymbolGray}" stroke="${symbolStrokeColor}" stroke-width="1.5"></rect><path class="symbol" d="M ${-s_2_str},${s_2_str} L ${s_2_str},${s_2_str} L 0,${s_2_str - triangleHeight_str} Z" fill="${innerSymbolGray}" stroke="${symbolStrokeColor}" stroke-width="1.5"></path>`;
			}
		}

		function toggleDistributionMode(elementId) {
			const element = currentGraphData.customElements.find(el => el.id === elementId);
			if (element) {
				element.distributionMode = element.distributionMode === 'manual' ? 'auto' : 'manual';
				if (element.distributionMode === 'auto') {
					element.connections.forEach(c => delete c.angle);
				}
				saveState();
				drawCustomElements();
				updateInfoPanel();
			}
		}
		
		function updateCustomElementOutputs(elementId) {
			const input = document.getElementById('num-outputs-input');
			const newCount = parseInt(input.value, 10);
			if (isNaN(newCount) || newCount < 0 || newCount > 8) {
				showMessageBox("Por favor, ingrese un número válido entre 0 y 8.");
				return;
			}
			const element = currentGraphData.customElements.find(el => el.id === elementId);
			if (element) {
				const currentConnections = element.connections || [];
				element.numConnections = newCount;
				element.connections = Array.from({ length: newCount }, (_, i) => {
					return currentConnections[i] || {
						id: i,
						name: `Salida ${i + 1}`,
						state: 'closed',
						symbolType: 'seccionador'
					};
				});
				element.connections.length = newCount;

				if (newCount === 1) {
					updateCustomElementConnections(element);
				}
				saveState();
				drawCustomElements();
				updateInfoPanel();
			}
		}

		function toggleCustomElementState(elementId) {
			const element = currentGraphData.customElements.find(el => el.id === elementId);
			if (element) {
				element.state = element.state === 'open' ? 'closed' : 'open';
				saveState();
				drawCustomElements();
				updateInfoPanel();
			}
		}

		function toggleCustomConnectionState(elementId, connIndex) {
			const element = currentGraphData.customElements.find(el => el.id === elementId);
			if (element && element.connections[connIndex]) {
				const currentState = element.connections[connIndex].state || 'closed';
				element.connections[connIndex].state = currentState === 'closed' ? 'open' : 'closed';
				saveState();
				drawCustomElements();
				updateInfoPanel();
			}
		}
		
		async function generateDiagramCanvas() {
			return new Promise((resolve, reject) => {
				try {
					const svgElement = document.getElementById('graph-svg');
					if (!svgElement || !svgElement.children.length) {
						return reject("No hay diagrama para procesar.");
					}

					const g = svgElement.querySelector('g.graph-content');
					if (!g) {
						return reject("No se encontró contenido en el diagrama.");
					}
					const bbox = g.getBBox();

					const padding = 20;
					let scale = 2;	
					const MAX_DIMENSION = 16000;

					let canvasWidth = (bbox.width + padding * 2) * scale;
					let canvasHeight = (bbox.height + padding * 2) * scale;

					if (canvasWidth > MAX_DIMENSION || canvasHeight > MAX_DIMENSION) {
						const max_bbox_dim = Math.max(bbox.width, bbox.height);
						scale = MAX_DIMENSION / (max_bbox_dim + padding * 2);
						canvasWidth = (bbox.width + padding * 2) * scale;
						canvasHeight = (bbox.height + padding * 2) * scale;
						showMessageBox("El diagrama es muy grande. La imagen se ha generado a una resolución menor para evitar errores.");
					}

					const canvas = document.createElement('canvas');
					canvas.width = canvasWidth;
					canvas.height = canvasHeight;
					const ctx = canvas.getContext('2d');
					
					const styles = Array.from(document.styleSheets)
						.map(sheet => {
							try {
								return Array.from(sheet.cssRules).map(rule => rule.cssText).join('\n');
							} catch (e) {
								console.warn("No se pudo acceder a las reglas de la hoja de estilo:", e);
								return '';
							}
						}).join('\n');

					const g_clone = g.cloneNode(true);
					d3.select(g_clone).attr('transform', `translate(${-bbox.x + padding}, ${-bbox.y + padding})`);
					
					const svgString = `
						<svg width="${(bbox.width + padding * 2)}" height="${(bbox.height + padding * 2)}" xmlns="http://www.w3.org/2000/svg">
							<style>
								${styles}
							</style>
							<rect x="0" y="0" width="100%" height="100%" fill="white"></rect>
							${g_clone.outerHTML}
						</svg>`;

					const img = new Image();
					const blob = new Blob([svgString], { type: 'image/svg+xml;charset=utf-8' });
					const url = URL.createObjectURL(blob);

					img.onload = () => {
						ctx.scale(scale, scale);
						ctx.drawImage(img, 0, 0);
						URL.revokeObjectURL(url);
						resolve(canvas);
					};

					img.onerror = (e) => {
						URL.revokeObjectURL(url);
						reject("Error al generar la imagen a partir del diagrama.");
					};

					img.src = url;
				} catch (error) {
					reject(`Ocurrió un error inesperado: ${error.message}`);
				}
			});
		}

		async function copyDiagramAsImage() {
			try {
				const canvas = await generateDiagramCanvas();
				const dataUrl = canvas.toDataURL('image/png');
				
				const modal = document.getElementById('copy-image-modal');
				const imageElement = document.getElementById('image-to-copy');
				
				imageElement.src = dataUrl;
				modal.classList.remove('hidden');
				modal.classList.add('flex');

			} catch (error) {
				console.error('Error al preparar la imagen para copiar:', error);
				showMessageBox(error.toString());
			}
		}

		async function downloadDiagramAsImage() {
			try {
				const canvas = await generateDiagramCanvas();
				const link = document.createElement('a');
				link.download = 'diagrama_de_red.png';
				link.href = canvas.toDataURL('image/png');
				link.click();
				showMessageBox("La descarga del diagrama ha comenzado.");
			} catch (error) {
				console.error('Error al descargar el diagrama:', error);
				showMessageBox(error.toString());
			}
		}


		function initializeBlankCanvas() {
			const svg = d3.select("#graph-svg");
			svg.selectAll("*").remove();
			const container = document.getElementById('visualization-container');

			const width = container.clientWidth;
			const height = container.clientHeight;
			svg.attr("width", width).attr("height", height);

			const defs = svg.append('defs');
			defs.append('pattern')
				.attr('id', 'grid')
				.attr('width', 20)
				.attr('height', 20)
				.attr('patternUnits', 'userSpaceOnUse')
				.append('path')
				.attr('d', 'M 20 0 L 0 0 0 20')
				.attr('fill', 'none')
				.attr('stroke', '#e5e7eb')
				.attr('stroke-width', '0.5');
			
			const drawingArea = svg.append('rect').attr('id', 'drawing-area').attr('width', '100%').attr('height', '100%').attr('fill', 'url(#grid)');

			svg.append("g").attr("class", "graph-content");
			
			initializeZoom();

			originalGraphData = null;
			currentGraphData = { nodes: [], edges: [], annotations: [], customElements: [], rootId: null };
			history = [];
			historyIndex = -1;
			rootNode = null;
			document.getElementById('search-input').value = '';
			document.getElementById('search-suggestions').innerHTML = '';
			saveState();
			updateUndoRedoButtons();
			updateClearDrawingsButtonState();
			updateSavedSketchesDropdown();
		}
		
		// --- NEW: Lasso & Marquee Select and Filtering Logic ---
		function isPointInPolygon(point, polygon) {
			const [x, y] = point;
			let isInside = false;
			for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
				const [xi, yi] = polygon[i];
				const [xj, yj] = polygon[j];
				const intersect = ((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
				if (intersect) isInside = !isInside;
			}
			return isInside;
		}

		function initializeLassoSelect() {
			const svg = d3.select("#graph-svg");
			const g = svg.select("g.graph-content");
			let lassoPath;
			let lassoPoints;

			const drag = d3.drag()
				.on('start', (event) => {
					lassoPoints = [d3.pointer(event, g.node())];
					multiSelectedNodes.clear();
					d3.selectAll('.node.multi-selected').classed('multi-selected', false);
					
					lassoPath = g.append('path')
						.attr('class', 'lasso-path')
						.attr('d', `M${lassoPoints[0][0]},${lassoPoints[0][1]}`);
				})
				.on('drag', (event) => {
					lassoPoints.push(d3.pointer(event, g.node()));
					lassoPath.attr('d', `M${lassoPoints.map(p => p.join(',')).join('L')}`);
				})
				.on('end', () => {
					lassoPath.remove();
					
					d3.selectAll('.node').each(function(d) {
						const nodeElement = d3.select(this);
						const nodeX = d.customX ?? d.scaledX;
						const nodeY = d.customY ?? d.scaledY;
						if (isPointInPolygon([nodeX, nodeY], lassoPoints)) {
							multiSelectedNodes.add(d.id);
							nodeElement.classed('multi-selected', true);
						}
					});
					document.getElementById('filter-selection-btn').disabled = multiSelectedNodes.size < 2;
				});
			
			svg.call(drag);
		}

		function initializeMarqueeSelect() {
			const svg = d3.select("#graph-svg");
			const g = svg.select("g.graph-content");
			let marquee;
			let startPos;

			const drag = d3.drag()
				.on('start', (event) => {
					startPos = d3.pointer(event, g.node());
					multiSelectedNodes.clear();
					d3.selectAll('.node.multi-selected').classed('multi-selected', false);
					
					marquee = g.append('rect')
						.attr('class', 'selection-marquee')
						.attr('x', startPos[0])
						.attr('y', startPos[1])
						.attr('width', 0)
						.attr('height', 0);
				})
				.on('drag', (event) => {
					const currentPos = d3.pointer(event, g.node());
					const x = Math.min(startPos[0], currentPos[0]);
					const y = Math.min(startPos[1], currentPos[1]);
					const width = Math.abs(startPos[0] - currentPos[0]);
					const height = Math.abs(startPos[1] - currentPos[1]);

					marquee.attr('x', x).attr('y', y).attr('width', width).attr('height', height);

					d3.selectAll('.node').each(function(d) {
						const nodeElement = d3.select(this);
						const nodeX = d.customX ?? d.scaledX;
						const nodeY = d.customY ?? d.scaledY;
						if (nodeX >= x && nodeX <= x + width && nodeY >= y && nodeY <= y + height) {
							multiSelectedNodes.add(d.id);
							nodeElement.classed('multi-selected', true);
						} else {
							multiSelectedNodes.delete(d.id);
							nodeElement.classed('multi-selected', false);
						}
					});
					document.getElementById('filter-selection-btn').disabled = multiSelectedNodes.size < 2;
				})
				.on('end', () => {
					marquee.remove();
				});
			
			svg.call(drag);
		}

		function findShortestPath(startId, endId, nodes, edges) {
			const adj = new Map();
			nodes.forEach(n => adj.set(n.id, []));
			edges.forEach(e => {
				adj.get(e.source).push(e.target);
				adj.get(e.target).push(e.source);
			});

			const queue = [[startId]];
			const visited = new Set([startId]);

			while (queue.length > 0) {
				const path = queue.shift();
				const lastNode = path[path.length - 1];

				if (lastNode === endId) {
					return path;
				}

				for (const neighbor of adj.get(lastNode)) {
					if (!visited.has(neighbor)) {
						visited.add(neighbor);
						const newPath = [...path, neighbor];
						queue.push(newPath);
					}
				}
			}
			return null; // No path found
		}

		function filterGraphToSelection() {
			if (multiSelectedNodes.size < 2 || !originalGraphData) return;

			const selectedIds = Array.from(multiSelectedNodes);
			const subgraphNodeIds = new Set(selectedIds);

			for (let i = 0; i < selectedIds.length; i++) {
				for (let j = i + 1; j < selectedIds.length; j++) {
					const path = findShortestPath(selectedIds[i], selectedIds[j], originalGraphData.nodes, originalGraphData.edges);
					if (path) {
						path.forEach(id => subgraphNodeIds.add(id));
					}
				}
			}

			const filteredNodesRaw = originalGraphData.nodes.filter(n => subgraphNodeIds.has(n.id));
			const filteredEdges = originalGraphData.edges.filter(e => subgraphNodeIds.has(e.source) && subgraphNodeIds.has(e.target));
			
			const filteredNodes = JSON.parse(JSON.stringify(filteredNodesRaw));

			if (filteredNodes.length > 1) {
				const centroid = filteredNodes.reduce((acc, node) => {
					acc.x += node.x;
					acc.y += node.y;
					return acc;
				}, { x: 0, y: 0 });
				centroid.x /= filteredNodes.length;
				centroid.y /= filteredNodes.length;

				filteredNodes.forEach(node => {
					const vecX = node.x - centroid.x;
					const vecY = node.y - centroid.y;
					
					node.x = centroid.x + vecX / 2;
					node.y = centroid.y + vecY / 2;
				});
			}

			const newRootId = filteredNodes.length > 0 ? filteredNodes[0].id : null;

			currentGraphData = {
				...currentGraphData,
				nodes: filteredNodes,
				edges: filteredEdges,
				rootId: newRootId
			};

			parentMap = null;
			drawGraph(currentGraphData);
			
			document.getElementById('filter-selection-btn').classList.add('hidden');
			document.getElementById('reset-view-btn').classList.remove('hidden');
			setCurrentTool('select');
			
			// Disable file uploads while in filtered view
			document.getElementById('file-upload').disabled = true;
			document.querySelector('label[for="file-upload"]').classList.add('opacity-50', 'cursor-not-allowed');
			document.getElementById('upload-sketch-file').disabled = true;
			document.querySelector('label[for="upload-sketch-file"]').classList.add('opacity-50', 'cursor-not-allowed');
		}
		
		function resetGraphView() {
			if (!originalGraphData) return;
			
			currentGraphData = JSON.parse(JSON.stringify(originalGraphData));
			parentMap = null;
			drawGraph(currentGraphData);
			
			document.getElementById('filter-selection-btn').classList.remove('hidden');
			document.getElementById('reset-view-btn').classList.add('hidden');
			document.getElementById('filter-selection-btn').disabled = true;
			
			// Re-enable file uploads
			document.getElementById('file-upload').disabled = false;
			document.querySelector('label[for="file-upload"]').classList.remove('opacity-50', 'cursor-not-allowed');
			document.getElementById('upload-sketch-file').disabled = false;
			document.querySelector('label[for="upload-sketch-file"]').classList.remove('opacity-50', 'cursor-not-allowed');
		}

		function revertToCsv() {
			if (!initialCsvData) {
				showMessageBox("No hay datos de CSV originales para cargar.");
				return;
			}

			originalGraphData = JSON.parse(JSON.stringify(initialCsvData));
			currentGraphData = JSON.parse(JSON.stringify(initialCsvData));
			
			parentMap = null;
			directedAdj = null;

			clearSelections();
			drawGraph(currentGraphData);

			document.getElementById('revert-to-csv-btn').classList.add('hidden');
			document.getElementById('file-name').textContent = initialCsvName;
			showMessageBox("Se han restaurado los datos del archivo CSV original.");
		}

		window.app = {
			changeNodeSymbol,
			toggleNodeState,
			changeCustomElementSymbol,
			toggleCustomElementState,
			toggleDistributionMode,
			updateCustomElementOutputs,
			editConnectionName,
			toggleCustomConnectionState,
			changeConnectionSymbol,
			changeCustomElementColor,
			changeAnnotationColor,
			changeEdgeColor,
			changeElementTextProperty,
			loadSketch,
			downloadSavedSketch,
			deleteSketch
		};
		
		window.onload = function() {
			// --- DOM Element Listeners ---
			document.getElementById('file-upload').addEventListener('change', handleFileSelect);
			document.getElementById('upload-sketch-file').addEventListener('change', handleUploadSketch);
			document.getElementById('download-sketch-btn').addEventListener('click', handleDownloadCurrentSketch);
			document.getElementById('delete-btn').addEventListener('click', handleDelete);
			document.getElementById('undo-btn').addEventListener('click', undo);
			document.getElementById('redo-btn').addEventListener('click', redo);
			document.getElementById('clear-drawings-btn').addEventListener('click', clearDrawings);
			document.getElementById('search-input').addEventListener('input', handleSearch);
			document.getElementById('copy-image-btn').addEventListener('click', copyDiagramAsImage);
			document.getElementById('save-sketch-btn').addEventListener('click', handleSaveSketch);
			document.getElementById('filter-selection-btn').addEventListener('click', filterGraphToSelection);
			document.getElementById('reset-view-btn').addEventListener('click', resetGraphView);
			document.getElementById('revert-to-csv-btn').addEventListener('click', revertToCsv);
			document.getElementById('close-modal-btn').addEventListener('click', () => {
				const modal = document.getElementById('copy-image-modal');
				modal.classList.add('hidden');
				modal.classList.remove('flex');
			});
			document.getElementById('close-info-panel-btn').addEventListener('click', clearSelections);


			// Drawing Tools Listeners
			const setupToolButton = (id, toolName, symbolType = null) => {
				const button = document.getElementById(id);
				button.addEventListener('click', (e) => {
					e.stopPropagation();
					if (toolName === 'custom-element' && symbolType) {
						setCurrentTool(toolName, e.currentTarget, { symbolType });
					} else {
						setCurrentTool(toolName, e.currentTarget);
					}
				});
			};
			setupToolButton('lasso-select-btn', 'lasso-select');
			setupToolButton('marquee-select-btn', 'marquee-select');
			setupToolButton('draw-ct-btn', 'custom-element', 'ct-default');
			setupToolButton('draw-seccionador-btn', 'custom-element', 'seccionador');
			setupToolButton('draw-ellipse-btn', 'ellipse');
			setupToolButton('draw-rect-btn', 'rect');
			setupToolButton('draw-line-btn', 'line');
			setupToolButton('draw-dashed-line-btn', 'dashed-line');
			setupToolButton('draw-text-btn', 'text');
			setupToolButton('draw-ground-btn', 'ground');
			
			document.addEventListener('keydown', (event) => {
				if (event.key === 'Escape') {
					setCurrentTool('select');
				}
			});

			// Dropdown Menus Logic
			const savedSketchesMenuButton = document.getElementById('saved-sketches-menu-button');
			const savedSketchesMenu = document.getElementById('saved-sketches-menu');

			savedSketchesMenuButton.addEventListener('click', (event) => {
				event.stopPropagation();
				savedSketchesMenu.classList.toggle('hidden');
			});

			window.addEventListener('click', (event) => {
				if (!savedSketchesMenuButton.contains(event.target) && !savedSketchesMenu.contains(event.target)) {
					savedSketchesMenu.classList.add('hidden');
				}
			});
			
			initializeBlankCanvas();
		};
	</script>
</body>
</html>